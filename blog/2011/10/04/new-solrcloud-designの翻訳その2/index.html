<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    
    <meta property="og:site_name" content="@johtaniの日記 3rd">
    <meta property="og:type" content="article">

    
    <meta property="og:image" content="https://blog.johtani.info/images/header3.jpg">
    <meta property="twitter:image" content="https://blog.johtani.info/images/header3.jpg" />
    

    
    <meta name="title" content="New SolrCloud Designの翻訳（その2）(Jugemより移植)" />
    <meta property="og:title" content="New SolrCloud Designの翻訳（その2）(Jugemより移植)" />
    <meta property="twitter:title" content="New SolrCloud Designの翻訳（その2）(Jugemより移植)" />
    

    
    <meta name="description" content="johtaniの日記です。技術とか、他愛のないことを書き連ねていくブログです。 | johtani&#39;s blog site that includes topics, e.g. technical, life, hobby, etc.">
    <meta property="og:description" content="johtaniの日記です。技術とか、他愛のないことを書き連ねていくブログです。 | johtani&#39;s blog site that includes topics, e.g. technical, life, hobby, etc." />
    <meta property="twitter:description" content="johtaniの日記です。技術とか、他愛のないことを書き連ねていくブログです。 | johtani&#39;s blog site that includes topics, e.g. technical, life, hobby, etc." />
    

    
    <meta property="twitter:card" content="summary" />
    
    

    <meta name="keyword"  content="johtani elasticsearch kibana search 検索 ">
    <link rel="shortcut icon" href="/img/favicon.ico">

    <title>New SolrCloud Designの翻訳（その2）(Jugemより移植)-@johtaniの日記 3rd | @johtani&#39;s blog 3rd edition </title>

    <link rel="canonical" href="/blog/2011/10/04/new-solrcloud-design%E3%81%AE%E7%BF%BB%E8%A8%B3%E3%81%9D%E3%81%AE2/">

    <link rel="stylesheet" href="/css/iDisqus.min.css"/>

    
    <link rel="stylesheet" href="/css/bootstrap.min.css">

    
    <link rel="stylesheet" href="/css/hux-blog.min.css">

    
    <link rel="stylesheet" href="/css/zanshang.css">

    
    <link href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css" rel="stylesheet" type="text/css">

    
    <link rel="stylesheet" href="https://blog.johtani.info/css/custom-font.css"><link rel="stylesheet" href="https://blog.johtani.info/css/amazon.css">

    
    
    <script src="/js/jquery.min.js"></script>

    
    <script src="/js/bootstrap.min.js"></script>

    
    <script src="/js/hux-blog.min.js"></script>

    
    

</head>



<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">@johtaniの日記 3rd</a>
        </div>

        
        
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/">Home</a>
                    </li>
                    
                        
                    
                    
		    
                        <li><a href="/top/about/">ABOUT</a></li>
                    

                    
		    <li>
                        <a href="/search">SEARCH <img src="/img/search.png" height="15" style="cursor: pointer;" alt="Search"></a>
		    </li>
                    
                </ul>
            </div>
        </div>
        
    </div>
    
</nav>
<script>
    
    
    
    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    $toggle.addEventListener('click', handleMagic)
    function handleMagic(e){
        if ($navbar.className.indexOf('in') > 0) {
        
            $navbar.className = " ";
            
            setTimeout(function(){
                
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        }else{
        
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }
</script>




<style type="text/css">
    header.intro-header {
        background-image: url('/images/header3.jpg')
    }
</style>
<header class="intro-header">
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <div class="tags">
                        
                        <a class="tag" href="/tags/solr" title="solr">
                            solr
                        </a>
                        
                    </div>
                    <h1>New SolrCloud Designの翻訳（その2）(Jugemより移植)</h1>
                    <h2 class="subheading"></h2>
                    <span class="meta">
                        Posted by 
                        
                            johtani
                         
                        on 
                        Tuesday, October 4, 2011
                        
                        
                        
                    </span>
                </div>
            </div>
        </div>
    </div>
</header>




<article>
    <div class="container">
        <div class="row">

            
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                post-container">

                
                <header>
                    <h2>目次</h2>
                </header>
                <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#boot-strapping">Boot Strapping</a></li>
        <li><a href="#transaction-log"><strong>Transaction Log</strong></a></li>
        <li><a href="#recovery">Recovery</a></li>
        <li><a href="#splitting-partitions">Splitting partitions</a></li>
        <li><a href="#cluster-re-balancing">Cluster Re-balancing</a></li>
        <li><a href="#cluster-re-balancing-1">Cluster Re-balancing</a></li>
        <li><a href="#configuration">Configuration</a></li>
        <li><a href="#cluster-admin-commands"><strong>Cluster Admin Commands</strong></a></li>
        <li><a href="#migrating-from-solr-to-solrcloud">Migrating from Solr to SolrCloud</a></li>
        <li><a href="#alternative-to-a-cluster-lock">Alternative to a Cluster Lock</a></li>
        <li><a href="#single-node-simplest-use-case">Single Node Simplest Use Case</a></li>
        <li><a href="#boot-strapping-1">Boot Strapping</a></li>
        <li><a href="#transaction-log-1"><strong>Transaction Log</strong></a></li>
        <li><a href="#recovery-1">Recovery</a></li>
        <li><a href="#splitting-partitions-1">Splitting partitions</a></li>
        <li><a href="#cluster-re-balancing-2">Cluster Re-balancing</a></li>
        <li><a href="#monitoring">Monitoring</a></li>
        <li><a href="#configuration-1">Configuration</a></li>
        <li><a href="#cluster-admin-commands-1"><strong>Cluster Admin Commands</strong></a></li>
        <li><a href="#migrating-from-solr-to-solrcloud-1">Migrating from Solr to SolrCloud</a></li>
        <li><a href="#alternative-to-a-cluster-lock-1">Alternative to a Cluster Lock</a></li>
        <li><a href="#single-node-simplest-use-case-1">Single Node Simplest Use Case</a></li>
      </ul>
    </li>
  </ul>
</nav>
                
                <p>遅くなりましたが、続きです。
さらに英語力のなさを痛感して凹んでいるところですが、何かの役に立てばと恥を晒すところです。。。</p>
<p>一応、訳してみたのですが、訳すのに必死になってしまい、つながりがわかっていない点もちらほら。
このあと一旦見直しつつ、再度理解する「理解編」をアップしようかと思います。
できれば、シーケンス図とかも交えつつ。（そうしないと理解ができない可能性が。。。）
前回同様、原文は最後に付加しておきます。</p>
<h3 id="boot-strapping">Boot Strapping</h3>
<h4 id="cluster-startupクラスタの起動">Cluster Startup（クラスタの起動）</h4>
<p>ノードはZookeeperのホストとポートを指定することから始めます。
クラスタの最初のノードはクラスタのschema/configとクラスタの設定を指定するとこから開始します。
最初のノードはZookeeperに設定をアップロードしてクラスタをブートします。
クラスタは「ブートストラップ」状態です。
この状態ではノード-&gt;パーティションマッピングは計算されず、クラスタはクラスタ管理コマンド以外のどんなread/writeリクエストも受け付けません。</p>
<p>クラスタの最初のノード集合が起動した後、クラスタ管理コマンド（TBD記述？？？）が管理者によって発行されます。このコマンドは整数「partitions」パラメータを受け取り、次のステップを実行します。</p>
<ol>
<li>Cluster Lockを取得</li>
<li>「partitions」をパーティション数として割り当て</li>
<li>各パーティションのためのノードを取得</li>
<li>ZooKeeperのノード-&gt;パーティションマッピングを更新</li>
<li>Cluster Lockをリリース</li>
<li>全ノードに対して最新版のノード-&gt;パーティションマッピングをZooKeeper経由で更新させる</li>
</ol>
<h4 id="node-startup"><strong>Node Startup</strong></h4>
<p>ノードが起動すると、自分がすでに存在するシャードの一部かどうかZooKeeperでチェックします。
もし、ZooKeeperがノードのレコードを持っていない、またはどのシャードの一部でもないと判断したら、
ノードは後述の「New Node」のステップを実行します。すでに存在するノードの場合は後述の「Node Restart」のステップを実行します。</p>
<p><strong>New Node</strong></p>
<p>新しいノードはクラスタの一部ではなく、クラスタのキャパシティを増強するためのものです。</p>
<p>「auto_add_new_nodes」クラスタプロパティが「false」の場合、新しいノードはZooKeeperに「idle」として登録され、他のノードが参加してくれと言うまで待機します。
そうでない場合（auto_add_new_nods=true）は次のステップを実行します。</p>
<ol>
<li>Cluster Lockを取得します。</li>
<li>適切なnode-&gt;partitionエントリを選び出します。</li>
<li>利用可能なパーティションのリストをスキャンして「replication_factor」のノード数以下のパーティションのエントリを探します。複数ある場合はノード数が最小のエントリを選びます。それも一緒ならランダムに選びます。</li>
<li>全パーティションが「replication_factor」以上のノードを持っている場合、ノードはパーティションが最も多いものをスキャンします。複数ある場合はパーティション内のドキュメント数が最大のエントリを選びます。ドキュメント数が同一なら任意のエントリを選びます。</li>
<li>もし、選んだノード-&gt;パーティションエントリを現在のノードに移動させることでがクラスタのパーティション：ノード比率の最大値を小さくするなら、現在のエントリを返します。。それ以外の場合選ばれたエントリがないので、アルゴリズムは終了です。。</li>
<li>ZooKeeper内のノード-&gt;パーティションマッピングを更新します</li>
</ol>
</li>
<li>ZooKeeper内のノードステータスを「リカバリ」状態にします</li>
<li>Cluster Lockをリリースします</li>
<li>「リカバリ」はパーティションのリーダーから開始します。</li>
<li>リカバリが終了したら、再度、Cluster Lockを取得します。</li>
<li>元のエントリはZooKeeperのノード-&gt;パーティションマッピングから削除されます。</li>
<li>Cluster Lockをリリースします</li>
<li>元のノードはZooKeeperからノード-&gt;パーティションマッピングを更新させられます</li>
<li>ステップ1に戻ります。</li>
</ol>
<h4 id="node-restart"><strong>Node Restart</strong></h4>
<p>ノードの再起動とは次のいずれかを意味しています。</p>
<ul>
<li>JVMがクラッシュし、手動または自動でのリスタート</li>
<li>ノードが一時的にネットワークから切り離された。もしくは、ZooKeeperに接続できなかった（死んでいると思われた）。または、ある一定期間、リーダーからの更新を受信できなかった。</li>
<li>このシナリオが表す書き込み処理のライフサイクルの間にネットワークから分断された</li>
<li>ハード故障もしくはメンテナンスウインドウによりクラスタからノードが分断され、ノードをクラスタにrejoinさせるために起動した。</li>
</ul>
<p>ノードが各パーティションに対してメンバーであるパーティションのリストを読み、パーティションのリーダーがリカバリプロセスを実行する。その時、ノードは「auto_add_new_nods」プロパティをチェックして、「New Node」処理のステップを実行する。
これはクラスタが。。。（元の文章が切れてて意味が不明）</p>
<p>クライアントは標準的なSolrの更新形式を利用して書き込みできます。
書き込み処理はクラスタの任意のノードに送信されます。
ノードはハッシュ関数を利用して、どのパーティションに所属するか決めるためにrange-パーティションマッピングを使います。
ZooKeeperはシャードのリーダーを識別して、書き込み処理をそこに送ります。
SolrJはリーダーに対して書き込みを直接送信するための拡張がされています。</p>
<p>リーダーはPartitionバージョンの操作を割り当て、そのトランザクションログの操作を書き込み、シャードに属する他のノードにドキュメントバージョンハッシュを転送します。
ノードはインデックスにドキュメントハッシュを書き込み、トランザクションログに操作を記録します。
リーダーは、min_writesの最小数のノード以上のノードが「OK」とレスポンスを返したら「OK」とレスポンスを返します。
クラスタプロパティのmin_writesは書き込みリクエスト時に指定することで、異なる値を指定できます。</p>
<p>クラウドモードはコミット/ロールバック操作を明示的には行いません。
コミットは特定の間隔で（commit_within）リーダーによりオートコミットにより管理されます。
また、シャードの全メンバーのコミットはトリガーにより管理されます。
ノードが利用可能な最新バージョンはコミットの時点で記録されます。</p>
<h3 id="transaction-log"><strong>Transaction Log</strong></h3>
<ul>
<li>トランザクションログは2つのコミットの間にインデックスに対して実行された操作全てを記録したもの</li>
<li>コミットはそれ以前に実行された操作の耐久性を保証するために、新しいトランザクションログを開始します。</li>
<li>同期は調整が可能です。例えば、flush vs fsynです。fsyncがデフォルトで、JVMクラッシュに対して保証できるが、電源異常の場合には保証できないが、速度的には早いです。</li>
</ul>
<h3 id="recovery">Recovery</h3>
<p>次のトリガーにより復旧が可能です。</p>
<ul>
<li>Bootstrap</li>
<li>パーティション分割</li>
<li>クラスタの再構築</li>
</ul>
<p>ノードは自身に「recovering」というステータスを設定して復旧を開始します。
このフェーズの間、ノードは読み込みリクエストを受けることができませんが、トランザくkションログに書きこまれるすべての新しい書き込みリクエストを受け取ります。
ノードは自身が持つインデックスのバージョンを調べて、パーティションの最新バージョンのリーダーに問い合わせます。
リーダーはシャード内の残りのノードと同期する前に実行されるべき操作の集合を返します（？？？）。</p>
<p>最初にインデックスをコピーし、最新のノードにあるトランザクションログをリプレイします。
もし、インデックスのコピーが必要ならば、インデックスファイルをローカルにまずコピーし、その後トランザクションログをリプレイします。
トランザクションログのリプレイは通常の書き込みリクエストの流れと同じです。
この時、ノードは新しい書き込みを受け付けるかもしれません。その書き込みはインデックスに再生されるべきです。
ある時点でノードは最新のコミットポイントに追いつき、自身のステータスを「ready」にします。
この時点で、このノードは読み込みリクエストを処理できます。</p>
<h4 id="handling-node-failures">Handling Node Failures</h4>
<p>一時的にネットワークが分断され、幾つかのノードとZooKeeperの間の通信が遮断されるかもしれません。
クラスタはデータの再構築（リバランシング）の前にしばらく待ちが発生します。</p>
<p><strong>Leader failure</strong></p>
<p>ノードが故障し、もしそれがシャードのリーダだった場合、他のメンバーがリーダー選出のプロセスを開始します。
新しいリーダーが選出されるまで、このパーティションへの書き込みは受け付けられません。
この時、これはリーダー以外の故障ステップを処理します。（？？？）</p>
<p><strong>Leader failure</strong></p>
<p>シャードの一部に新しいノードが割り当てられる前にリーダーはmin_reaction_timeの間待ちます。
リーダーはCluster Lockを取得し、シャードの新規メンバーとしてノードを割り当てるためのノード-シャード割り当てアルゴリズムを使用します。
ZooKeeperのノード-&gt;パーティションマッピングが更新され、Cluster Lockがリリースされます。
新しいノードはZooKeeperからノード-&gt;パーティションマッピングを強制的にリロードされます。</p>
<h3 id="splitting-partitions">Splitting partitions</h3>
<p>明示的なクラスタ管理コマンドもしくはSolrによる自動的な分割戦略（ストラテジ）はパーティションを分割することができます。
明示的な分割コマンド（split command）は対象となるパーティションを分割するために実行されます。</p>
<p>パーティションXが100から199のハッシュの範囲を持つものとし、X（100から149）、Y（150～199）に分割するとします。
Xのリーダーは、XとYの新しい値の範囲をZooKeeperに分割アクションを記録します。
ノードはこの分割アクションもしくは新しいパーティションの存在については通知を受けません。（？？？）</p>
<ol>
<li>XのリーダはCluster Lockを取得し、パーティションY（アルゴリズムはto be determined）を割り当てるノードを決定し、新しいパーティションを知らせ、パーティション-&gt;ノードマッピングを更新します。Xのリーダはノードのレスポンスを街、新しいパーティションがコマンドを受付可能な状態になったら次の処理を実行します。</li>
<li>Xのリーダーは分割が完了するまですべてのコミットを停止します。</li>
<li>Xのリーダーは最新のコミットポイント（バージョンVとする）のIndexReaderをオープンし、同じバージョンのIndexReaderもオープンするように命じます</li>
<li>XのリーダーはYのリーダーに対してバージョンV以降のトランザクションログのうちハッシュ値の範囲が150から199のものを流します。</li>
<li>Yのリーダーはトランザクションログの#2（#3の間違い？）で送られたリクエストだけを記録します？？？</li>
<li>Xのリーダーはステップ#2で開いたIndexReaderに対してインデックスの分割を開始します。</li>
<li>#5で作成されたインデックスはYのリーダーに送られ、登録されます。</li>
<li>Yのリーダーは「recovery」プロセスを開始するように（シャードの）他のノード命令し、インデックスのトランザクションログを再生し始めます。</li>
<li>パーティションYのすべてのノードがバージョンVに到達したならば</li>
<li>YのリーダーはXのリーダーに#2で作成されたReaderの上に、ハッシュの範囲が100から149だけに属しているドキュメントを抽出するようにするFilteredIndexReaderを準備するように頼みます。</li>
<li>Xのリーダーは#8aのリクエストが完了したのを検知したら、YのリーダーがCluster Lockを取得し、クラスタ全体の検索/登録リクエストの受信を開始するためにレンジ-&gt;パーティションマッピングを変更します。</li>
<li>YのリーダーはXのリーダーに検索リクエストのために#8aで作成されたFilteredIndexReaderの利用開始を頼みます</li>
<li>YのリーダーはXのリーダーに、ZooKeeperからレンジ-&gt;パーティションマッピングを矯正リフレッシュするように頼みます。この時点で#3で開始されたトランザクションログの流しこみが停止されるのが保証されます。</li>
</ol>
</li>
<li>Xのリーダーは自身のパーティションに存在するべきでないハッシュ値をもつドキュメントを削除し、最新のコミットポイントのsearcherを再度開きます。</li>
<li>この時点で分割は完全に終了し、Xのリーダーはcommit_withinパラメータによるコミットをレジュームします（？？？）</li>
</ol>
<p>Notes:</p>
<ul>
<li>分割操作が完了するまで、commit_withinパラメータによるパーティションの分割は実行されない</li>
<li>#8b開始から#8c終了までの間の分散検索は一貫しない検索結果を帰す場合がある（例えば：検索結果が異なる）</li>
</ul>
<h3 id="cluster-re-balancing">Cluster Re-balancing</h3>
<p>クラスタは明示的なクラスタ管理コマンドにより再構築（リバランシング）できる。</p>
<p>TBD
（to be determined）</p>
<h3 id="cluster-re-balancing-1">Cluster Re-balancing</h3>
<p>TBD
（to be determined）</p>
<h3 id="configuration">Configuration</h3>
<h4 id="solr_clusterproperties"><strong>solr_cluster.properties</strong></h4>
<p>これはクラスタ内の全ノードにわたって適用される一般的なSolr設定ファイルとは別のプロパティファイルの集合である。</p>
<ul>
<li>replication_factor：クラスタによって管理されるドキュメントのレプリカの数</li>
<li>min_writes：書き込み操作が成功になる前の最小の書き込み？？？？。これは書き込みごとに上書き設定可能</li>
<li>commit_within：検索に現れるまでの書き込み操作の最大回数</li>
<li>hash_function：ドキュメントのハッシュ値を計算するための関数の実装</li>
<li>max_hash_value：ハッシュ関数が出力することができる最大値。理論的には、この値はクラスタが保持できるパーティションの最大数でもある</li>
<li>min_reaction_time：起動、停止の後に再配分/分割にかかる時間（？？）</li>
<li>min_replica_for_reaction：レプリカノード数がこの値以下になったら、min_reaction_timeにならなくても分割が実行される。</li>
<li>auto_add_new_nodes：booleanフラグ。もしtrueなら新しいノードは自動的にパーティションからレプリカを読み込む。そうでない場合は新しいノードはクラスタに「idle」状態で登録される</li>
</ul>
<h3 id="cluster-admin-commands"><strong>Cluster Admin Commands</strong></h3>
<p>すべてのクラスタ管理コマンドはすべてのノードでパス（/cluster_admin）を与えることで実行できます。
全ノードは同じコマンドを受け付けることができ、振る舞いも同じものになるでしょう。
以下のコマンドはユーザが利用できるパブリックなコマンドです。</p>
<ul>
<li>init_cluster：（パラメータ：パーティション）このコマンドはノードの集合の初期化後に実施されます。このコマンドが実行されるまで、クラスタは読み込み/書き込みコマンドを受け付けません。</li>
<li>split_partition：（パラメータ：パーティション（任意））パーティションを2つに分割します。もしパーティションパラメータが指定されない場合は、ドキュメント数が最大の</li>
<li>add_idle_nodes：このコマンドはauto_add_new_nodes=falseの場合に利用できます。このコマンドはクラスタに対して「idle」状態のすべてのノードを追加するトリガーとなります。</li>
<li>move_partition：（パラメータ：パーティション、from、to）fromのノードからtoの別のノードに引数で指定されたパーティションを移動します。</li>
<li>command_status：（パラメータ：completion_id（任意））上記コマンドはすべて非同期で実行され、completion_idを返します。このコマンドは特定の実行中のコマンドもしくは全ての実行中のコマンドの状態を表示するために利用できます。</li>
<li>status：（パラメータ：パーティション（任意））パーティションのリストを表示し各パーティションの次の情報を表示します。</li>
<li>リーダーノード</li>
<li>ノードのリスト</li>
<li>ドキュメント数</li>
<li>平均読み込み回数（reads/sec）</li>
<li>平均書き込み回数（writes/sec）</li>
<li>平均読み込み時間（time/read）</li>
<li>平均書き込み時間（time/write）</li>
</ul>
</li>
</ul>
<h3 id="migrating-from-solr-to-solrcloud">Migrating from Solr to SolrCloud</h3>
<p>クラウドに移行するときに幾つかの特徴は不要かもしれないし、サポートされないかもしれません。
既存の（クラウドでない）バージョンでのすべての特徴をSolrCloudでサポートし続けなければなりません。</p>
<ul>
<li>レプリケーション：これは必要ありません。</li>
<li>CoreAdminコマンド：明示的なコアの操作は許可されません。内部にコアがあるかもしれないが、暗黙的に管理されるでしょう</li>
<li>複数スキーマのサポート？：単純化のため、ver1.0ではサポートしないかもしれない</li>
<li>solr.xml：SolrCloudでほんとに必要？</li>
</ul>
<h3 id="alternative-to-a-cluster-lock">Alternative to a Cluster Lock</h3>
<p>リーダーを選出する常設の調停ノード（masterはインデックスレプリケーションで利用している用語なので、「調停」とする）を持つほうが単純かもしれません。
「truth」状態をZookeeperの状態としてみなすような次のパターンでは、将来の柔軟性（クラスタを制御するためのZookeeperの状態を直接変更するような外部管理ツールのような）を考慮に入れることができます。
（毎回ロックを取得するよりも）調停ノードを持つことにより、よりスケーラブルになるかもしれません。
特定条件下でのみCluster Lockを利用するハイブリッドも意味があるでしょう。</p>
<h3 id="single-node-simplest-use-case">Single Node Simplest Use Case</h3>
<p>単一ノードでスタートして、ドキュメントをインデックス登録できないといけません。
また、あとで、クラスタに2番目のノードを追加できないと行けません。</p>
<ul>
<li>1つのノードから開始し、最初にZookeeperに設定ファイルをアップロードし、shard1にノードを作成＋登録します。</li>
<li>他の情報がない状態で設定が作成され、1つのシャードのシステムとなります。</li>
</ul>
</li>
<li>いくつかのドキュメントをインデックスします</li>
<li>他のノードが起動し、「まだ割り当てられていない場合、レプリカの最小の数をもつshardに割り当てられ、「recovery」プロセスを開始します」というパラメータを受け取ります。
* 出来れば、同一ホスト上に同じシャードはコピーしない
* この時点の後で、ノードが停止したら、再起動し、同じ役割が再開されるべきです。（Zookeeperでそれ自身であると判別されれば）
</li>
</ol>
<p>原文はこちらからです。</p>
<h3 id="boot-strapping-1">Boot Strapping</h3>
<h4 id="cluster-startup">Cluster Startup</h4>
<p>A node is started pointing to a Zookeeper host and port. The first node in the cluster may be started with cluster configuration properties and the schema/config files for the cluster. The first node would upload the configuration into zookeeper and bootstrap the cluster. The cluster is deemed to be in the “bootstrap” state. In this state, the node -&gt; partition mapping is not computed and the cluster does not accept any read/write requests except for clusteradmin commands.</p>
<p>After the initial set of nodes in the cluster have started up, a clusteradmin command (TBD description) is issued by the administrator. This command accepts an integer “partitions” parameter and it performs the following steps:</p>
<ol>
<li>Acquire the Cluster Lock</li>
<li>Allocate the “partitions” number of partitions</li>
<li>Acquires nodes for each partition</li>
<li>Updates the node -&gt; partition mapping in ZooKeeper</li>
<li>Release the Cluster Lock</li>
<li>Informs all nodes to force update their own node -&gt; partition mapping from ZooKeeper</li>
<li>The Cluster Lock is acquired</li>
<li>A suitable source (node, partition) tuple is chosen:</li>
<li>The list of available partitions are scanned to find partitions which has less then “replication_factor” number of nodes. In case of tie, the partition with the least number of nodes is selected. In case of another tie, a random partition is chosen.</li>
<li>If all partitions have enough replicas, the nodes are scanned to find one which has most number of partitions. In case of tie, of all the partitions in such nodes, the one which has the most number of documents is chosen. In case of tie, a random partition on a random node is chosen.</li>
<li>If moving the chosen (node, partition) tuple to the current node will decrease the maximum number of partition:node ratio of the cluster, the chosen tuple is returned.Otherwise, no (node, partition) is chosen and the algorithm terminates</li>
<li>The node -&gt; partition mapping is updated in ZooKeeper</li>
</ol>
<li>The node status in ZooKeeper is updated to “recovery” state</li>
<li>The Cluster Lock is released</li>
<li>A “recovery” is initiated against the leader of the chosen partition</li>
<li>After the recovery is complete, the Cluster Lock is acquired again</li>
<li>The source (node, partition) is removed from the node -&gt; partition map in ZooKeeper</li>
<li>The Cluster Lock is released</li>
<li>The source node is instructed to force refresh the node -&gt; partition map from ZooKeeper</li>
<li>Goto step #1</li>
</ol>
<h4 id="node-restart-1"><strong>Node Restart</strong></h4>
<p>A node restart can mean one of the following things:</p>
<ul>
<li>The JVM crashed and was manually or automatically restarted</li>
<li>The node was in a temporary network partition and either could not reach ZooKeeper (and was supposed to be dead) or could not receive updates from the leader for a period of time. A node restart ine node failure.</li>
<li>Lifecycle of a Write Operation this scenario signifies the removal of the network partition.</li>
<li>A hardware failure or maintenance window caused the removal of the node from the cluster and the node has been started again to rejoin the cluster.</li>
</ul>
<p>The node reads the list of partitions for which it is a member and for each partition, starts a recovery process from each partition’s leader respectively. Then, the node follows the steps in the New Node section without checking for the auto_add_new_nodes property. This ensures that the cluster recovers from the imbalance created by th</p>
<p>Writes are performed by clients using the standard Solr update formats. A write operation can be sent to any node in the cluster. The node uses the hash_function , and the Range-Partition mapping to identify the partition where the doc belongs to. A zookeeper lookup is performed to identify the leader of the shard and the operation is forwarded there. A SolrJ enhancement may enable it to send the write directly to the leader</p>
<p>The leader assigns the operation a Partition Version and writes the operation to its transaction log and forwards the document + version + hash to other nodes belonging to the shard. The nodes write the document + hash to the index and record the operation in the transaction log. The leader responds with an ‘OK’ if at least min_writes number of nodes respond with ‘OK’. The min_writes in the cluster properties can be overridden by specifying it in the write request.</p>
<p>The cloud mode would not offer any explicit commit/rollback operations. The commits are managed by auto-commits at intervals (commit_within) by the leader and triggers a commit on all members on the shard. The latest version available to a node is recorded with the commit point.</p>
<h3 id="transaction-log-1"><strong>Transaction Log</strong></h3>
<ul>
<li>A transaction log records all operations performed on an Index between two commits</li>
<li>Each commit starts a new transaction log because a commit guarantees durability of operations performed before it</li>
<li>The sync can be tunable e.g. flush vs fsync by default can protect against JVM crashes but not against power failure and can be much faster</li>
</ul>
<h3 id="recovery-1">Recovery</h3>
<p>A recovery can be triggered during:</p>
<ul>
<li>Bootstrap</li>
<li>Partition splits</li>
<li>Cluster re-balancing</li>
</ul>
<p>The node starts by setting its status as ‘recovering’. During this phase, the node will not receive any read requests but it will receive all new write requests which shall be written to a separate transaction log. The node looks up the version of index it has and queries the ‘leader’ for the latest version of the partition. The leader responds with the set of operations to be performed before the node can be in sync with the rest of the nodes in the shard.</p>
<p>This may involve copying the index first and replaying the transaction log depending on where the node is w.r.t the state of the art. If an index copy is required, the index files are replicated first to the local index and then the transaction logs are replayed. The replay of transaction log is nothing but a stream of regular write requests. During this time, the node may have accumulated new writes, which should then be played back on the index. The moment the node catches up with the latest commit point, it marks itself as “ready”. At this point, read requests can be handled by the node.</p>
<h4 id="handling-node-failures-1">Handling Node Failures</h4>
<p>There may be temporary network partitions between some nodes or between a node and ZooKeeper. The cluster should wait for some time before re-balancing data.</p>
<p><strong>Leader failure</strong></p>
<p>If node fails and if it is a leader of any of the shards, the other members will initiate a leader election process. Writes to this partition are not accepted until the new leader is elected. Then it follows the steps in non-leader failure</p>
<p><strong>Non-Leader failure</strong></p>
<p>The leader would wait for the min_reaction_time before identifying a new node to be a part of the shard. The leader acquires the Cluster Lock and uses the node-shard assignment algorithm to identify a node as the new member of the shard. The node -&gt; partition mapping is updated in ZooKeeper and the cluster lock is released. The new node is then instructed to force reload the node -&gt; partition mapping from ZooKeeper.</p>
<h3 id="splitting-partitions-1">Splitting partitions</h3>
<p>A partition can be split either by an explicit cluster admin command or automatically by splitting strategies provided by Solr. An explicit split command may give specify target partition(s) for split.</p>
<p>Assume the partition ‘X’ with hash range 100 - 199 is identified to be split into X (100 - 149) and a new partition Y (150 - 199). The leader of X records the split action in ZooKeeper with the new desired range values of X as well as Y. No nodes are notified of this split action or the existence of the new partition.</p>
<ol>
<li>The leader of X, acquires the Cluster Lock and identifies nodes which can be assigned to partition Y (algorithm TBD) and informs them of the new partition and updates the partition -&gt; node mapping. The leader of X waits for the nodes to respond and once it determines that the new partition is ready to accept commands, it proceeds as follows:</li>
<li>The leader of X suspends all commits until the split is complete.</li>
<li>The leader of X opens an IndexReader on the latest commit point (say version V) and instructs its peers to do the same.</li>
<li>The leader of X starts streaming the transaction log after version V for the hash range 150 - 199 to the leader of Y.</li>
<li>The leader of Y records the requests sent in #2 in its transaction log only i.e. it is not played on the index.</li>
<li>The leader of X initiates an index split on the IndexReader opened in step #2.</li>
<li>The index created in #5 is sent to the leader of Y and is installed.</li>
<li>The leader of Y instructs its peers to start recovery process. At the same time, it starts playing its transaction log on the index.</li>
<li>Once all peers of partition Y have reached at least version V:</li>
<li>The leader of Y asks the leader of X to prepare a FilteredIndexReader on top of the reader created in step #2 which will have documents belonging to hash range 100 - 149 only.</li>
<li>Once the leader of X acknowledges the completion of request in #8a, the leader of Y acquires the Cluster Lock and modifies the range -&gt; partition mapping to start receiving regular search/write requests from the whole cluster.</li>
<li>The leader of Y asks leader of X to start using the FilteredIndexReader created in #8a for search requests.</li>
<li>The leader of Y asks leader of X to force refresh the range -&gt; partition mapping from ZooKeeper. At this point, it is guaranteed that the transaction log streaming which started in #3 will be stopped.</li>
</ol>
</li>
<li>The leader of X will delete all documents with hash values not belonging to its partitions, commits and re-opens the searcher on the latest commit point.</li>
<li>At this point, the split is considered complete and leader of X resumes commits according to the commit_within parameters.</li>
</ol>
<p>Notes:</p>
<ul>
<li>The partition being split does not honor commit_within parameter until the split operation completes</li>
<li>Any distributed search operation performed starting at the time of #8b and till the end of #8c can return inconsistent results i.e. the number of search results may be wrong.</li>
</ul>
<h3 id="cluster-re-balancing-2">Cluster Re-balancing</h3>
<p>The cluster can be rebalanced by an explicit cluster admin command.</p>
<p>TBD</p>
<h3 id="monitoring">Monitoring</h3>
<p>TBD</p>
<h3 id="configuration-1">Configuration</h3>
<h4 id="solr_clusterproperties-1"><strong>solr_cluster.properties</strong></h4>
<p>This are the set of properties which are outside of the regular Solr configuration and is applicable across all nodes in the cluster:</p>
<ul>
<li><strong>replication_factor</strong> : The number of replicas of a doc maintained by the cluster</li>
<li><strong>min_writes</strong> : Minimum no:of successful writes before the write operation is signaled as successful . This may me overridden on a per write basis</li>
<li><strong>commit_within</strong> : This is the max time within which write operation is visible in a search</li>
<li><strong>hash_function</strong> : The implementation which computes the hash of a given doc</li>
<li><strong>max_hash_value</strong> : The maximum value that a hash_function can output. Theoretically, this is also the maximum number of partitions the cluster can ever have</li>
<li>min_reaction_time : The time before any reallocation/splitting is done after a node comes up or goes down (in secs)</li>
<li><strong>min_replica_for_reaction</strong> : If the number of replica nodes go below this threshold the splitting is triggered even if the min_reaction_time is not met</li>
<li><strong>auto_add_new_nodes</strong> : A Boolean flag. If true, new nodes are automatically used as read replicas to existing partitions, otherwise, new nodes sit idle until the cluster needs them.</li>
</ul>
<h3 id="cluster-admin-commands-1"><strong>Cluster Admin Commands</strong></h3>
<p>All cluster admin commands run on all nodes at a given path (say /cluster_admin). All nodes are capable of accepting the same commands and the behavior would be same. These are the public commands which a user can use to manage a cluster:</p>
<ul>
<li><strong>init_cluster</strong> : (params : partition) This command is issued after the initial set of nodes are started. Till this command is issued, the cluster would not accept any read/write commands</li>
<li><strong>split_partition</strong> : (params : partitionoptional). The partition is split into two halves. If the partition parameter is not supplied, the partition with the largest number of documents is identified as the candidate.</li>
<li><strong>add_idle_nodes</strong> : This can be used if auto_add_new_nodes=false. This command triggers the addition of all ‘idle’ nodes to the cluster.</li>
<li><strong>move_partition</strong> : (params : partition, from, to). Move the given partition from a given node from to another node</li>
<li><strong>command_status</strong> :(params : completion_idoptional) . All the above commands are asynchronous and returns with a completion_id . This command can be used to know the status of a particular running command or all the current running commands</li>
<li><strong>status</strong> : (params : partitionoptional) Shows the list of partitions and for each partition, the following info is provided</li>
<li>leader node</li>
<li>nodes list</li>
<li>doc count</li>
<li>average reads/sec</li>
<li>average writes/sec</li>
<li>average time/read</li>
<li>average time/write</li>
</ul>
</li>
</ul>
<h3 id="migrating-from-solr-to-solrcloud-1">Migrating from Solr to SolrCloud</h3>
<p>A few features may be redundant or not supported when we move to cloud such as. We should continue to support the non cloud version which supports all the existing features</p>
<ul>
<li>Replication. This feature is not required anymore</li>
<li>CoreAdmin commands. Explicit manipulation of cores will not be allowed. Though cores may exist internally and they meay be managed implicitly</li>
<li>Multiple schema support ? Should we just remove it from ver 1.0 for simplicity?</li>
<li>solr.xml . Is there a need at all for this in the cloud mode?</li>
</ul>
<h3 id="alternative-to-a-cluster-lock-1">Alternative to a Cluster Lock</h3>
<p>It may be simpler to have a coordinator node (we avoid the term master since that is associated with traditional index replication) that is established via leader election. Following a pattern of treating the zookeeper state as the &ldquo;truth&rdquo; and having nodes react to changes in that state allow for more future flexibility (such as allowing an external management tool directly change the zookeeper state to control the cluster). Having a coordinator (as opposed to grabbing a lock every time) can be more scalable too. A hybrid model where a cluster lock is used only in certain circumstances can also make sense.</p>
<h3 id="single-node-simplest-use-case-1">Single Node Simplest Use Case</h3>
<p>We should be able to easily start up a single node and start indexing documents. At a later point in time, we should be able to start up a second node and have it join the cluster.</p>
<p>start up a single node, upload it&rsquo;s configuration (the first time) to zookeeper, and create+assign the node to shard1.
in the absence of other information when the config is created, a single shard system is assumed
index some documents
start up another node and pass it a parameter that says &ldquo;if you are not already assigned, assign yourself to any shard that has the lowest number of replicas and start recovery process&rdquo;
avoid replicating a shard on the same host if possible
after this point, one should be able to kill the node and start it up again and have it resume the same role (since it should see itself in zookeeper)</p>


                

                <hr>
                <ul class="pager">
                    
                    <li class="previous">
                        <a href="/blog/2011/09/28/new-solrcloud-design%E3%81%AE%E7%BF%BB%E8%A8%B3%E3%81%9D%E3%81%AE%EF%BC%91/" data-toggle="tooltip" data-placement="top" title="New SolrCloud Designの翻訳（その１）(Jugemより移植)">&larr;
                            Previous Post</a>
                    </li>
                    
                    
                    <li class="next">
                        <a href="/blog/2011/10/05/solr%E3%81%AE%E6%96%B0%E3%81%97%E3%81%84%E7%AE%A1%E7%90%86%E7%94%BB%E9%9D%A2solr4-x-trunk%E7%B3%BB/" data-toggle="tooltip" data-placement="top" title="Solrの新しい管理画面（Solr4.x trunk系）(Jugemより移植)">Next
                            Post &rarr;</a>
                    </li>
                    
                </ul>

                
<div id="disqus-comment"></div>

<div id="disqus_thread"></div>
<script type="application/javascript">
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "johtaniblog2nd" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>



            </div>
            
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                
                
                <section>
                    <hr class="hidden-sm hidden-xs">
                    <h5><a href="/tags/">FEATURED TAGS</a></h5>
                    <div class="tags">
                        
                        
                        
                        
                        
                        <a href="/tags/aws" title="aws">
                            aws
                        </a>
                        
                        
                        
                        <a href="/tags/azure-search" title="azure-search">
                            azure-search
                        </a>
                        
                        
                        
                        
                        
                        <a href="/tags/berlin-buzzwords" title="berlin-buzzwords">
                            berlin-buzzwords
                        </a>
                        
                        
                        
                        <a href="/tags/cloudera" title="cloudera">
                            cloudera
                        </a>
                        
                        
                        
                        <a href="/tags/cloudera-search" title="cloudera-search">
                            cloudera-search
                        </a>
                        
                        
                        
                        
                        
                        
                        
                        <a href="/tags/conference" title="conference">
                            conference
                        </a>
                        
                        
                        
                        <a href="/tags/curator" title="curator">
                            curator
                        </a>
                        
                        
                        
                        <a href="/tags/diy%E3%82%AD%E3%83%BC%E3%83%9C%E3%83%BC%E3%83%89" title="diyキーボード">
                            diyキーボード
                        </a>
                        
                        
                        
                        <a href="/tags/elastic" title="elastic">
                            elastic
                        </a>
                        
                        
                        
                        
                        
                        
                        
                        <a href="/tags/elasticsearch" title="elasticsearch">
                            elasticsearch
                        </a>
                        
                        
                        
                        <a href="/tags/fluentd" title="fluentd">
                            fluentd
                        </a>
                        
                        
                        
                        
                        
                        <a href="/tags/hadoop" title="hadoop">
                            hadoop
                        </a>
                        
                        
                        
                        
                        
                        <a href="/tags/hugo" title="hugo">
                            hugo
                        </a>
                        
                        
                        
                        <a href="/tags/java" title="java">
                            java
                        </a>
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        <a href="/tags/kibana" title="kibana">
                            kibana
                        </a>
                        
                        
                        
                        
                        
                        <a href="/tags/kuromoji" title="kuromoji">
                            kuromoji
                        </a>
                        
                        
                        
                        
                        
                        <a href="/tags/logstash" title="logstash">
                            logstash
                        </a>
                        
                        
                        
                        <a href="/tags/lucene" title="lucene">
                            lucene
                        </a>
                        
                        
                        
                        <a href="/tags/lucene-gosen" title="lucene-gosen">
                            lucene-gosen
                        </a>
                        
                        
                        
                        <a href="/tags/manifoldcf" title="manifoldcf">
                            manifoldcf
                        </a>
                        
                        
                        
                        <a href="/tags/marvel" title="marvel">
                            marvel
                        </a>
                        
                        
                        
                        
                        
                        <a href="/tags/misc" title="misc">
                            misc
                        </a>
                        
                        
                        
                        <a href="/tags/morphlines" title="morphlines">
                            morphlines
                        </a>
                        
                        
                        
                        
                        
                        <a href="/tags/nlp100" title="nlp100">
                            nlp100
                        </a>
                        
                        
                        
                        
                        
                        <a href="/tags/octopress" title="octopress">
                            octopress
                        </a>
                        
                        
                        
                        
                        
                        <a href="/tags/paper" title="paper">
                            paper
                        </a>
                        
                        
                        
                        <a href="/tags/plugin" title="plugin">
                            plugin
                        </a>
                        
                        
                        
                        
                        
                        
                        
                        <a href="/tags/riak" title="riak">
                            riak
                        </a>
                        
                        
                        
                        <a href="/tags/rust" title="rust">
                            rust
                        </a>
                        
                        
                        
                        <a href="/tags/rust-the-book" title="rust-the-book">
                            rust-the-book
                        </a>
                        
                        
                        
                        
                        
                        <a href="/tags/search" title="search">
                            search
                        </a>
                        
                        
                        
                        
                        
                        <a href="/tags/shield" title="shield">
                            shield
                        </a>
                        
                        
                        
                        <a href="/tags/solr" title="solr">
                            solr
                        </a>
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        <a href="/tags/visual-studio-code" title="visual-studio-code">
                            visual-studio-code
                        </a>
                        
                        
                        
                        
                        
                        <a href="/tags/wikipedia" title="wikipedia">
                            wikipedia
                        </a>
                        
                        
                        
                        <a href="/tags/windows" title="windows">
                            windows
                        </a>
                        
                        
                        
                        <a href="/tags/workplace-search" title="workplace-search">
                            workplace-search
                        </a>
                        
                        
                        
                        
                        
                        <a href="/tags/yokozuna" title="yokozuna">
                            yokozuna
                        </a>
                        
                        
                        
                        <a href="/tags/zipkin" title="zipkin">
                            zipkin
                        </a>
                        
                        
                        
                        
                        
                        <a href="/tags/%E3%82%AA%E3%83%A9%E3%82%A4%E3%83%AA%E3%83%BC" title="オライリー">
                            オライリー
                        </a>
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        <a href="/tags/%E3%83%96%E3%83%AD%E3%82%B0" title="ブログ">
                            ブログ
                        </a>
                        
                        
                        
                        <a href="/tags/%E5%82%99%E5%BF%98%E9%8C%B2" title="備忘録">
                            備忘録
                        </a>
                        
                        
                        
                        <a href="/tags/%E5%8B%89%E5%BC%B7%E4%BC%9A" title="勉強会">
                            勉強会
                        </a>
                        
                        
                        
                        
                        
                        
                        
                        <a href="/tags/%E6%8C%AF%E3%82%8A%E8%BF%94%E3%82%8A" title="振り返り">
                            振り返り
                        </a>
                        
                        
                        
                        
                        
                        <a href="/tags/%E6%9C%AC" title="本">
                            本
                        </a>
                        
                        
                        
                        <a href="/tags/%E6%A4%9C%E7%B4%A2" title="検索">
                            検索
                        </a>
                        
                        
                        
                        
                        
                        <a href="/tags/%E8%AA%AD%E6%9B%B8" title="読書">
                            読書
                        </a>
                        
                        
                        
                        
                        
                        <a href="/tags/%E8%BB%A2%E8%81%B7" title="転職">
                            転職
                        </a>
                        
                        
                        
                        
                    </div>
                </section>
                

                
                
            </div>
        </div>
    </div>
</article>




<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                   
                   <li>
                       <a href='' rel="alternate" type="application/rss+xml" title="@johtaniの日記 3rd" >
                           <span class="fa-stack fa-lg">
                               <i class="fas fa-circle fa-stack-2x"></i>
                               <i class="fas fa-rss fa-stack-1x fa-inverse"></i>
                           </span>
                       </a>
                   </li>
                   
                    

                    
                    <li>
                        <a href="https://twitter.com/johtani">
                            <span class="fa-stack fa-lg">
                                <i class="fas fa-circle fa-stack-2x"></i>
                                <i class="fab fa-twitter fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    

                    

		    
                    
                    
                    <li>
                        <a target="_blank" href="https://github.com/johtani">
                            <span class="fa-stack fa-lg">
                                <i class="fas fa-circle fa-stack-2x"></i>
                                <i class="fab fa-github fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
		    
                    
                    
                    
                    <li>
                        <a target="_blank" href="https://www.linkedin.com/in//jun-ohtani-254a634a">
                            <span class="fa-stack fa-lg">
                                <i class="fas fa-circle fa-stack-2x"></i>
                                <i class="fab fa-linkedin fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
		    
                    
                    
                    
                    
                    
            
            
            
                </ul>
		<p class="copyright text-muted">
                    Copyright &copy; @johtaniの日記 3rd 2022
                    <br>
                    <a href="https://themes.gohugo.io/hugo-theme-cleanwhite">CleanWhite Hugo Theme</a> by <a href="https://zhaohuabing.com">Huabing</a> |
                    <iframe
                        style="margin-left: 2px; margin-bottom:-5px;"
                        frameborder="0" scrolling="0" width="100px" height="20px"
                        src="https://ghbtns.com/github-btn.html?user=zhaohuabing&repo=hugo-theme-cleanwhite&type=star&count=true" >
                    </iframe>
                </p>
            </div>
        </div>
    </div>
</footer>




<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>






<script>
    
    if($('#tag_cloud').length !== 0){
        async("/js/jquery.tagcloud.js",function(){
            $.fn.tagcloud.defaults = {
                
                color: {start: '#bbbbee', end: '#0085a1'},
            };
            $('#tag_cloud a').tagcloud();
        })
    }
</script>


<script>
    async("https://cdnjs.cloudflare.com/ajax/libs/fastclick/1.0.6/fastclick.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>






<script async src="https://www.googletagmanager.com/gtag/js?id=G-ZCZYDMJX3V"></script>
<script>
var doNotTrack = false;
if (!doNotTrack) {
	window.dataLayer = window.dataLayer || [];
	function gtag(){dataLayer.push(arguments);}
	gtag('js', new Date());
	gtag('config', 'G-ZCZYDMJX3V', { 'anonymize_ip': false });
}
</script>



</body>
</html>
