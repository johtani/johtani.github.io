<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: elasticsearch | @johtaniの日記 2nd]]></title>
  <link href="http://blog.johtani.info/blog/categories/elasticsearch/atom.xml" rel="self"/>
  <link href="http://blog.johtani.info/"/>
  <updated>2015-04-13T14:41:29+09:00</updated>
  <id>http://blog.johtani.info/</id>
  <author>
    <name><![CDATA[johtani]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Elasticsearch 1.5.1リリース（日本語訳）]]></title>
    <link href="http://blog.johtani.info/blog/2015/04/13/elasticsearch-1-5-1-released-ja/"/>
    <updated>2015-04-13T11:34:31+09:00</updated>
    <id>http://blog.johtani.info/blog/2015/04/13/elasticsearch-1-5-1-released-ja</id>
    <content type="html"><![CDATA[<p><strong>※この記事は次のブログを翻訳したものになります。</strong></p>

<p>原文：<a href="https://www.elastic.co/blog/elasticsearch-1-5-1-released">Elasticsearch 1.5.1 Released</a></p>

<p>本日（4/9）、<strong>Lucene 4.10.4</strong>ベースの<strong>Elasticsearch 1.5.1</strong> をリリースしました。
このリリースはElasticsearchの最新の安定バージョンとなります。</p>

<p>すべての変更については<a href="https://www.elastic.co/downloads/past-releases/elasticsearch-1-5-1">download Elasticsearch 1.5.1 here</a>をごらんください。</p>

<!-- more -->


<p>本リリースはシャードを新しいノードに配置するスピードを改善するためのバグフィックスを含んでいます。
シャードのリカバリーの最初のフェーズで、コピー元のノードからコピー先のノードへすべてのセグメントをコピーします。
このフェーズ中には登録、更新削除のリクエストはトランザクションログに記録され、リカバリが終了したあとに
コピー先のノードでトランザクションログが再生されます。
シャードが非常に大きい場合に、このトランザクションログはリプレイされるのに必要な多くのイベントを保存します。</p>

<p>以前では、新しいセグメントのマージはリカバリ中のコピー先のノードでは、実行できませんでした。
よって、大きなトランザクションログが新しい小さなセグメントを生成します。
これはリカバリのスピードに非常に影響があります。Issue <a href="https://github.com/elastic/elasticsearch/pull/10463">#10463</a>は
リカバリ中のコピー先のシャードのマージを可能にする変更です。</p>

<p>その他の注目すべきバグフィックスは次のものになります。</p>

<ul>
<li>多くの削除のrefreshを強要した場合にバージョンマップがいっぱいになる問題の解消(<a href="https://github.com/elastic/elasticsearch/pull/10312">#10312</a>)</li>
<li>多数のスナップショットを含んだリポジトリの管理の改善(<a href="https://github.com/elastic/elasticsearch/pull/10366">#10366</a>)</li>
<li>実験的な機能である<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-request-inner-hits.html">inner hits</a>のバグフィックス(<a href="https://github.com/elastic/elasticsearch/pull/10388">#10388</a>, <a href="https://github.com/elastic/elasticsearch/pull/10353">#10353</a>, <a href="https://github.com/elastic/elasticsearch/pull/10309">#10309</a>, <a href="https://github.com/elastic/elasticsearch/pull/10235">#10235</a>)</li>
</ul>


<p>最後に、<a href="https://www.elastic.co/blog/deprecating_rivers">Riverが非推奨となりました</a>、まだ見ていない場合は記事をご覧ください。</p>

<p>ぜひ、<a href="https://www.elastic.co/downloads/past-releases/elasticsearch-1-5-1">Elasticsearch 1.5.1</a>をダウンロードして、試してみてください。
そして、感想をTwitter(<a href="https://twitter.com/elastic">@elastic</a>)などで教えて下さい。
また、問題がありましたら、<a href="https://github.com/elastic/elasticsearch/issues">GitHub issues page</a>で報告をお願いします。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Elasticsearch勉強会 in 名古屋を開催しました。#elasticsearch #elasticsearchjp]]></title>
    <link href="http://blog.johtani.info/blog/2015/04/04/elasticsearch-study-session-at-nagoya/"/>
    <updated>2015-04-04T09:47:19+09:00</updated>
    <id>http://blog.johtani.info/blog/2015/04/04/elasticsearch-study-session-at-nagoya</id>
    <content type="html"><![CDATA[<p><a href="https://elasticsearch.doorkeeper.jp/events/21984">Elasticsearch勉強会 in 名古屋</a>を開催しました。
初の東京以外での勉強会です。
企画、セッションなどお手伝いいただいた<a href="https://twitter.com/smogami">@smogami</a>さん、<a href="https://twitter.com/mzp">@mzp</a>さんありがとうございました！</p>

<p><img src="/images/entries/20150406/nagoya.jpg" width="500"></p>

<!-- more -->


<h2>Elasticsearch/ELK stack紹介 @johtani</h2>

<p>スライド：<a href="https://speakerdeck.com/johtani/introduction-elasticsearch-and-elk-elasticsearchmian-qiang-hui-in-nagoya">Introduction Elasticsearch</a></p>

<p>初回（次回があるかはわかりませんが。。。）ということもあり、Elasticsearchの説明を行いました。
あと、LogstashとKibanaも。
Kibanaについては、手元の環境でいつものアクセスログのデモやなどを行いました。
また、LTの後に時間があったので、前回の勉強会で利用したチェックリストの説明なども。</p>

<h2>スタンドファームにおけるElasticsearch導入事例 <a href="https://twitter.com/mzp">@mzp</a> さん</h2>

<p>スライド：後日アップ？</p>

<ul>
<li>使ってるのはKibana3</li>
<li>アクセスログが保存されてたけど、活用できてなかった。</li>
<li>Fluentd、Elasticsearch、Kibanaをいれて、可視化してみた。</li>
<li>普通にログ検索が簡単にできて嬉しい</li>
<li>システムのレスポンスの性能値などを可視化できるようにして性能改善中</li>
</ul>


<h2>Kibanaでログ分析を1年続けてみたら業務システムの保守と運用が捗った(仮) <a href="https://twitter.com/smogami">@smogami</a> さん</h2>

<p>スライド：「<a href="https://speakerdeck.com/exoego/how-and-why-i-have-been-leveraging-kibana-for-devops">Kibanaでログ分析を1年続けてみたら業務システムの保守と運用が捗った</a>」</p>

<ul>
<li>名古屋でJavaの勉強会を主催してみたり（最近できてないけど）</li>
<li>導入するのになかなか大変だった（ファイアウォールだったりが）。。。</li>
</ul>


<p>Kibanaを使ってどんなことをしてるのか？</p>

<ul>
<li>既存システムなどの機能の実行回数やレスポンス時間の推移</li>
<li>曜日ごとにもチェック</li>
<li>どの機能がよく使われるのか？</li>
<li>対象となっているシステムはJavaのシステム。</li>
</ul>


<p>QA</p>

<ul>
<li>Q：ログの出力は新規に追加したのか？

<ul>
<li>A : ログの出力自体はLog4Jの設定を変更しただけ。もともと、各メソッドの開始と終了にそれぞれ時間が出力される仕組みがある。<br/>
ログの読み込み自体は自作ツールを利用。</li>
</ul>
</li>
</ul>


<h2>飛び込みLT <a href="https://twitter.com/dabits">@dabits</a> さん</h2>

<p>スライド：未定</p>

<p>Kibanaの使い道</p>

<ul>
<li>KPIツール</li>
<li>エゴサーチツール - Twitterや2chなどのデータを解析ソーシャル分析みたいな感じ？</li>
<li>ダッシュボードを用意してあげる場合もあるが、触っていろんな機能を試す人も。</li>
</ul>


<h2>感想・反省点など</h2>

<p>30名弱の方に参加していただきました。ありがとうございました。
東京の勉強会でもそうですが、半分くらいが検索、半分くらいがログ解析関連に興味がある感じでした。
飛び込みLTもしていただけましたし。会場内限定の話もいくつか。</p>

<h4>場所</h4>

<p>場所が少しわかりにくかったかなと。。。建物の入り口に看板がないので、1名に看板役として立っていただきました。
ただ、設備は充実していましたし、室内も綺麗でよかったです。</p>

<p><img src="/images/entries/20150406/seminar_room.jpg" width="300"></p>

<h4>懇親会</h4>

<p>11名（+私）でした。美味しい手羽先などをいただきながら、Elasticsearch以外のことでも盛り上がりましたw。
また、名古屋の観光名所なども教えてもらったりと有意義な時間でしたw。</p>

<p>ということで、少しでもElasticsearch、Kibana、Logstashなどのユーザが増えてくれればうれしいかなと。
私抜きでも勉強会はできると思うので、今後も開いてもらえるとうれしいかぎりです。
初めての東京以外での勉強会でどんな感じの方が利用しているのか、興味があるのかといったことも知ることができました。</p>

<h2>関連ブログなど</h2>

<ul>
<li><a href="http://blog.exoego.net/2015/04/kibana4-use-case.html">Kibana4活用事例を話しました</a></li>
</ul>


<h2>その他（余談）</h2>

<p>コンパルという喫茶店のアイスコーヒー。ちょっと新鮮な体験でした。
<img src="/images/entries/20150406/ice_coffee.jpg" width="300"></p>

<p>あとは、日曜日に観光場所として教えてもらった、<a href="http://www.tcmit.org/">トヨタ産業技術記念館</a>にも行ってみました。
一人だったけど、非常に楽しめました。実演とかあって、わかりやすいし。
トヨタが自動織機の会社が始まりだってのは知らなかった。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Elasticsearch 1.5.0リリース（日本語訳）]]></title>
    <link href="http://blog.johtani.info/blog/2015/04/01/elasticsearch-1-5-0-released-ja/"/>
    <updated>2015-04-01T12:38:16+09:00</updated>
    <id>http://blog.johtani.info/blog/2015/04/01/elasticsearch-1-5-0-released-ja</id>
    <content type="html"><![CDATA[<p><strong>※この記事は次のブログを翻訳したものになります。</strong></p>

<p>原文：<a href="https://www.elastic.co/blog/elasticsearch-1-5-0-released">Elasticsearch 1.5.0 Released</a></p>

<p>本日（3/23）、<strong>Lucene 4.10.4</strong>ベースの<strong>Elasticsearch 1.5.0</strong> をリリースしました。
このリリースはElasticsearchの最新の安定バージョンとなります。
多くの<em>resiliency(復元性、弾力性) enhancement</em>とバグフィックスを含んでおり、
すべてのユーザにアップグレードを推奨しています。</p>

<p>すべての変更については<a href="https://www.elastic.co/downloads/past-releases/elasticsearch-1-5-0">download Elasticsearch 1.5.0 here</a>をごらんください。</p>

<p>460PRという大量の変更を含む本リリースは、Elasticsearchをよりresilient(弾力のあるもの)にするために
費やされています。</p>

<!-- more -->


<h3>Inner hits</h3>

<p>本リリースで追加された、Elasticsearchに最もリクエストされたものの一つがinner hitsです。
これは、<code>has_child</code>もしくは<code>nested</code>クエリにマッチした子のドキュメントを、各親ドキュメントと一緒に返すことができます。</p>

<p>例えば、<code>blog</code>という親ドキュメントと<code>comment</code>という子ドキュメントを持っているとします。
この時、&#8221;full text search&#8221;というコメントを持ったブログ記事を検索したいとします。</p>

<pre><code class="json">GET /my_index/blog/_search
{
  "query": {
    "has_child": {
      "type":       "comment",
      "score_mode": "sum",
      "query": {
        "match": {
          "body":   "full text search"
        }
      }
    }
  }
}
</code></pre>

<p>上記のリクエストは、親の<code>blog</code>ドキュメントを返します。
しかし、どのコメントが関係しているのかはわかりません。
関連しているコメントを検索して親ごとにグルーピングするために、
少し手間のかかる2回目のクエリを実行する必要があります。</p>

<p>Inner hitsがこれを変えてくれます。
<code>inner_hits</code>パラメータを次のように、上記のクエリに追加するだけです！</p>

<pre><code class="json">GET /my_index/blog/_search
{
  "query": {
    "has_child": {
      "type":       "comment",
      "score_mode": "sum",
      "query": {
        "match": {
          "body":   "full text search"
        }
      },
      "inner_hits": {}
    }
  }
}
</code></pre>

<p>検索結果の各<code>blog</code>記事に、<code>inner_hits</code>という項目があり、そこに検索にヒットしたコメントの
上位3件（デフォルト値）が返ってきます。</p>

<pre><code class="json">...
"hits": [
  {
    "_index":   "my_index",
    "_type":    "blog",
    "_id":      1,
    "_score":   3.68,
    "_source":  { ... },
    "inner_hits": {
      "comment": {
        "total": 16,
        "hits": [
          {
            "_type":    "comment",
            "_id":      5,
            "_score":   2.79,
            "_source": {
              "body":   "Full text search is the bomb"
            }
          },
          { ... },
          { ... }
        ]
      }
    }
  }
]
...
</code></pre>

<p><code>inner_hits</code>部分は、第2の検索リクエストに似ています。
<code>size</code>や<code>from</code>パラメータを含めるくことで、挙動をカスタマイズできます。
また、検索から想像するであろう、ページネーション、ソート、ハイライト、<code>_source</code>フィルタリングなどといった機能もサポートします。</p>

<p>Inner hitsはparent-childおよび、<code>nested</code>ドキュメントをサポートします。
この機能は、現時点では<code>experimental</code>ラベルが付与されています。
このラベルは、この機能が将来変更されたり、削除されたりする可能性があるかもしれないことを意味します。
詳細については、<a href="https://www.elastic.co/guide/en/elasticsearch/reference/1.5/search-request-inner-hits.html">Inner Hits documentation</a>をごらんください。</p>

<h3>Shadow replicas</h3>

<p>Elasticsearchはそれ自身の冗長性に常に気をつけています。
それは、レプリカシャード（各プライマリシャードの冗長なコピー）を持っています。
これは、プライマリシャードを失った時に、データをロスしないようにするためのものです。
レプリカシャードはまた、検索のスループットをスケールアウトするためにも利用できます。
多くのレプリカ（ノードを伴うことで。）はスループットを増加させます。</p>

<p>しかし、ユーザによってはElsticsearchを分散ファイルシステム上でホスティングしており、すでに、
ファイルシステムがレプリケーションと冗長性を担当しています。
ファイルシステムが同じことしているので、各シャードのコピーを複数持つことはあまり意味がありません。</p>

<p>Shadowレプリカはノードを追加することによる検索スループットをスケールアウトすることが、
余分なストレージやインデキシングのコストを払うことなく、可能になります。
代わりに、各シャドーレプリカはプライマリシャードを持っている共有ファイルシステムにread-onlyでアクセスします。
Shadowレプリカは定期的にファイルシステムのビューをリフレッシュし、プライマリシャードのどんな変更も検知するでしょう。</p>

<p>プライマリシャードが失敗したら、Shadowレプリカがプライマリに昇格し、
失敗したプライマリによって書き込まれたトランザクションログを読み込みリプレイできます。</p>

<p>この機能は<em>experimental</em>マークが付いています。詳細については<a href="https://www.elastic.co/guide/en/elasticsearch/reference/1.5/indices-shadow-replicas.html">Shadow Replicas documentation</a>をごらんください。</p>

<h3>Resiliency improvements</h3>

<p>Elasticsearch 1.1 から 1.3では、インデックスのすべてのファイルのチェックサムを追加し、
それらのファイルが壊れているかどうかをチェックするために利用することにフォーカスしました。
1.4では、Zen discoveryと分散モデルについて大きな改良を加えました。</p>

<p>これらの変更にともなう、より詳細な統計情報やより詳細なロギングがElasticsearchやLuceneの以前のバージョンに存在した
未知の問題を明るみに出しました。
Elasticsearch 1.5.0では、これらの問題の多くに対処しています。</p>

<ul>
<li><p>ElasticsearchとLuceneの以前のバージョンにあるバグがインデックスの故障を引き起こしていました。<br/>
チェックサムコードのおかげで、これらを発見できました。現在は、Elasticsearchの起動時に自動的にLucene3.x<br/>
(Elasticsearch 0.20.x以前)が作成したセグメントを検知して、シャードをオープンする前に、新しいフォーマットを使って、
新しいコミットポイントを書き出します。(<a href="https://github.com/elastic/elasticsearch/pull/9899">#9899</a>)</p></li>
<li><p>1.3.xもしくは以前のバージョンからローリングアップグレードは、ローカルのシャードデータを再利用しようとせずに、<br/>
シャード全体をコピーしようとします。1.3.2と以前のバージョンが実行されているノードからローリングアップグレードすることは
圧縮をオフにしない限りできなくなりました。(<a href="https://github.com/elastic/elasticsearch/pull/9925">#9925</a>)<br/>
1.3.xやそれ以前のバージョンからアップグレードする場合、ローリングアップデートする代わりにクラスタの再起動を考えたほうがいいかもしれません。</p></li>
<li><p>非同期環境は予測することが難しいです。時に、最も予測していないことが起きるからです。<br/>
シャード配置、リカバリ、削除のコードの多くが単純化され、状態変更をよりアトミックで決定的にするための変更によりリファクタリングされました。<br/>
(<a href="https://github.com/elastic/elasticsearch/pull/8720">#8720</a>, <a href="https://github.com/elastic/elasticsearch/pull/9799">#9799</a>, <a href="https://github.com/elastic/elasticsearch/pull/9784">#9784</a>, <a href="https://github.com/elastic/elasticsearch/pull/9801">#9801</a>, <a href="https://github.com/elastic/elasticsearch/pull/9083">#9083</a>, <a href="https://github.com/elastic/elasticsearch/pull/8579">#8579</a>, <a href="https://github.com/elastic/elasticsearch/pull/8436">#8436</a>, <a href="https://github.com/elastic/elasticsearch/pull/8092">#8092</a>, <a href="https://github.com/elastic/elasticsearch/pull/9902">#9902</a>, <a href="https://github.com/elastic/elasticsearch/pull/6644">#6644</a>, <a href="https://github.com/elastic/elasticsearch/pull/8350">#8350</a>, <a href="https://github.com/elastic/elasticsearch/pull/9770">#9770</a>, <a href="https://github.com/elastic/elasticsearch/pull/9616">#9616</a>, <a href="https://github.com/elastic/elasticsearch/pull/9439">#9439</a>, <a href="https://github.com/elastic/elasticsearch/pull/8350">#8350</a>, <a href="https://github.com/elastic/elasticsearch/pull/8494">#8494</a>)</p></li>
<li><p>同様に、変更はクラスタ状態の更新が常に前進するということを確実にしました。更新の受け取り順序が順不同であったり、<br/>
マスターだったノードからの更新を受け取った場合に混乱させていました。
(<a href="https://github.com/elastic/elasticsearch/pull/9632">#9632</a>, <a href="https://github.com/elastic/elasticsearch/pull/9541">#9541</a>, <a href="https://github.com/elastic/elasticsearch/pull/9503">#9503</a>)</p></li>
<li><p>チェックサムとチェックサムのバリデーションの強化(<a href="https://github.com/elastic/elasticsearch/pull/8723">#8723</a>,<br/>
<a href="https://github.com/elastic/elasticsearch/pull/8599">#8599</a>, <a href="https://github.com/elastic/elasticsearch/pull/8587">#8587</a>, <a href="https://github.com/elastic/elasticsearch/pull/8407">#8407</a>, <a href="https://github.com/elastic/elasticsearch/pull/8010">#8010</a>, <a href="https://github.com/elastic/elasticsearch/pull/8018">#8018</a>)</p></li>
<li><p>disk threshold allocation deciderを速く(<a href="https://github.com/elastic/elasticsearch/pull/8803">#8803</a>)、賢く(<a href="https://github.com/elastic/elasticsearch/pull/7785">#7785</a>)、自動化(<a href="https://github.com/elastic/elasticsearch/pull/8270">#8270</a>)</p></li>
<li><p>auto-generated IDの利用時のインデキシングのスピードアップのためのに追加された最適化を除去。<br/>
たまにドキュメントを重複して登録するため(<a href="https://github.com/elastic/elasticsearch/pull/7729">#7729</a>)</p></li>
</ul>


<h3>Download now</h3>

<p>ぜひ、<a href="https://www.elastic.co/downloads/past-releases/elasticsearch-1-5-0">Elasticsearch 1.5.0</a>をダウンロードして、試してみてください。
そして、感想をTwitter(<a href="https://twitter.com/elastic">@elastic</a>)などで教えて下さい。
また、問題がありましたら、<a href="https://github.com/elastic/elasticsearch/issues">GitHub issues page</a>で報告をお願いします。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[セキュリティ向けプラグインShieldのリリース（日本語訳）]]></title>
    <link href="http://blog.johtani.info/blog/2015/02/27/you-know-for-security-shield-goes-ga-ja/"/>
    <updated>2015-02-27T18:49:56+09:00</updated>
    <id>http://blog.johtani.info/blog/2015/02/27/you-know-for-security-shield-goes-ga-ja</id>
    <content type="html"><![CDATA[<p><strong>※この記事は次のブログを翻訳したものになります。</strong></p>

<p>原文：<a href="http://www.elasticsearch.org/blog/you-know-for-security-shield-goes-ga/">you know, for security: shield goes ga</a></p>

<p>1/27にShield 1.0 をリリースしました。
Elasticsearch向けの私たちのセキュリティプラグインの最初のリリースです。
11月にShieldについてアナウンスしてから、Elsaticsearchのためのセキュリティの機能は、
一般的に望まれているものから始まり、具体的な考えと実行できる計画へと変遷し、それが、いま現実となりました。</p>

<p>十分にセキュアな環境に、Elasticsearchクラスタをセキュアな状態でデプロイできるようにするため、
私たちは継続的にカスタマーやユーザーからのリクエストを受け取り、統合されたソリューションになるようにしてきました。</p>

<p>私たちは、そのようなプロダクトがどうあるべきか調査することから始め、
カスタマーとユーザが必要とするセキュリティとはどんなものかを理解するために多くの時間を費やしました。
その結果がShieldです。
Shieldは、ElasticsearchクラスタをセキュアにするElasticsearchの有償プラグインです。
私たちは、ShieldをDev、Gold、Platinumサブスクリプションの一部として、追加料金なしで提供します。</p>

<p>最初のリリースでは、基本的な機能と基盤にフォーカスしています。
Elasticsearch自身に対しても、セキュリティに対して準備してきました。
拡張性の側面だけでなく、Elasticsearchにあるデータフローについても再考してきました。
Elasticsearchクラスタをセキュアにする場合に、具体的な価値を即座に届けるだけでなく、素早く拡張できるようにも開発しました。</p>

<!-- more -->


<h3>機能</h3>

<p>Shield 1.0は次の5つにフォーカスしています。</p>

<ul>
<li>認証(Authentication)</li>
<li>認可(Authorization)</li>
<li>暗号化通信とノードの認可(Encrypted Communication &amp; Node Authentication)</li>
<li>IPフィルタリング</li>
<li>監査証跡(Audit Trail)</li>
</ul>


<h3>認証(Authentication)</h3>

<p>セキュリティの大部分はアイデンティティについてです（例えば、だれがこのAPIを呼び出したのか？システムに何のサービスが接続するか？など）
サービスのライフタイムのある時点で、サブジェクト（例えばユーザー）を現在実行中のサブプロセスなどに結びつけることです。
この関係性を持つためには、サブプロセスを実行する前にユーザの身元を確認するように命じます。
ユーザの身元の確認のプロセスをAuthenticationと呼び、ElasticsearchのすべてのAPIコールでそれが実行されます。</p>

<p>認証の手法は多くの異なるものがあります。
それぞれの手法は、ユーザが認証されたという資格（Authentication Token）を、それぞれのタイプで提供するようにユーザに要求します。
Shield 1.0ではシンプルに、必要なauthentication tokenをユーザ/パスワードペアとしています。
（これは、Shieldの認証基盤が簡単に拡張でき、将来は異なるauthentication tokenもサポートできることを意味します。）</p>

<p>ユーザの資格を受け取ることだけでは不十分で、次に、それらをチェックする必要があります。
Shieldでは、これはレルムの責務です。
レルムは認証プロバイダ/サービスとしてみることができます。
妥当なユーザであると判断/解決されたか、
authentication tokenが適切な資格を持っていない/単に知らないユーザであるということで、拒否されたかです。
Shieldの認証メカニズムでは、複数のレルムを設定でき、さらに、あるレルムの戻り値を扱う他のレルム、というようなchainとすることもできます。
Shield 1.0は3つのレルムをサポートします。</p>

<ul>
<li>esusers - Elasticsearchによって管理されるファイルベースのレルムです。
これは、ファイルにユーザを定義することができます。（Apacheサーバのhtpasswdファイルのようなもの）
このレルムは外部への依存はなく、Shieldをインストールすれば、デフォルトで使用できます。
このレルムは配置が簡単で、マルチテナントなElasticsearchクラスタに対して使用できます。
マルチテナントなElasticsearchクラスタとは、クラスタを複数のアプリでシェアすることをテナントと言います。
また、すべてのユーザがパスワードを忘れてしまうような&#8221;emergency&#8221;な代替レルムも対応可能です。
(誰もシステムに入れないような状況のことです)</li>
<li>LDAP - 外部のLDAPサーバでユーザを認証するレルムです。
このレルムは組織のLDAPサーバで管理/保存されているユーザをすでに持っている組織を対象としています。</li>
<li>Active Directory - LDAPのタイプの1つで、Active Directoryに対する設定になります。</li>
</ul>


<p>レルムはelasticsearch.yml設定ファイルで、次のように設定可能です。</p>

<blockquote><p>shield.authc
    realms:</p>

<pre><code>    esuser:
        type: esusers
        order: 0

    ldap:
        type: ldap
        order: 1
        url: ldaps://url/to/ldap1/server

    ldap_fallback:
        type: ldap
        order: 2
        url: ldaps://url/to/ldap2/server
</code></pre></blockquote>

<p>上記のようにrealmsが一つのチェインとして参照されます。
レルムごとに、設定された順序で、それらは参照されます。</p>

<p>NOTE : Shieldには、esusersファイルに保存されたユーザを管理するためのコマンドラインツールもあります。</p>

<h2>認可(authorization)</h2>

<p>認可(Authorization)は保護されたリソースにアクセスするユーザを許可するか拒否するかということです。
モダンなシステムは、ユーザのパーミッションのために、ロールベースのアクセスコントロール（RBAC）モデルを利用します。
このモデルでは、各ユーザはロールの集合に関連していて、それぞれのロールには、パーミッションの集合が定義されています。
これは、洗練された設定で、パーミッションを機能的なグループで共有させることができます。
例えば、次のようなロールを定義したとします。</p>

<ul>
<li><em>employee</em> - すべての従業員は部門をまたいだ会社のデータへアクセスできます（例えば、コンタクトやディレクトリ情報など）</li>
<li><em>sales</em> - すべての営業職は営業データにアクセスできる（例えば、流通ルート、ルート、顧客）</li>
<li><em>finace</em> - すべての財務の従業員は財務データにアクセスできる（例えば、予算、経費、伝票）</li>
</ul>


<p>財務部門の<code>Ann</code>は従業員と財務のロールを持っており、会社のディレクトリと財務データにアクセスでできます。</p>

<p>認可プロセスはユーザがリクエストに関連したユーザが必要で、このプロセスのために、認証フェーズの後に直接実行されます。</p>

<p>Shieldは2つのタイプのリソースを定義します。クラスタとインデックスです。
これらは、すべてのAPIコールで保護されます。
さらに、それらに関連したパーミッションとロールも定義できます。
一度定義をすると、ロールはユーザもしくはLDAP/ADのグループに関係します。
ロールは<strong>roles.yml</strong>設定ファイルで定義されます。
設定のサンプルは次のようになります。</p>

<pre><code>admin:
    cluster: all
    indices:
        '*' : all

monitor:
    cluster: monitor
    indices:
        '*': monitor

employee:
    indices:
        'company_directory' : read

sales:
    indices:
        'opportunities' : read, write
        'accounts' : read, write

finance:
    indices:
        'expenses' : read, write
        'purchases' : read, write
</code></pre>

<p>上記のサンプルで、次の5つのロールを定義しています。</p>

<ul>
<li><em>admin</em> - 管理者のロールで、すべてのクラスターレベルの操作とすべてのインデックスに対してすべてのインデックスレベルの操作を実行可能です。
(¥*インデックスはすべてのインデックスにマッチするワイルドカード)</li>
<li><em>monitor</em> - システム/クラスタのモニタリングのためのロール。このロールのユーザはすべてのクラスタとインデックスレベルの情報の読み取りの
APIにアクセス可能だが、インデックスのデータへの読み書きや設定の更新は不能</li>
<li><em>employee</em> - compnay_directoryにあるすべてのデータへの読み取りアクセスを与えられたロール。このロールはクラスタレベルへのアクセスやデータの書き込みアクセスは持っていない
(特にcompany。洗濯されたグループの人々はcompanyディレクトリの更新は可能だが、employeeは読み取りのみが可能)</li>
<li><em>sales</em> - opportunitiesとaccountsインデックスの読み書きができるロール</li>
<li><em>finance</em> - expensesとpurchasesの両方に読み書きができるロール</li>
</ul>


<p>上記のサンプルで定義されている<code>all</code>と<code>read</code>と<code>write</code>として名前がつけられた権限です。
これらは、予約語で、Elasticsearchのローレベルのアクションを複数含んだ権限です。
（<code>write</code>は<code>index, delete, delete_by_query, bulk, update</code>の操作を含んでいます。）
多くのケースで、これらのハイレベルの名前が付けられた権限で十分ですが、特定のロールに特定のアクションを明示的に指定することもできます。
次のようになります。</p>

<pre><code>hr:
    indices:
        'company_directory' : indices:data/write/index, indices:data/write/update
</code></pre>

<p>ここまで説明した認可のレルムは、各ユーザに関連するロールを識別するためのものです。
内部のesuserレルムでは、提供されるesuserコマンドラインツールを使ってロールはユーザに割り当てたり変更したりもできます。
LDAPやActive Directoryでは、LDAP/ADグループにShieldのロールを割り当てることができます。</p>

<p>認証と認可の両方を用いることで、ユーザリクエストに対して、ユーザごとに許可/不許可をすることができます。</p>

<h3>暗号化通信</h3>

<p>認可はElasticsearchのデータを機能的な観点（許可されたユーザだけが操作を可能にする）で保護しますが、
クライアントからElasticsearchクラスタへ、もしくはクラスタのノード間では暗号化されていないデータを送るためまだ危険があります。
第三者が登頂したり、オンザフライでデータを書き換えたりといった可能性やクラスタを壊すことができます。</p>

<p>Shield 1.0はElasticsearchのすべての通信チャネルをセキュアにすることができます。
クラスタ内のノード間のチャネルやクライアントに公開されているチャネルです。
これは、SSL/TLS通信を導入して実現します。</p>

<p>Shieldで使えるSSLはElasticsearchのtransportサービスをSSL/TLSで通信できるものに置き換えます。
これは、ノード間通信チャネルと、HTTP transport（REST APIを提供するもの）のそれぞれに設定可能です。</p>

<p>ShieldのSSL/TLSは、スタンダードなJavaのものとkeystoreとtruststoreを基本にしたものが利用可能です。
SSL/TLSを設定すると、各ノードのキーストアに証明書をインポートする必要があります。
CAがサインした証明書を使うことも、CAが信頼したものとして許可許諾されたものを使うことが可能です。
これは、信頼されたすべてのCAとして知られているtrust storeが必要です。
新しいノードをクラスタに追加するときに、すべての必要な少なくとも一つの信頼されたCAから発行されてサインされたものが必要になります。
クラスタで個別のノードがすべてのkeystore/truststoreを更新する必要性なしに。？？</p>

<p>通信チャネルを安全にする方法やSSL/TLS設定をどのように行うかは<a href="http://www.elasticsearch.org/guide/en/shield/current/securing-nodes.html">Shieldのドキュメント</a>をご覧ください。</p>

<h3>ノード間認証</h3>

<p>強く推奨しますが、許可されたノードだけがクラスタに接続できるようにするために、ノードの認証をSSL transportに設定することができます。
これは、<code>shield.transport.client.auth</code>に<code>true</code>を設定することで可能です。
設定した場合、ノード間でSSLハンドシェイクが行われ、接続されたノードが接続に来たノードのクライアント認証を要求しチェックします。
もし、チェックに失敗した場合は、SSLシェイクハンドが失敗し接続が拒否されます。</p>

<h3>SSLクライアント認証</h3>

<p>transportレベルでノード認証が必要なようなら、次のような疑問がわくでしょう。
Elasticsearchはクラスタに接続するTransportクライアントを使うときはどのように振る舞うのか？
Transportクライアントはクラスタの他のノードと同じチャネルを使うため、コネクションを確立するときに、ノードが他のノードと異なるかどうかを見極めることはできません。</p>

<p>この時、もっとも単純な解決は、Transportクライアントも同様に許可を与えることです。
それは、認証を解決するときに、他の問題（潜在的な悪意）を引き起こします。
Transportクライアントが他のクラスタのノードを偽装しようとすることです。これは望んでいません。</p>

<p>幸いなことに、良い解決方法があります。
トランスポートプロファイルです。
Elasticsearch 1.4で導入されたトランスポートプロファイルは、トランスポートレイヤー（異なるホスト/ポートにバインドされる）のために複数のネットワークチャネルを設定することができます。
Shieldはこのサポートを、プロファイルごとに異なるSSL設定をできるように拡張します。
また、ノードのタイプとクライアントプロファイルタイプの間に明確な違いを設定することも可能です。
これを用いると、2つのプロファイルを設定できるようになります。
ひとつは、クライアントのためのもので、もうひとつはクラスタのノードのためのものです。
これにより、クライアントのための認証の問題が必要なくなり、Shieldはクライアントプロファイルをもった限定されたクライアントからのリクエストを保証します。</p>

<h3>IPフィルタリング</h3>

<p>これは、厳密には、認証カテゴリではありませんが関係しています。
Shieldはそれ自身がIPフィルタリングのメカニズムを持っています。
これは、許可/不許可のIPのリストを設定することができます。
これらのフィルタリングのルールは複数のレベルで設定可能です。
transportチャネル、transportプロファイルレベル、そして、HTTPチャネルです。
次の設定は、それらの設定のサンプルです。（設定ファイルはelasticsearch.ymlになります）</p>

<pre><code>shield:

    transport.filter:
        allow:
            - '127.0.0.1'
            - '2001:0db8:1234:0000:0000:8a2e:0370:73
        deny:
            - '10.0.0.0/8'
            - '2001:0db8:1234::/48'
            - '*.google.com'

    http.filter:
        allow: [ '10.0.0.0/8' ]
        deny: [ '127.0.0.1' ]

transport.profiles:
    client:
        shield.filter.deny: [ '_all' ]
</code></pre>

<p>このように、IPv4とIPv6、CIDR、ホスト名、ワイルドカードが利用できます。
また、この機能はホストOSのIPテーブルに設定することで追加できるが、Shieldにそれを保持し、それらの設定を単純化し、
デプロイの全体から除去できることにも注意してください（詳細は<a href="http://www.elasticsearch.org/guide/en/shield/current/ip-filtering.html">ドキュメントのIPフィルタリングをご覧ください</a>）。</p>

<h3>監査証跡（Audit Trail）</h3>

<p>セキュアなシステムの必須機能の一つで、監査硝石により、Elasticsearchに発生した重要なイベントをトラッキングすることが可能です。
これらのイベントを保存することは、Elasticsearchクラスタの重要なアクティビティの証拠を提供でき、
不審な/悪意のある可能性のあるイベントを追跡するときの診断ツールにもなります。</p>

<p>Shield 1.0.0で、監査証跡は監査/アクセスlogを一般的なElasticsearchのログとは個別に保存します。
それらは、構造化されているため、読んだりパースするのが容易で、イベントのタイプも分類されています。
また、情報のレベルを設定することができ、各イベントをlogレベルの設定で書き出すことができます。
以下が、イベントのリストです。</p>

<ul>
<li><em>anonymous_access_denied</em> - 認証トークンがないユーザからのリクエストがあった時のログ</li>
<li><em>authentication_failed</em> - リクエストされたユーザの認証に失敗した時のログ</li>
<li><em>access_denied</em> - 認証されたユーザが許可されていない操作を実行した時のログ</li>
<li><em>access_granted</em> - 認証されたユーザが許可された操作を実行した時のログ</li>
<li><em>tampered_request</em> - 不正に書き換えられたリクエストが到着したのを検知した時のログ</li>
<li><em>connection_granted</em> - ノードもしくはtransportクライアントがIPフィルタのルールにパスした時のログ</li>
<li><em>connection_denied</em> - ノードもしくはtransportクライアントがIPフィルタリングルールの制限により却下された時のログ</li>
</ul>


<p>Shieldの監査証跡についてより詳しく知りたい方は、<a href="http://www.elasticsearch.org/guide/en/shield/current/auditing.html">ドキュメント</a>をごらんください。</p>

<h3>次のバージョンでは？</h3>

<p>ここまで紹介したように、これはまだ始まりにすぎません。
Shieldに追加される多くの機能があり、しっかりとした基盤を構築したところです。
Shieldの次のバージョンでは、以下の機能の追加にフォーカスするでしょう。（これらだけに限ったわけではありません。）</p>

<ul>
<li>APIによる設定、管理</li>
<li>より拡張され、柔軟なLDAP/Active Directoryサポート</li>
<li>レルムタイプの追加（kerberos、anonymous、certificatesなどなど）</li>
<li>セッションベースの認証</li>
</ul>


<p>ShieldはElasticsearch社の2番目の（<a href="http://www.elasticsearch.com/products/marvel?_ga=1.40546982.567962035.1389706748">Marvel</a>に続く）商用プロダクトです。
ダウンロードして開発環境で評価してください。
インストールは他のプラグインと同様の方法です（インストール方法についての詳細は<a href="http://www.elasticsearch.org/guide/en/shield/current/index.html">こちら</a>）。
一度インストールすると、30日の試用ライセンスが始まります。
もし、さらに時間が必要な場合は、sales@elasticsearch.comまで連絡してください。</p>

<p>私たちのすべてのプロダクトについてフィードバックをお待ちしています。
Shieldの商用利用、機能、ロードマップ、その他のセキュリティに関するトピックなど、質問がありましたら、
<a href="http://www.elasticsearch.com/contact/?_ga=1.32250170.567962035.1389706748">サイトからご連絡ください</a>。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Elasticsearch Coreトレーニング開催]]></title>
    <link href="http://blog.johtani.info/blog/2015/02/27/2nd-tokyo-training/"/>
    <updated>2015-02-27T17:10:29+09:00</updated>
    <id>http://blog.johtani.info/blog/2015/02/27/2nd-tokyo-training</id>
    <content type="html"><![CDATA[<p><a href="https://purchases.elasticsearch.com/class/Tokyo/2015-04-13">4月13日から3日間、ElasticsearchのCoreトレーニング</a>が東京で開催されます。
Early Birdということで、3/14までに申し込みすると割引があります。
興味のある方は、見ていただければと。</p>

<!-- more -->


<p>また、4/15にElasticsearch勉強会を開催します。
トレーニングに弊社のエンジニアが来日しますので、なにか話をしてもらう予定です。</p>

<p>募集は後日、<a href="https://elasticsearch.doorkeeper.jp">Elasticsearch勉強会</a>のDoorkeeperで行います。
興味のある方は、登録しておいていただければと。</p>

<p>トレーニングや勉強会でお待ちしております。</p>
]]></content>
  </entry>
  
</feed>
