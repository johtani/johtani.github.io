<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: elasticsearch | @johtaniの日記 2nd]]></title>
  <link href="http://blog.johtani.info/blog/categories/elasticsearch/atom.xml" rel="self"/>
  <link href="http://blog.johtani.info/"/>
  <updated>2015-07-22T17:25:20+09:00</updated>
  <id>http://blog.johtani.info/</id>
  <author>
    <name><![CDATA[johtani]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Elasticsearch 1.7.0 および 1.6.1リリース（日本語訳）]]></title>
    <link href="http://blog.johtani.info/blog/2015/07/22/elasticsearch-1-7-0-and-1-6-1-released-ja/"/>
    <updated>2015-07-22T15:33:37+09:00</updated>
    <id>http://blog.johtani.info/blog/2015/07/22/elasticsearch-1-7-0-and-1-6-1-released-ja</id>
    <content type="html"><![CDATA[<p><strong>※この記事は次のブログを翻訳したものになります。</strong></p>

<p>原文：<a href="https://www.elastic.co/blog/elasticsearch-1-7-0-and-1-6-1-released">Elasticsearch 1.7.0 and 1.6.1 released</a></p>

<p>本日（7/16）、<strong>Lucene 4.10.4</strong>ベースの<strong>Elasticsearch 1.7.0</strong>および<strong>Elasticsearch 1.6.1</strong> のバグフィックス版をリリースしました。
これらのリリースはセキュリティフィックスを含んでおり、<strong>すべてのユーザにアップグレードを推奨します。</strong></p>

<p>ダウンロードおよびすべての変更については次のリンクをごらんください。</p>

<ul>
<li>最新安定版：<a href="https://www.elastic.co/downloads/past-releases/elasticsearch-1-7-0">Elasticsearch 1.7.0</a></li>
<li>1.6系バグフィックス：<a href="https://www.elastic.co/downloads/past-releases/elasticsearch-1-6-1">Elasticsearch 1.6.1</a></li>
</ul>


<!-- more -->


<p>1.7.0が1.x系の最後のリリースとなります。
今後の新機能については、Elasticsearch 2.0以降で取り込まれる予定です。</p>

<p>Elasticsearch 1.7.0は小さなリリースですが、2つの重要なセキュリティフィックスと
クラスタの安定化とリカバリに関する2つの重要な機能を含んでいます。</p>

<ul>
<li><a href="#security">セキュリティフィックス</a></li>
<li><a href="#delayed">シャードアロケーションを遅らせる</a></li>
<li><a href="#prioritization">インデックスリカバリの優先度</a></li>
</ul>


<h2><a name="security">セキュリティフィックス</a></h2>

<p>Elasticsearch 1.6.1 と 1.7.0 は次の2つのセキュリティフィックスを含んでいます。</p>

<h3>リモートコード実行の脆弱性</h3>

<p>Elasticsearch 1.6.1より前のバージョンには、transport protocol（ノードとJavaクライアント間での通信に利用）により、
リモートでコードが実行される脆弱性があります。
これは、<a href="http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2015-3253">CVE-2015-3253</a>でのGroovyに関係しています。</p>

<p>Groovyのダイナミックスクリプティングがオフでも脆弱性があります。
アップグレードをしないユーザは、transport protocol のポート（デフォルトで9300）信頼したエージェントからのみの
アクセスに限定することで、脆弱性から保護できます。</p>

<p>この問題を<a href="https://www.elastic.co/community/security">CVE-2015-5377</a>としました。</p>

<h3>ディレクトリ探索の脆弱性</h3>

<p>Elasticsearch 1.0.0から1.6.0までのバージョンで、ElasticsearchのJVMプロセスによって読み込みが可能なファイルを
取得することができるディレクトリ探索攻撃の脆弱性があります。
アップグレードをしないユーザは、信頼できない場所からの<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/modules-snapshots.html">Snapshot-Restore API</a>の呼び出しを防ぐためにファイアウォール、リバースプロキシやShieldを使用することができます。</p>

<p>この問題を<a href="https://www.elastic.co/community/security">CVE-2015-5531</a>としました。</p>

<h2><a name="delayed">シャードアロケーションを遅らせる</a></h2>

<p>Elasticsearch 1.6.0で<a href="https://www.elastic.co/blog/elasticsearch-1-6-0-released#synced-flush">Synced Flushing</a>が導入されました。
これは、ノードのリスタート時に、更新が止まっているシャードのリカバリを劇的にスピードアップします。
しかし、この変更は、シャードの配置を無効にしている環境でのみうまく実行されます。
ノードが一時的にクラスタから外れている場合や予期せぬリブートの場合には役に立ちません。</p>

<p>このシナリオとは次のようなものです。</p>

<ul>
<li>ノードの想定外のシャットダウン</li>
<li>マスタがたのノードにシャードを再配置</li>
<li>各シャードが新しい場所にネットワーク越しにコピー</li>
<li>その間に、外れていたノードが再度クラスタにジョイン</li>
<li>マスタは新しいノードにシャードを再配置。新しいノードに存在する既存のシャードが全く再利用されない可能性がある</li>
</ul>


<p>ノードレベルとクラスタレベルの両方の並列的なリカバリを抑制しても、
この&#8221;シャードシャッフル&#8221;がクラスタに対して負荷をかける可能性があります。
これは、外れたノードが再度ジョインするのを単に待つことにより防げるかもしれません。</p>

<h3>待ちましょう！</h3>

<p>Elasticsearch 1.7.0は<a href="https://www.elastic.co/guide/en/elasticsearch/reference/1.7/delayed-allocation.html"><code>index.unassigned.node_left.delayed_timeout</code></a>設定を追加しました。デフォルトでは1分です。
これは、ノードがクラスタから外れたとき、ほかのノードにこれらのノードを再配置するまでマスタが1分待つということです。
ノードがこの1分の間に復帰した場合、マスタはローカルにあるシャードを再度配置します。</p>

<h3>なぜ1分？</h3>

<p>ノードがシャットダウンし、リスタートし、復帰するために十分な時間が1分だからです。
しかし、ノードが復帰しない場合にはまだ再配置が発生することを意味します。
デフォルト値を決定するのは難しいです。
この設定をどのくらいに減らすか、増やすかを決める必要があるかもしれません。</p>

<p>このデフォルト値は、<code>config/elasticsearch.yml</code>ファイルに設定できますが、<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/indices-update-settings.html">インデックス設定の更新API</a>を使って設定することも可能です。</p>

<p>このデフォルトに関する知見をぜひフィードバックしてください。</p>

<h2><a name="prioritization">インデックスリカバリの優先度</a></h2>

<p>1.7.0の2つ目の重要な機構はフルクラスタリスタートのような後に、
どの順番でインデックスをリカバリするかという優先度をつけることができるという機能です。</p>

<p>電源故障による、ロギング用のクラスタのダウンを想像してください。
クラスタが普及した場合、500個のインデックスをリカバリするような場合、499個のインデックスのデータは古く、
500番目のインデックスが重要です。
もっとも最近作成されたインデックスがリカバリされるまで、インデキシングを待つというようなことはできません。</p>

<p>これまでは、インデックスはランダムな順序でリカバリされ、重要なインデックスがリカバリされるまで待つしかありませんでした。
1.7.0では、インデックスは優先度の順番でリカバリされます。
この優先度は次のプロパティで指定できます。</p>

<ul>
<li><code>index.priority</code>設定（大きな値が優先度が高い）</li>
<li>インデックス作成日（新しいものが優先度が高い）</li>
<li>インデックス名</li>
</ul>


<p>既存のクラスタについて特に変更せずとも、最も最近作成されたインデックスが古いものよりも復旧されます。
古いインデックスの優先度を上げるためには、<code>index.priority</code>設定に0よりも大きな値を設定します。</p>

<pre><code>PUT important_index/_settings
{
  "index.priority": 5
}
</code></pre>

<p>この設定は、存在するインデックスに対して更新できます。リカバリ中にもです。</p>

<h2>まとめ</h2>

<p>ぜひ、<a href="https://www.elastic.co/downloads/past-releases/elasticsearch-1-7-0">Elasticsearch 1.7.0</a>をダウンロードして、試してみてください。
そして、感想をTwitter(<a href="https://twitter.com/elastic">@elastic</a>)などで教えて下さい。
また、問題がありましたら、<a href="https://github.com/elastic/elasticsearch/issues">GitHub issues page</a>で報告をお願いします。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[大阪と京都でElasticsearch勉強会を開催しました。 #elasticsearchjp]]></title>
    <link href="http://blog.johtani.info/blog/2015/07/16/kansai-1st-elasticsearch-jp/"/>
    <updated>2015-07-16T10:40:57+09:00</updated>
    <id>http://blog.johtani.info/blog/2015/07/16/kansai-1st-elasticsearch-jp</id>
    <content type="html"><![CDATA[<p>東京以外での勉強会の第2弾として、関西で勉強会を開催してきました。</p>

<ul>
<li><a href="https://elasticsearch.doorkeeper.jp/events/27555">Elasticsearch勉強会 in 大阪</a></li>
<li><a href="https://elasticsearch.doorkeeper.jp/events/27553">Elasticsearch勉強会 in 京都</a></li>
</ul>


<p>会場提供をしていただいた、Yahoo!大阪、はてなのみなさん、ご協力ありがとうございました！</p>

<p><img src="/images/entries/20150715/osaka.jpg"></p>

<!-- more -->


<p><img src="/images/entries/20150715/kamogawa.jpg"></p>

<p>ここからはいつものメモです。
ちなみに、大阪の勉強会に、<a href="https://twitter.com/takuya_a">@takuya_a</a>さんと<a href="https://twitter.com/5kozawa">@5kozawa</a>さんの両名にお越しいただき話をしていただきました。
なので、勉強会の内容はほぼ同一になります。</p>

<h2>Introduction Elastic @johtani</h2>

<p>スライド：<a href="https://speakerdeck.com/johtani/introduction-elastic-1">Introduction Elasticsearch</a></p>

<p>初めての関西での勉強会ということで、ElasticsearchのOSSおよび商用プラグインの紹介をしてきました。
もちろん、Kibanaのデモもちょっとだけ。スプラトゥーンに関するデータをKibanaでちょっとだけ。
突貫でデータをかき集めたのでもう少し改良しないとですが。</p>

<h2>Elasticsearch での類似文書検索と More Like This API 詳解 / 株式会社はてな　id:takuya-a</h2>

<p>スライド：<a href="https://speakerdeck.com/takuyaa/elasticsearch-defalselei-si-wen-shu-jian-suo-to-more-like-this-query-api-xiang-jie">Elasticsearch での類似文書検索と More Like This Query API 詳解</a></p>

<p>Elasticsearchの<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-mlt-query.html">More Like This</a>のソースコードリーディングみたいな感じで、
内部でどうやって処理されているかの説明を詳しくしてもらいました。</p>

<p>前のはてなエンジニアセミナーで話をされていた検索精度の件に絡んだ内容になっているかと。
（大阪で発表してもらった時より京都での発表が分かりやすくなってました。1日で改善されたのすごい！）
MoreLikeThisだとチューニングつらいので、自分で作るために<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-termvectors.html">TermVectorAPI</a>でやってみたという流れかと。</p>

<p>以下は発表後に出てきた質問のいくつかです。</p>

<p>Q:MoreLikeThisに対してTermVectorで柔軟にできる？
A:TermVectorのAPIで統計情報が取れるので、それを使うことでさらなるデータの更新ができる。</p>

<p>Q:TFとかの統計情報が必要なら、すべてインデックスをしたあとじゃないとちゃんとした値はとれないのでは？
A:TermVectorで取得したものをどうやって使うか</p>

<p>Q:TermVectorAPi&hellip;聞こえなかった
A:。。。</p>

<h2>Elasticsearchを用いたはてなブックマークのトピック生成 / 株式会社はてな　id:skozawa</h2>

<p>スライド：<a href="http://www.slideshare.net/shunsukekozawa5/elasticsearch-in">Elasticsearchを用いたはてなブックマークのトピック生成</a></p>

<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-bucket-significantterms-aggregation.html">Significant Terms Aggregation</a>を活用してる話。
トピックページの生成のために、Significant Terms Aggregationをどうやって利用しているかなどのお話でした。</p>

<p>トピックの集合の重複だったり、精度の判定方法とかいろいろ詳しく説明していただきました。</p>

<p>Q:2011年と12年で11年の方が多いのは？
A:ブックマークの件数に比例</p>

<p>Q:Significant terms aggsのsizeはいくつをつかってますか？
A:20を指定してます。</p>

<p>Q:Yahooとかニュースをストップワードとしてますが、Yahoo自体のニュースに関してはどーしてるんですか？
A:本文とタイトルから別々に作っていて、タイトルからは弾かれますが、本文から作った時に出てきます。</p>

<h2>はてなブックマークにおける Elasticsearch の運用まわりの話 / 株式会社はてな　id:hagihala</h2>

<p>スライド：未定（おそらく公開される）</p>

<p>体調が回復しきっていない中の発表ありがとうございました。
大幅に修正された資料が出てくるかなと。（ツイートできない数値がちらほらあったので）</p>

<p>Elasticsearchのクラスタの構成、どういった点で困ってたのでどういう調べ方をしたのか、どういった対処をしたのか。
どのあたりが次の課題かなどの話もありました。</p>

<h2>感想・反省点など</h2>

<p>大阪、京都ともに30名弱の方の参加をしていただきました。ありがとうございました。
反省点としては、ハッシュタグを告知し忘れてました。。。</p>

<p>勉強会はやはり、東京が異常に活発で、大阪や京都はまだそれほどでもないのかなぁとも。
大阪はエンジニアの人や会社も多い気がするんですが。私の告知の仕方もあるかもなぁと。
次回があれば、大阪での事例も聞きたいので、スピーカーをもっと探さないとなと。</p>

<h2>関連ブログなど</h2>

<p>見つけたら、リンク追加していきます。</p>

<ul>
<li><a href="http://skozawa.hatenablog.com/entry/2015/07/17/194709">Elasticsearch勉強会 in 大阪/京都で発表しました</a></li>
<li><a href="http://stop-the-world.hatenablog.com/entry/2015/07/22/014047">「Elasticsearch での類似文書検索と More Like This Query API 詳解」というタイトルで発表しました</a></li>
</ul>


<h2>その他（余談）</h2>

<p>大阪のYahoo!さんは立地条件（梅田のすぐそば）がよく、</p>

<p><img src="/images/entries/20150715/yahoo_osaka.jpg" width="300"></p>

<p>夜景も綺麗でした。大阪城とかも見えてました。（夜景じゃないけど。。。）</p>

<p><img src="/images/entries/20150715/view_from_yahoo.jpg" width="600"></p>

<p>京都は祇園祭の真っ最中。</p>

<p><img src="/images/entries/20150715/naginata2.jpg" width="300"></p>

<p>水曜日はお休みをいただいて、観光してました。ちょっと日焼けが。。。
おかげで、リフレッシュできました。三十三間堂とか良かった:)</p>

<p>あまり、関西に縁がない（大阪15年ぶり、京都10年ぶり）ので、
もっとユーザが増えて勉強会の機運が高まると嬉しいなと。:)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mappingのすばらしいリファクタリング（日本語訳）]]></title>
    <link href="http://blog.johtani.info/blog/2015/07/08/great-mapping-refactoring-ja/"/>
    <updated>2015-07-08T18:11:31+09:00</updated>
    <id>http://blog.johtani.info/blog/2015/07/08/great-mapping-refactoring-ja</id>
    <content type="html"><![CDATA[<p><strong>※この記事は次のブログを翻訳したものになります。</strong></p>

<p>原文：<a href="https://www.elastic.co/blog/great-mapping-refactoring">The Great Mapping Refactoring</a></p>

<!-- more -->


<p>Elasticsearchのユーザの悩みの最も大きなものの一つは、
タイプとフィールドのマッピングに関する多義性です。
この多義性は、インデックス時の例外やクエリ時の例外、
正しくない結果、リクエストからリクエストへ変化する結果、
また、インデックスの故障やデータのロスを結果として引き起こします。</p>

<p>Elasticsearchをより強固で予測可能な振る舞いをするようにする作業において、
フィールドやタイプのマッピングをより厳格でより信頼性を高くするかといったことに
多くの変更を費やしました。
多くのケースで、Elasticsearch v2.0で新しいインデックスを作るときにのみ、
新しいルールを強制し、これまでのインデックスに関しては後方互換性を保つようにします。</p>

<p>しかし、幾つかのケースでは、先ほど説明したようなフィールドマッピングの
コンフリクトなどが存在するため、それらを利用できないです。</p>

<blockquote><p>コンフリクトしたフィールドのマッピングをもつインデックスはElasticsearch v2.0にはアップグレードできません。</p></blockquote>

<p>もし、これらのインデックスのデータが必要ない場合は、インデックスを消せばいいです。
そうでない場合はマッピングを正しくして再度インデックスする必要があるでしょう。</p>

<p>マッピングを正しく変更することは、私たちが簡単に決めることではありません。
ここからは、現在ある問題点と、私たちがどのように実装して解決したかについて説明します。</p>

<ul>
<li><a href="#conflicting-field-mappings">フィールドマッピングのコンフリクト</a></li>
<li><a href="#ambiguous-field-lookup">あいまいなフィールドのルックアップ</a></li>
<li><a href="#type-meta-fields">タイプのメタフィールド</a></li>
<li><a href="#analyzer-settings">アナライザ設定</a></li>
<li><a href="#index_name-and-path"><code>index_name</code>と<code>path</code></a></li>
<li><a href="#mapping-update">同期的なマッピングの更新</a></li>
<li><a href="#delete-mapping">マッピングの削除</a></li>
<li><a href="#prepare-2_0">2.0のための準備</a></li>
</ul>


<h2><a name="conflicting-field-mappings">フィールドマッピングのコンフリクト</a></h2>

<p>これまで、わたしたちはドキュメントのタイプは「データベースのテーブルのようなもの」と説明していました。
タイプの目的を説明する簡単な方法だったからです。
しかし、残念なことにこれは、真実ではありません。
「同じ」インデックスの「異なるタイプ」にある同じ名前のフィールドは、
内部的に、Luceneのフィールド名が同じものになります。</p>

<p>もし<code>error</code>フィールドとして、ドキュメントタイプが<code>apache</code>のものには数値（integer）を、
ドキュメントタイプが<code>nginx</code>のものには文字列（string）を割り当てた場合、
Elasticsearchは同じLuceneのフィールドに数値と文字列のデータをもつことになります。
このフィールドに対して、検索やaggregationを行う場合、おかしな結果を受け取るか、例外が帰ってくるか、
インデックスが破損することになります。</p>

<p>この問題を解決するために、まず、ドキュメントタイプの名前をフィールドの名前の前に追加することを考えました。
各フィールドは完全に別のものとなります。
このアプローチの利点はドキュメントタイプが実際のテーブルのようになることです。</p>

<p>しかし、この方法には多くの欠点があります。</p>

<ul>
<li>フィールドは常に、他のタイプとは異なるものであると区別するためもしくは、複数のタイプに同じフィールドのクエリのためにワイルドカードをつけた場合、
ドキュメントタイプを前につける必要があります。</li>
<li>複数のドキュメントタイプに対して同じフィールド名で検索する場合、クエリを個別に発行しなければならなく遅くなります。</li>
<li>多くの検索で、既存の多くのクエリを壊してしまうために、単純な<code>match</code>や<code>term</code>クエリの代わりに、multi-fieldクエリを使う必要があります。</li>
<li>圧縮の効率の悪さから、ヒープ利用量、ディスク使用量、I/Oなどが、増加します。</li>
<li>複数のドキュメントタイプに対するaggregationは、global ordinalの利点を利用できなくなるために、遅くなり、メモリの使用量も増えます。</li>
</ul>


<h3>解決方法</h3>

<p>最終的に、同じインデックスの同じ名前を持つ全てのフィールドは、同じマッピングを持つ必要があるというルールを採用することに決めました。
ただ、<code>copy_to</code>や<code>enabled</code>のようなパラメータはタイプごとに指定することができるようになっています。
これにより、データの破損、クエリ時の例外そして、おかしな結果が発生する問題を防ぎます。
クエリとaggregationは現在でも高速なままで、圧縮率を最大化し、ヒープ使用量やディスク使用率の低減させます。</p>

<p>この解決方法の欠点は、個別のテーブルとしてタイプを扱いたいユーザが彼らの考え方を変える必要があるということです。
これは、思ったよりも問題ではありません。
実際には、多くのフィールド名はデータの明確なタイプを表現しています。
<code>created_date</code>は常に、日付ですし、<code>number_of_hits</code>フィールドはいつも数値です。
フィールドマッピングがコンフリクトしているユーザはデータを失ったり、おかしなデータを受け取ったり、データを欠損させています。
ベストプラクティスにユーザが従っているかどうかによらず、インデックス時に正しい振る舞いを強制することが現在の違いです。</p>

<p>ユーザの多くがコンフリクトしていないフィールドマッピングをもっていれば、
コンフリクトが起きた場合、技術がこれらのシチュエーションを扱うことが可能になると思いませんか？
そこにはいくつかの解決方法があります。</p>

<h4>タイプの代わりにインデックスを別々に</h4>

<p>最も簡単な解決方法です。インデックスを別々のインデックスとし、実際のデータベーステーブルのようにします。
インデックスをまたいだ検索はタイプをまたいだ検索のように動作しますし、
ソートやaggregationも同じデータタイプへのクエリのように動作します。これまでと同じ制限です。</p>

<h4>コンフリクトしたフィールドの名前の変更</h4>

<p>コンフリクトがごくわずかな場合、（Logstashやアプリケーションで使っているものも一緒に）よりわかりやすいフィールド名に変更することで解決できます。
例えば、2つの<code>error</code>フィールドがあった場合に、<code>error_code</code>と<code>error_message</code>に変更します。</p>

<h4><code>copy_to</code>もしくはmulti-fieldsを利用</h4>

<p>異なるドキュメントタイプのフィールドは別々の<code>copy_to</code>を設定できます。
元の<code>error</code>フィールドは<code>index</code>の設定に<code>no</code>が設定してあり、全てのドキュメントタイプで無効化されていますが、
特定のタイプだけ、<code>error</code>フィールドの値を数値の<code>error_code</code>フィールドにコピーすることができます。</p>

<pre><code>PUT my_index/_mapping/mapping_one
{
  "properties": {
    "error": {
      "type": "string",
      "index": "no",
      "copy_to": "error_code"
    },
    "error_code": {
      "type": "integer"
    }
  }
}
</code></pre>

<p>他のタイプでは文字列の<code>error_message</code>にコピーします。</p>

<pre><code>PUT my_index/_mapping/mapping_two
{
  "properties": {
    "error": {
      "type": "string",
      "index": "no",
      "copy_to": "error_message"
    },
    "error_message": {
      "type": "string"
    }
  }
}
</code></pre>

<p>同様の解決方法として<a href="https://www.elastic.co/guide/en/elasticsearch/reference/master/mapping-core-types.html#multi-fields">multi-field</a>も使えます。</p>

<h4>各データタイプに対してネストしたフィールドに</h4>

<p>ときどき、Elasticsearchに送ったドキュメントやドキュメントがもっているフィールドを制御できない場合があります。
部分的なコンフリクトに加え、闇雲に、ユーザが送ってきたフィールドを受け入れると、マッピングが肥大化します。
タイムスタンプやIPアドレスをフィールド名に使うようなドキュメントがあると考えてください。</p>

<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping-nested-type.html"><code>nested</code> フィールド</a>にすることで、<code>str_val</code>、<code>int_val</code>、<code>date_val</code>というような各データタイプを利用できます。</p>

<p>このアプローチによって、次のドキュメントは</p>

<pre><code>{
  "message": "some string",
  "count":   1,
  "date":    "2015-06-01"
}
</code></pre>

<p>アプリケーションによって、次のようにフォーマットしなおす必要があります。</p>

<pre><code>{
  "data": [
    {"key": "message", "str_val":  "some_string" },
    {"key": "count",   "int_val":  1             },
    {"key": "date",    "date_val": "2015-06-01"  }
  ]
}
</code></pre>

<p>この解決方法は、アプリケーションサイドでより多くの作業が必要ですが、コンフリクトの問題とマッピングの肥大化の問題を同時に解決します。</p>

<h2><a name="#ambiguous-field-lookup">あいまいなフィールドのルックアップ</a></h2>

<p>現在、フィールドの指定には&#8221;short name&#8221;、フルパス、ドキュメントタイプを前につけたフルパスが利用できます。
これらのオプションがあいまいさをもたらしています。
サンプルとして次のマッピングをご覧ください。</p>

<pre><code>{
  "mappings": {
    "user": {
      "properties": {
        "title": {
          "type": "string"
        }
      }
    },
    "blog": {
      "properties": {
        "title": {
          "type": "string"
        },
        "user": {
          "type": "object",
          "fields": {
            "title": {
              "type": "string"
            }
          }
        }
      }
    }
  }
}
</code></pre>

<ul>
<li><code>title</code>は<code>user.title</code>、<code>blog.title</code>、<code>blog.user.title</code>のどれでしょう？</li>
<li><code>user.title</code>は<code>user.title</code>または<code>blog.user.title</code>のどちらでしょう？</li>
</ul>


<p>答えは「場合によります。」です。Elasticsearchが最初に見つけたものになります。
フィールドはリクエストごとに変わるため、各ノードでマッピングがどのようにシリアライズされたかに依存します。</p>

<p>2.0では、フィールドを指定する時に、ドキュメントタイプを除いたフルパス名を使用するべきでしょう。</p>

<ul>
<li><code>user.title</code>は、<code>blog</code>タイプの<code>user.title</code>を意味します。</li>
<li><code>title</code>は、<code>user</code>と<code>blog</code>タイプの<code>title</code>フィールドを意味します。</li>
<li><code>*title</code>は<code>user.title</code>と<code>title</code>フィールドの両方にマッチします。</li>
</ul>


<p><code>user</code>タイプの<code>title</code>フィールドと<code>blog</code>タイプの<code>title</code>の違いはどのように指定するのでしょう？</p>

<p>指定できません。<a href="#conflicting-field-mappings">フィールドマッピングのコンフリクト</a>で説明した変更により、
<code>title</code>フィールドは両方のタイプで同じフィールドになります。
本質的に<code>title</code>と呼ばれる1つのフィールドになります。</p>

<p><code>user.</code>や<code>blog.</code>のようなタイプのプレフィックスはタイプを指定することによるフィルタリングで効果があります。
クエリの<code>blog.title</code>フィールドは<code>blog</code>タイプのドキュメントだけを検索し、<code>user</code>タイプのドキュメントを検索しません。
このシンタックスは誤解を招きやすいです。なぜなら、いつでも動作するわけではないからです。
aggregationやsuggestionはすべてのタイプに関する結果を含みます。
この利用のため、上記の例のあいまいさがあるので、タイプのプレフィックスはサポートしません。</p>

<p><strong>重要</strong> short nameやタイププレフィックスを利用したpercolatorは更新する必要があります。</p>

<h2><a name="type-meta-fields">タイプのメタフィールド</a></h2>

<p>すべてのタイプはメタフィールドを持っています。<code>_id</code>、<code>_index</code>、<code>_routing</code>、<code>_parent</code>、<code>_timestamp</code>などです。
これらのほとんどは<code>index</code>、<code>store</code>、<code>path</code>のような幾つかの設定をサポートしています。
これらの設定について次のようにシンプルにしました。</p>

<ul>
<li><code>_id</code>と<code>_type</code>は変更不可</li>
<li><code>_index</code>は、ドキュメントのもつインデックスを保存するために<code>enabled</code></li>
<li><code>_routing</code>は<code>required</code>のみを指定</li>
<li><code>_size</code>は<code>enabled</code>のみ</li>
<li><code>_timestamp</code>はデフォルトで保存される</li>
<li><code>_boost</code>と<code>_analyzer</code>は廃止。古いインデックスのものは無視される</li>
</ul>


<p>ドキュメントのフィールドから<code>_id</code>と<code>_routing</code>と<code>_timestamp</code>の値を抽出することができました。
この機能は廃止されます。これは、ドキュメントのパースとコンフリクトを起こすためです。
代わりに、これらの値はURLもしくはquery stringで指定可能です。</p>

<p><code>_boost</code>と<code>_analyzer</code>フィールドは例外で、すでにあるメタフィールドの設定は古いインデックスのものが採用されます。</p>

<h2><a name="analyzer-settings">アナライザ設定</a></h2>

<p>これまで、indexとsearchのアナライザがインデックス、タイプ、フィールド、ドキュメント（<code>_analyzer</code>フィールドで）の
それぞれのレベルで指定可能でした。
同じフィールドに対して異なるanalysis chainの組み合わせができることにより、おかしな関連度を引き起こしていました。
フィールドマッピングのコンフリクトを解消することに加え、アナライザの設定も簡略化します。</p>

<ul>
<li>Analyzedな文字列フィールドは、<code>analyzer</code>設定と<code>search_analyzer</code>設定（<code>analyzer</code>設定の値をデフォルトとする）を指定できます。<code>index_analyzer</code>設定は<code>analyzer</code>となります。</li>
<li>複数のタイプで同じ名前のフィールドがある場合、フィールドはすべて、同じアナライザの設定を持たなければなりません。</li>
<li>タイプレベルのデフォルト設定の<code>analyzer</code>、<code>index_analyzer</code>、<code>search_analyzer</code>設定は廃止されます。</li>
<li>デフォルトアナライザはインデックスごとにインデックスの<code>analysis</code>設定で設定します。これらは<code>default</code>もしくは<code>default_search</code>という名前で設定します。</li>
<li>ドキュメントごとの<code>_analyzer</code>フィールドはサポートしません。既存のインデックスのものは無視されます。</li>
</ul>


<h2><a name="index_name-and-path"><code>index_name</code>と<code>path</code></a></h2>

<p><code>index_name</code>と<code>path</code>設定は（Elasticsearch v1.0.0から利用できる）<code>copy_to</code>によって置き換わりました。
既存のインデックスについてはこれらは機能しますが、新しいインデックスでは指定できません。</p>

<h2><a name="mapping-update">同期的なマッピングの更新</a></h2>

<p>現在、これまで存在していないフィールドを含むドキュメントをインデキシングするとき、
フィールドはローカルのマッピングに追加され、それから、マスターに変更（新しいマッピングをすべてのシャードに適用する更新）が送信されていました。
同時に2つのシャードに同じフィールドを追加することができます。
また、そのとき、異なる2つのマッピングがある可能性があります。
1つは<code>double</code>でもう1つは<code>long</code>だったり、<code>string</code>と<code>date</code>だったりと。</p>

<p>このような場合、マスターに最初に届いたマッピングが採用されます。
しかし、「負けた」マッピングをもつシャードでは、すでに異なるデータのタイプを利用しているため、
これを利用し続けます。
そのご、ノードをリスタートしたときに、シャードが別のノードに移動し、マスターにあるマッピングを適用します。
このとき、インデックスが破損したりデータを失ったりします。</p>

<p>これを防ぐために、シャードはインデキシングを続ける前に、新しいマッピングがマスターによって採用されるかどうかを待つようになりました。
これはすべてのマッピングが安全に更新されます。
新しいフィールドをもっているドキュメントをインデキシングすると、前よりも処理が遅くなるでしょう。
受け入れられることを待つ必要があるためです。
しかし、クラスタの状態の更新処理のスピードが次の2つの新しい機能によって大きく改善されています。</p>

<ul>
<li><strong>クラスタ状態の差分</strong>：可能であれば、クラスタの状態の変更はクラスタ状態全体の変更ではなく、部分的なものとする。</li>
<li><strong>シャードへのリクエストの非同期化</strong>：シャードアロケーション処理中に、マスタノードは、
割り当てられていないシャードのコピーの日付が最新のものを持っているかを見つけるために、リクエストをデータノードに対して送信します。
ここで、クラスタ状態を変更する呼び出しがブロッキングで行われていました。v1.6.0から、このリクエストはバックグラウンドで非同期で実行されます。
これにより、マッピング更新のようなペンディングタスクをより早く処理できるようになります。</li>
</ul>


<h2><a name="delete-mapping">マッピングの削除</a></h2>

<p>（そのタイプのドキュメントがある場合）タイプマッピングを削除できないようにします。
マッピングを削除した後に、削除されたフィールドの情報は、Luceneレベルでは存在し続け、
もし、後から同じ名前のフィールドが追加されたときにインデックスの破損を引き起こします。
そのようなマッピングは残しておくか、新しいインデックスに再インデックスすることができます。</p>

<h2><a name="prepare-2_0">2.0のための準備</a></h2>

<p>マッピングがコンフリクトしているかどうかを決めることは、手動で行うには慎重に行う必要があります。
私たちは、<a href="https://github.com/elastic/elasticsearch-migration">Elasticsearch Migration Plugin</a>を提供します。
これは、2.0で非推奨になったり廃止された機能を利用しているかどうかを見つけるために役に立つでしょう。</p>

<p>もし、コンフリクトしたマッピングを持っている場合、
正しいマッピングを持つ新しいインデックスにデータを再インデックスするか、
必要ないなら削除します。
これらのコンフリクトを解決しない限り2.0にはアップグレードできないでしょう。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Elasticsearch 2.0.0.beta1リリース間近（日本語訳）]]></title>
    <link href="http://blog.johtani.info/blog/2015/07/07/elasticsearch-2-dot-0-0-dot-beta1-coming-soon-ja/"/>
    <updated>2015-07-07T15:25:00+09:00</updated>
    <id>http://blog.johtani.info/blog/2015/07/07/elasticsearch-2-dot-0-0-dot-beta1-coming-soon-ja</id>
    <content type="html"><![CDATA[<p><strong>※この記事は次のブログを翻訳したものになります。</strong></p>

<p>原文：<a href="https://www.elastic.co/blog/elasticsearch-2.0.0.beta1-coming-soon">Elasticsearch 2.0.0.beta1 coming soon!</a></p>

<p>Elasticsearch 2.0.0.beta1のリリースの準備をしています。
これは、Lucene 5.2.1に含まれる多くの改善が利用できるようになります。
このリリースに関するいくつかの機能は次のようなものです。</p>

<!-- more -->


<h4>Pipeline Aggregations</h4>

<p>差分や移動平均、他のAggregationsの結果に対する
series arithmeticのようなaggregationが利用可能になります。
この機能は、これまでは、クライアントサイドで実行する必要がありました。
しかし、この計算をより強力な解析クエリを構築してElasticsearchで
実行することができるようになります。
クライアントのコードをより簡潔にすることができます。
これにより、予測解析や異常検知のようなことができるようになります。</p>

<h4>Query/Filter merging</h4>

<p>Filterはなくなります。全てのフィルタは、クエリになります。
クエリコンテキストで利用されると、効率的に関連度スコアを計算し、
フィルタコンテキストで利用されると、単に、
マッチしていないドキュメントを除外する（今のフィルタのようなもの）だけです
この変更は、クエリ実行が自動的に、より効率的な順番で実行されるように
最適化されることを意味します。
例えば、フレーズやgeoクエリのような遅いクエリは
まず、近似フェーズを実行し、それから、より遅い実際のフェーズが
結果に対して行われます。
フィルタコンテキストにおいて、頻繁に利用される条件は自動的にキャッシュされます。</p>

<h4>Configurable store compression</h4>

<p><code>index.codec</code>設定により、高速化のためのLZ4圧縮（<code>default</code>）か
インデックスサイズを小さくするためのDEFLATE（<code>best_compression</code>）を
選択できます。これは、ロギングでとくに役に立ちます。
これにより、古いインデックスオプティマイズする前に<code>best_compression</code>に
変更できます。</p>

<p>これらに関するブログ記事がすぐに公開されるでしょう。</p>

<h3>Performance and resilience</h3>

<p>以降では、新しいメジャーリリースに関して簡単に紹介します。
2.0の変更の多くは内部の機能に関するものであり、
直接ユーザに関連するわけではないからです。</p>

<p>新しいメジャーバージョンのテーマは、パフォーマンス、安定性、
堅牢性、予測可能性、そして使い勝手の良さです。</p>

<ul>
<li>物事が予測した通りに動作する</li>
<li>何か問題があった場合に、Elasticsearchから役立つフィードバックがある</li>
<li>ローレベルの設定を扱う必要はなく、Elasticsearchが良い設定を決定する</li>
<li>これらに加え、データがより安全に</li>
</ul>


<p>これらの目標は完全ではありません。
まだ、多くの改善があります。しかし、2.xブランチで、
すでに500コミットを超える大きな改善が実施されています。</p>

<ul>
<li>on-diskの doc valuesをデフォルトで利用（これまではfielddata）。
ヒープ使用量を減らして、スケーラビリティを向上</li>
<li>セグメントマージ処理中のメモリ使用量の削減</li>
<li>normsの圧縮率の改善。ヒープスペースを利用している大きな処理のひとつだったため。</li>
<li>全てのリクエストの後に、transaction logをfsyncすることで、デフォルトで耐久性を向上</li>
<li>全てのファイル変更をアトミックに（部分的なファイルの書き出しはなし）</li>
<li>マージを自動で制限</li>
<li>フレーズクエリやスパンクエリを高速化</li>
<li>フィルタキャッシュをより効率化するための圧縮されたビットセット</li>
<li>クラスタ状態の差分更新</li>
<li>構造化されたJSON形式の例外</li>
<li>よりきめ細かいLuceneのメモリレポート</li>
<li>デフォルトではlocalhostにのみバインド。開発のノードが他のクラスタにジョインするのを防ぐ</li>
<li>parent/childのクエリ実行最適化のためにリライト</li>
<li>Java Security Managerで必要最小限なパーミッションで実行</li>
<li>全てのコアなプラグインをelasticsearchリポジトリに移行し、Elasticsearchのバージョンに同期してリリースされる予定</li>
</ul>


<h2>アップグレード前に</h2>

<p>メジャーバージョンのアップグレードは問題のあるものを一掃する機会を与えてくれます。
できる限り、これらの変更をアップグレードするために、簡単な方法を提供しようとしています。
しかし、Elasticsearch 2.0にアップグレードする前に、必要な処理が2つあります。</p>

<p>1つ目は、フィールドとタイプマッピングに関することです。
mapping APIは、現在、それほど厳密ではありません。
内蔵された保護機構を提供する代わりに、ユーザがベストプラクティスを知っていると信頼していました。
2.0では、mappingはより厳密で安全ですが、いくつかの変更では、後方互換性を保っていません。
詳細については<a href="https://www.elastic.co/blog/great-mapping-refactoring">The Great Mapping Recatoring</a>をごらんください。</p>

<p>2つ目はElasticsearch 0.20以前のユーザに関する変更です。
これは、Lucene 3.xを使っています。
Elasticsearch 2.xはLucene 5をベースにしています。
Lucene 5はLucene 4.xによって作成されたインデックスの読み込みはサポートしていますが、
Lucene 3.xに関してはサポートしていません。</p>

<p>Elasticsearch 0.20以前のバージョンによって生成されたインデックスを持っている場合、
Elasticsearch 2.xのクラスタをスタートすることはできません。
これらの古いインデックスを削除するか、Elaticsearch 1.6.0以上に含まれている
<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/indices-upgrade.html">upgrade API</a>を使用してアップグレードする必要があります。</p>

<p>upgrade APIの実行は2つのジョブを実行します。</p>

<ul>
<li>古いLuceneフォーマットのセグメントを最新のフォーマットで書き換えます</li>
<li>Elasticsearch 2.xによって読み込めるようという印をインデックスに追加します</li>
</ul>


<p>全てのセグメントを最新バージョンにアップグレードするのも良い案ですが、
アップグレード前に必要な処理を最小限に抑えることも可能です。
（Lucene 3.xのセグメントだけをアップグレード）
その場合は、<code>only_ancient_segments</code>パラメータを指定します。</p>

<h2>Elasticsearch Migration Plugin</h2>

<p>Elasticsearch 2.0 に移行する前に、インデックスがアップグレードが必要なのか、
ほかになにかするべきことがあるのかをチェックする助けになる
Elasticsearch Migration Pluginをリリースしました。</p>

<p>まず、プラグインをインストールします</p>

<pre><code>./bin/plugin -i elastic/elasticsearch-migration
</code></pre>

<p>プラグインのインストール後はノードのリスタートは必要ありません。</p>

<p>以下のリンクをブラウザで開きます。</p>

<p><a href="http://localhost:9200/_plugin/migration">http://localhost:9200/_plugin/migration</a></p>

<p>（<code>localhost:9200</code>はインストールしたホスト名に変更してください。）</p>

<p>Migration pluginに関してバグやご意見がある場合は、<a href="http://github.com/elastic/elasticsearch-migration/issues">GitHubのIssue</a>にお願いします。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[さらに進化したFound（日本語訳）]]></title>
    <link href="http://blog.johtani.info/blog/2015/07/07/we-just-made-found-more-awesome-ja/"/>
    <updated>2015-07-07T15:20:00+09:00</updated>
    <id>http://blog.johtani.info/blog/2015/07/07/we-just-made-found-more-awesome-ja</id>
    <content type="html"><![CDATA[<p>4ヶ月前に、<a href="https://www.elastic.co/blog/welcome-found">Found joined our team at Elastic</a>をアナウンスしました。
Foundの素晴らしいチームと一緒に仕事をしていますが、彼らによって、より素晴らしい
hosted Elasticsearchを提供することになりました。</p>

<!-- more -->


<p>私たちがともに密接に働くことにより、本日（2015/7/1）、
<a href="https://www.elastic.co/products/found">新しい2つのFound</a>を提供することになりました。
Found StandardはこれまでのFoundの機能に加え、さらに低価格を提供します。
Found Premiumは、SLAサポートと、ShieldやWatcherを将来Found上で提供します。</p>

<h2>Found Standard</h2>

<p>Foundは素晴らしいです。専用のElasticsearchクラスタ、簡単なスケール、
ビルトインのセキュリティそして、時間単位での課金などを持っています。
私たちは、hosted Elasticsearchを探している方に、
Foundが適したソリューションであると思っていますし、
すべての方に利用できて手頃な価格であるということを確信したいと思っています。</p>

<p>本日（2015/07/01）からFoundの価格をかなり低価格にし、
<strong>月額50ドル以下</strong>でhosted Elasticsearchを簡単に試してもらえるようにしました。</p>

<p>価格を下げることは正しい重要なステップですが、
Foundを利用している全ての人に、より良い経験を持っていただきたいと考えています。
低価格化と一緒に、<strong>free backups</strong>と<strong>built in SSD</strong>もFoundで提供を始めることになります。</p>

<p>Foundの重要な特徴の一つが、高可用性のために、クラスタをいくつのデータセンターに持つかを
選択できることです。
データは重要です。これが正しい選択でユーザの助けになると考えています。
これにより、私たちの価格は、<strong>複数のデータセンターにより安価に</strong>配置することができます。</p>

<p>また、KibanaもElasticsearchのデータを可視化する素晴らしい方法だと考えています。
Kibana 4が最新バージョンですが、
これは、サーバサイドコンポーネントを持っています。
これは、サービスとしてこれを提供するために、追加の料金がかかることを意味します。
Foundチームが築いた素晴らしい基盤とKibanaチームの努力により、
hosted Elasticsearchクラスタで<strong>無料のKibana 4</strong>を7月15日より提供することになりました。</p>

<h2>Found Premium</h2>

<p>また、私たちは、オープンソースプロダクトに関してサブスクリプションを提供していますが、
Found Standardに対しても提供することになりました。
これが、Found Premiumです。</p>

<p>フォーラムベースのサポートよりもSLAベースのサポートを望んでいる場合、
プロダクトを開発しているチームからのサポートを受けることができるオプションを
提供し始めました。
クリティカルなイベントを持っていたり、私たちのプロダクトに関する
問題を予測するためのベストなヘルプやガイダンス、アドバイスを探しているような場合にサポートします。</p>

<p>さらに近い将来、サブスクリプションの一部として、<a href="https://www.elastic.co/products/shield">Shield</a>（Elasticasearchのセキュリティプラグイン）や<a href="https://www.elastic.co/products/watcher">Watcher</a>（アラーティングプラグイン）が利用できるようになります。</p>

<p>私たちのチームがともに働き、多くのことを可能にし、すばらしい仕事をユーザに提供したかを
将来も楽しみです。
私は非常に誇りに思っていますし、気に入っていただけたらと思っています。
ぜひ、<a href="https://www.elastic.co/webinars/getting-started-with-found">7/15のWebnarに参加して</a>くわしい話を聞いていただき、疑問を解消してください。</p>
]]></content>
  </entry>
  
</feed>
