<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: rust | @johtaniの日記 2nd]]></title>
  <link href="http://blog.johtani.info/blog/categories/rust/atom.xml" rel="self"/>
  <link href="http://blog.johtani.info/"/>
  <updated>2018-12-01T14:10:21+09:00</updated>
  <id>http://blog.johtani.info/</id>
  <author>
    <name><![CDATA[johtani]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[第1章の05から06までやってみた（言語処理100本ノック）]]></title>
    <link href="http://blog.johtani.info/blog/2018/03/20/nlp100-ch01-05to06/"/>
    <updated>2018-03-20T21:34:45+09:00</updated>
    <id>http://blog.johtani.info/blog/2018/03/20/nlp100-ch01-05to06</id>
    <content type="html"><![CDATA[<p>Rustで言語処理100本ノックの続きで、05と06です。</p>

<!-- more -->


<h3>05. n-gram</h3>

<p>問題は<a href="http://www.cl.ecei.tohoku.ac.jp/nlp100/#sec05">こちら</a>。</p>

<p>みんな大好きn-gramです。単語と文字があるので、それぞれ別関数として実装しました。問題はbi-gramと<code>n=2</code>だったのですが、一応、<code>n</code>を引数に取る形にして実装しました。</p>

<p>まずは、単語です。</p>

<script src="http://gist-it.appspot.com/https://github.com/johtani/nlp100-rust/blob/5439f96e8521bffe34689c23aa076eb3a2fe817b/src/chapter01/answer.rs?slice=128:139"></script>


<p>前に実装した時は、自分で頑張って、先頭から数えたりしてたんですが、Rustには<a href="https://rust-lang-ja.github.io/the-rust-programming-language-ja/1.6/std/primitive.slice.html#method.windows">windows(n)</a>という便利なメソッドがsliceにあり、これを利用したらこんな簡単になりました。
sliceは特定のシーケンス（配列）に対してある特定のサイズのViewを作ってくれます（説明あってる？）。
ということで、文字列から、単語の配列（スペース区切りで単語にしている）を作り出して、<code>windows(n)</code>メソッドを通すと、
<code>n</code>で指定した数字の個数だけの単語の配列を先頭から、1単語ずつずらして作ってくれます。まさに、n-gram!
戻り値は配列の配列です。
1点だけ疑問点があるのは、「空白で区切ったものが単語」という考え方で良いかどうか？という点です。特に問題文にはそれが明示されていなかったので、このような前提を置いてあります。</p>

<p><code>invalid_n(text, n)</code>は<code>n</code>の値や入力された文字列をチェックする関数です。入力チェックですね。<code>n</code>が1よりも小さい場合、入力文字列が空文字の場合は、warningでメッセージを出して、空の配列を返す仕組みになっています。</p>

<script src="http://gist-it.appspot.com/https://github.com/johtani/nlp100-rust/blob/5439f96e8521bffe34689c23aa076eb3a2fe817b/src/chapter01/answer.rs?slice=115:126"></script>


<p>次は、文字です。</p>

<script src="http://gist-it.appspot.com/https://github.com/johtani/nlp100-rust/blob/5439f96e8521bffe34689c23aa076eb3a2fe817b/src/chapter01/answer.rs?slice=128:139"></script>


<p>単語とほぼ一緒ですが、入力文字列を、1文字ずつの配列にしているところが異なります。
また、<code>windows</code>メソッドで取り出された、1文字ずつの<code>n</code>個の配列を文字列に修正してから、結果の配列に入れています。
ここでも疑問は空白をどう扱うか？になります。
現時点では、空白も1文字とカウントして扱うことにしてあります。
どっちがいいのかなぁ？</p>

<h3>06. 集合</h3>

<p>問題は<a href="http://www.cl.ecei.tohoku.ac.jp/nlp100/#sec06">こちら</a>。</p>

<p>まずは、文字n-gramで出てきた文字列をSetに入れる関数から。</p>

<script src="http://gist-it.appspot.com/https://github.com/johtani/nlp100-rust/blob/5439f96e8521bffe34689c23aa076eb3a2fe817b/src/chapter01/answer.rs?slice=159:174"></script>


<p>n-gramの問題で実装した文字n-gramの関数の戻り値を配列ではなく、BTreeSetに変えたものになります。比較などがしやすいように？と思い、BTreeSetを利用していますが、実装としてはHashSetでも問題ないかと。
この関数の集合（Set）を元に、和集合、積集合、差集合を求める関数を実装しました。</p>

<script src="http://gist-it.appspot.com/https://github.com/johtani/nlp100-rust/blob/5439f96e8521bffe34689c23aa076eb3a2fe817b/src/chapter01/answer.rs?slice=176:187"></script>


<p>Setのメソッドとして、それぞれ、<code>union</code>＝和集合、<code>intersection</code>＝積集合、<code>difference</code>＝差集合のメソッドが用意されているので、特に困ることはなかったです。
差集合については、1-2と2-1で結果が異なるはずなので、それぞれをテストケース、main.rsで出力するようにしてあります。</p>

<h3>所感</h3>

<p>今回は、Rustがすでに実装してくれているメソッドがあったので楽ができました。
やりたいことに相当するメソッドがあるかどうかを調べるためにリファレンスを探さないといけないのがちょっと苦労しましたが。。。
ということで、今日はこの辺りまで。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[第1章の03から04までやってみた（言語処理100本ノック）]]></title>
    <link href="http://blog.johtani.info/blog/2018/02/19/nlp100-ch01-03to04/"/>
    <updated>2018-02-19T18:34:08+09:00</updated>
    <id>http://blog.johtani.info/blog/2018/02/19/nlp100-ch01-03to04</id>
    <content type="html"><![CDATA[<p>Rustで言語処理100本ノックの続きで、03と04です。</p>

<!-- more -->


<h3>03. 円周率</h3>

<p>問題は<a href="http://www.cl.ecei.tohoku.ac.jp/nlp100/#sec03">こちら</a>。</p>

<script src="http://gist-it.appspot.com/http://github.com/johtani/nlp100-rust/blob/8ca508cc16fbc7a11ac04bbc43687dfec4f25483/src/chapter01/answer/mod.rs?slice=60:71"></script>


<p>入力文字列を<code>.split_whitespace()</code>で分割しておいて、単語ごとのベクタを作り出し、そこに対して文字を数えました。「アルファベットの」という注意書きがあるので&#8221;,&ldquo;や&rdquo;.&ldquo;は含めずに数えるのかなということで、
charの<code>.is_alphabetic()</code>で<code>A-z</code>までの判定をしつつ、文字のベクタを作ってから、そのベクタの長さを詰め込むという感じでやりました。</p>

<p>これ、ひょっとして、collectでベクタにしなくても、i32とかの変数でカウントするとベクタ作らなくてもいいなじゃにか？というのに書きながら気づいた。。。
必要じゃないオブジェクトを作ってるよなぁ。</p>

<p><code>.filter().map</code>とかかな？この辺りの操作がイマイチ苦手。Javaでもまだ馴染めてないところなんだよなぁ。頭固すぎ。</p>

<h3>04. 元素記号</h3>

<p>問題は<a href="http://www.cl.ecei.tohoku.ac.jp/nlp100/#sec04">こちら</a>。</p>

<script src="http://gist-it.appspot.com/http://github.com/johtani/nlp100-rust/blob/8ca508cc16fbc7a11ac04bbc43687dfec4f25483/src/chapter01/answer/mod.rs?slice=73:112"></script>


<p>大作ですね。何だろう、大作。。。
最終的に連想配列（辞書型もしくはマップ型）」ということだったので、BTreeMapに詰め込んでます。
HashMapでもいいんですが、文字列で出力した時にキーが並んで見やすいからという理由で、BTreeMap使いました。それ以上の理由はないです。普通にやるなら、HashMapかな？</p>

<p>入力として、1文字だけの出力をする場所（インデックス番号）の配列を受け取ってます。1点だけ、チェックしていない、けど入力値の想定をしていて、<code>idx_one_symbols</code>がソートされていて、小さいものから順番に出てくるものとしてます。関数作って、チェックすべきかな？</p>

<p>で、指定された場所の最後のものが入力文字列よりも大きいかどうかというチェックもしています。（あー、テストケース書いてないな）この辺りのせいでちょっと長めになってます。</p>

<p>単語の配列を作るのは03の時と同じやり方です。
回しかたがちょっと違って、<code>.iter().enumerate()</code>で回して、添字と値をタプル？でとりだしてます。添字を見ながら1文字取り出すのか、2文字取り出すのかの判断が必要だからです。あとは一緒ですね。1文字取り出すときは、<code>.first()</code>を使って見ました。
実は、2文字取り出す時と、1文字の時と同じロジック使った方が共通化できて、短くなった？？？</p>

<p>ということで、こんな感じでした。いつものようにツッコミお待ちしてます。</p>

<h3>所感</h3>

<p>問題それぞれについてではなく、
やってて思ったのですが、問題に対して想定される結果が記載されていると嬉しいなと思いました。
ロジックについては、各自実装者に寄ったり、言語によって違いが出たりするし、議論するベースになっていいかなと思うんですが、
問題で想定されている結果（出力）があると、自分の実装にケアが足りないところがないのか？とか、ケアしなくていい点とかがわかるのかもなぁと。
ユニットテスト相当のものがあると楽かなぁと。</p>

<p>このケースどうするんだろ？みたいなのが、ところどころコメントに残ったりしてます。
出題の意図としては、その部分も議論の対象ということなのかな？</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[第1章の00から02までやってみた（言語処理100本ノック）]]></title>
    <link href="http://blog.johtani.info/blog/2018/02/15/nlp100-ch01-00to02/"/>
    <updated>2018-02-15T21:59:01+09:00</updated>
    <id>http://blog.johtani.info/blog/2018/02/15/nlp100-ch01-00to02</id>
    <content type="html"><![CDATA[<p>「鉄は熱いうちに打て」ということで、言語処理100本ノックの第1章の00から02を実装してみました。</p>

<!-- more -->


<p>さて、これが効率がいいのかどうかはさておき。</p>

<h3>00. 文字列の逆順</h3>

<p>問題は<a href="http://www.cl.ecei.tohoku.ac.jp/nlp100/#sec00">こちら</a>。</p>

<p>最初、<a href="https://github.com/johtani/nlp100-rust/blob/48567d107511541d0401af4ef58c6abb98a6083b/src/chapter01/answer.rs">Vecのreverse()で逆順にして0からlen()まで回してた</a>んですが、pop()がいい感じに後ろから取れることがわかったんで、切り替えました。
シンプルかな？</p>

<script src="http://gist-it.appspot.com/http://github.com/johtani/nlp100-rust/blob/ccbdf272adbb5aa738dc73e78e3667e4300a49c1/src/chapter01/answer.rs?slice=2:12"></script>


<h3>01. 「パタトクカシーー」</h3>

<p>問題は<a href="http://www.cl.ecei.tohoku.ac.jp/nlp100/#sec01">こちら</a>。</p>

<script src="http://gist-it.appspot.com/http://github.com/johtani/nlp100-rust/blob/ccbdf272adbb5aa738dc73e78e3667e4300a49c1/src/chapter01/answer.rs?slice=14:24"></script>


<p>1文字ずつ取り出して、インデックスの番号が2で割ってあまりが0なら文字列に追加していくってのでやってみました。
（ブログ書いてるところで、<code>i in 0..char_array.len()</code>じゃなくて、<code>(i, x) in char_array.iter().enumerate()</code>に切り替えました。）
matchとか使って綺麗に書けたりするのかなぁ？</p>

<h3>02. 「パトカー」＋「タクシー」＝「パタトクカシーー」</h3>

<p>問題は<a href="http://www.cl.ecei.tohoku.ac.jp/nlp100/#sec02">こちら</a>。</p>

<script src="http://gist-it.appspot.com/http://github.com/johtani/nlp100-rust/blob/ccbdf272adbb5aa738dc73e78e3667e4300a49c1/src/chapter01/answer.rs?slice=26:56"></script>


<p>だいぶ思考錯誤してる感じがソースに現れてます。
とりあえず、両方の文字列をcharsの配列にして個々のイテレータを回しながら、next()の戻り値があれば追加していく感じにして、
終了条件が両方Noneを通ったらにしてるけど、、、
なんか、もっと綺麗にできないのかなぁ。。。
next()のタプル返す関数作って、とかでなんかできたりするかなぁ？</p>

<h3>gist-it</h3>

<p>関係ないですが、GitHubのコードを貼り付けるのに便利なサービスがあるみたいです。</p>

<p><a href="http://gist-it.appspot.com">http://gist-it.appspot.com</a></p>

<p>これほんと便利だな。行数指定もできるし。
説明するのが簡単だ。</p>

<p>とりあえず、今日はこの辺まで。なんか、いい知恵あれば教えてください！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[言語処理100本ノックはじめました(Rust)]]></title>
    <link href="http://blog.johtani.info/blog/2018/02/14/start-nlp100-with-rust/"/>
    <updated>2018-02-14T19:52:31+09:00</updated>
    <id>http://blog.johtani.info/blog/2018/02/14/start-nlp100-with-rust</id>
    <content type="html"><![CDATA[<p>ども。新しいもの始めないと頭が退化する。。。ということで、こちら（
<a href="http://blog.katsyoshi.org/blog/2018/01/16/happy-new-year-and-new-language/">happy new year and new language - katsyoshiのめもみたいなもの</a>）のブログに触発されて、言語処理100本ノックをはじめてみました。</p>

<!-- more -->


<p><a href="http://www.cl.ecei.tohoku.ac.jp/nlp100/#ch1">言語処理100本ノック</a>とは、自然言語処理になるのかな、東北大学の研究室の先生が公開している言語処理に関する実践的な課題をベースにプログラミングなどのスキルを学んでいくための問題集です。
元々はPythonを対象とされているようですが、Rustでやってみようかと。
まぁ、先ほどあげたブログの二番煎じです。。。
ちなみに、インスパイアされた元のブログの方はRust book 2nd editionを読み終えたらしいですが、私はかじった程度です（ダメかも？）。</p>

<p>NLPもRustもかじった程度なので、苦戦しそうですが、ちょっとずつやっていこうかなと。
ということで、準備運動の第1章から始めようかと。
GitHubにちょっとずつあげていく予定です。
<a href="https://github.com/johtani/nlp100-rust">https://github.com/johtani/nlp100-rust</a></p>

<p>まぁ、まずは宣言のブログを書いてみただけです。
続いてなかったら、叱咤激励してください。叱咤だけかも？</p>
]]></content>
  </entry>
  
</feed>
