<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: plugin | @johtaniの日記 2nd]]></title>
  <link href="http://blog.johtani.info/blog/categories/plugin/atom.xml" rel="self"/>
  <link href="http://blog.johtani.info/"/>
  <updated>2019-12-01T00:10:11+09:00</updated>
  <id>http://blog.johtani.info/</id>
  <author>
    <name><![CDATA[johtani]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Analyze UIとKibanaのプラグインの作成方法（第3回）]]></title>
    <link href="http://blog.johtani.info/blog/2018/04/20/directory-layout-and-architecture/"/>
    <updated>2018-04-20T15:30:01+09:00</updated>
    <id>http://blog.johtani.info/blog/2018/04/20/directory-layout-and-architecture</id>
    <content type="html"><![CDATA[<p><a href="http://blog.johtani.info/blog/2018/02/09/getting-started-template-kibana-plugin/">第2回</a>から少し間が空いてしまいましたが、templateで作成したプラグインのディレクトリ構成とどういう流れでデータがやり取りされるかについてみていきます。
（2018/02月時点で作成したディレクトリ構成にしたがって説明します）
ちなみに、JavaScriptの優れた開発者ではないので、誤解している点や、効率の悪い書き方などがあるかもしれません。見つけた場合は、連絡をいただければと思います。</p>

<!-- more -->


<p>では、まずは作成したディレクトリ構成についてみていきましょう。</p>

<h2>ディレクトリ構成</h2>

<p><code>simple-sample-kibana-plugin</code>がプラグインのプロジェクトのトップディレクトリになります。このディレクトリに次のような構成でサブディレクトリが存在します(なお、画像はIntelliJに取り込んだ後のディレクトリになっているので、<code>.iml</code>など、不要なファイル/ディレクトリが存在しています)。</p>

<p><img src="/images/entries/20180420/directories.jpg" width="400"></p>

<p>主要なディレクトリ、ファイルについて簡単に一覧で説明します(順不同)。</p>

<table>
<thead>
<tr>
<th> ファイル/ディレクトリ名 </th>
<th> 説明 </th>
</tr>
</thead>
<tbody>
<tr>
<td> index.js </td>
<td> プラグインの本体。Kibanaはこのファイルのオブジェクトを読み込みプラグインを起動。設定などの読み込みもこちら。 </td>
</tr>
<tr>
<td> package.json </td>
<td> npm/yarnのパッケージに関する情報を定義するファイル </td>
</tr>
<tr>
<td> README.md </td>
<td> README。プラグインの説明などを記載する。インストール方法なども記載すると便利 </td>
</tr>
<tr>
<td> public </td>
<td> ブラウザ側に配布されるプログラムや画像一式 </td>
</tr>
<tr>
<td> public/less/main.less </td>
<td> LESS用のファイル。アプリ固有のスタイルなどを記載 </td>
</tr>
<tr>
<td> public/app.js </td>
<td> ブラウザ側で読み込まれるプラグインのモジュールなど。 </td>
</tr>
<tr>
<td> public/template/index.html </td>
<td> HTMLのテンプレート。ブラウザ上での描画に利用 </td>
</tr>
<tr>
<td> server/routes </td>
<td> Kibanaサーバー側で動作するプラグイン。hapi.jsを利用してREST APIを実装する </td>
</tr>
</tbody>
</table>


<p>重要なファイルについて少しだけ説明します。</p>

<h4>package.json</h4>

<p>npmやyarnでビルドなどをするときに使用するパッケージ情報を記載するためのファイルです。
プラグインの名前、バージョン、説明などを記載します。
Kibanaのバージョンについてもこちらで管理します。この情報を
また、ライブラリなどの依存関係についてもこちらで記載しています。
以下、抜粋。</p>

<pre><code class="json">{
  "name": "simple-sample-kibana-plugin",
  "version": "0.0.0",
  "description": "Sample plugin for explaining how to make kibana app",
  "main": "index.js",
  "kibana": {
    "version": "6.2.1",
    "templateVersion": "7.2.4"
  },
  "scripts": {
    "lint": "eslint **/*.js",
...
  },
  "devDependencies": {
    "@elastic/eslint-config-kibana": "^0.14.0",
    "@elastic/eslint-import-resolver-kibana": "^0.9.0",
    "@elastic/plugin-helpers": "^7.1.3",
...
    "expect.js": "^0.3.1"
  }
}
</code></pre>

<p>ちなみに私は、<code>version</code>などをリリースするたびに変更しています。</p>

<h4>index.js</h4>

<p>最初にKibanaに読み込まれるオブジェクトになります。
Kibanaのアプリの名前や、必要なモジュールなどを記載します。</p>

<p>また、<code>kibana.yml</code>から設定など読み込む処理なども書くことができます。</p>

<p>2行目の<code>exampleRoute</code>はサーバー側のAPIとして利用するhapi.js用のファイルのパスになります。</p>

<p><code>uiExports</code>はこのアプリの画面に関する設定などの記載になります。
<code>app</code>の部分が実際にアプリの情報で、
<code>main</code>があとで説明するこのプラグインのUIのためのJavaScriptファイル(public/app.js)になります。mainですので、最初に読み込まれる処理が記載されているものを指定します。<code>app.js</code>というファイル名を変更する場合は、こちらの<code>app</code>の部分を変更したファイルに合わせましょう。</p>

<p><code>config(Joi)</code>の関数が設定ファイルの読み込みなどの処理を記載する場所です。</p>

<p><code>init(server, options)</code>の関数が初期化処理を記載する場所になります。
このサンプルアプリでは、2行目の<code>import</code>で読み込んだhapi.js用のファイルの関数を呼び出しています。引数で渡している<code>server</code>がhapi.jsの<code>server</code>オブジェクトになります。
<code>route</code>メソッドを使用して作成しているプラグイン用のREST APIを追加しています。</p>

<pre><code class="javascript">import { resolve } from 'path';
import exampleRoute from './server/routes/example';

export default function (kibana) {
  return new kibana.Plugin({
    require: ['elasticsearch'],
    name: 'simple-sample-kibana-plugin',
    uiExports: {

      app: {
        title: 'Simple Sample Kibana Plugin',
        description: 'Sample plugin for explaining how to make kibana app',
        main: 'plugins/simple-sample-kibana-plugin/app'
      },

...
    },

    config(Joi) {
      return Joi.object({
        enabled: Joi.boolean().default(true),
      }).default();
    },

    init(server, options) {
      // Add server routes and initialize the plugin here
      exampleRoute(server);
    }
  });
};
</code></pre>

<h4>public/app.js</h4>

<p>画面用のモジュールです。
<code>uiRoutes</code>という機能を使用して、アプリの呼び出しURLを定義します。テンプレートで作成したばかりの場合は、<code>/</code>というURLが追加されるのみです。</p>

<p>実際に画面を表示する際に動くコントローラーの部分はその下の
<code>uiModules.controller</code>に指定してあるfunctionが画面描画の
処理を書く部分になります。
templateで作成したプラグインでは、&#8221;title&#8221;など表示に必要なデータを<code>$scope</code>というオブジェクトに詰め込んでいます。
これはAngularJS(1系)でのモデルオブジェクトになります。</p>

<pre><code class="javascript">import moment from 'moment';
import { uiModules } from 'ui/modules';
import uiRoutes from 'ui/routes';

import 'ui/autoload/styles';
import './less/main.less';
import template from './templates/index.html';

uiRoutes.enable();
uiRoutes
  .when('/', {
    template,
    resolve: {
...
    }
  });

uiModules
  .get('app/simple-sample-kibana-plugin', [])
  .controller('simpleSampleKibanaPluginHelloWorld', function ($scope, $route, $interval) {
    $scope.title = 'Simple Sample Kibana Plugin';
    $scope.description = 'Sample plugin for explaining how to make kibana app';
...
    $scope.$watch('$destroy', unsubscribe);
  });
</code></pre>

<h4>server/routes/example.js</h4>

<p><a href="https://hapijs.com">hapi.js</a>というNode.jsのためのサーバーフレームワークです。
このフレームワークをKibanaは使っており、Kibanaのサーバーとブラウザとのやり取りに使用するREST APIを記述するために使用しています。
例えば、Elasticsearchとのやり取りを実際に行うAPIなどをこのREST API内部で記述します。</p>

<pre><code class="javascript">export default function (server) {

  server.route({
    path: '/api/simple-sample-kibana-plugin/example',
    method: 'GET',
    handler(req, reply) {
      reply({ time: (new Date()).toISOString() });
    }
  });

}
</code></pre>

<p><code>path</code>の部分がブラウザ側からアクセスするURLになります。
実際にElasticsearchとやり取りする処理の書き方については、次回の記事で説明します。</p>

<h2>アーキテクチャ（簡易版）</h2>

<p>ざっくりですが、ファイルやディレクトリについて説明しました。
簡単なデータのやり取りについての流れを説明します。</p>

<p>Kibana自体はNode.jsで実装されサーバーとして動作していますが、ブラウザでアクセスすることで画面を描画しています。
簡単なコンポーネントを並べるとデータのやり取りはこのような形です。</p>

<p><img src="/images/entries/20180420/architecture.jpg" width="600"></p>

<p>すごく簡易で大雑把な絵ですが。。。</p>

<p>実際のプラグインとしては大きく、2つの処理があります。</p>

<ul>
<li>ブラウザ上の処理

<ul>
<li>クリックなどのイベント処理</li>
<li>HTMLなどのレンダリング処理</li>
</ul>
</li>
<li>Kibanaサーバー上の処理(Elasticsearchなどとの通信が必要な場合)

<ul>
<li>外部との通信処理</li>
<li>ブラウザ上では重い処理</li>
</ul>
</li>
</ul>


<p>絵に記載しましたが、ブラウザ上の処理についてはAngularJSが主なフレームワークで、サーバー上の処理についてはhapi.jsがフレームワークとなっています。</p>

<h2>まとめ</h2>

<p>ということで、今回はディレクトリ構造とファイルの説明、どういったフレームワークが使われ、データのやり取りがどのように行われているか説明しました。</p>

<p>次回からは、実際に私が作成した<a href="https://github.com/johtani/analyze-api-ui-plugin">Analyze UI</a>を元にElasticsearchとのデータのやり取りなどについて紹介していきます。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Analyze UIとKibanaのプラグインの作成方法（第2回）]]></title>
    <link href="http://blog.johtani.info/blog/2018/02/09/getting-started-template-kibana-plugin/"/>
    <updated>2018-02-09T18:17:37+09:00</updated>
    <id>http://blog.johtani.info/blog/2018/02/09/getting-started-template-kibana-plugin</id>
    <content type="html"><![CDATA[<p>第1回では、<a href="https://github.com/johtani/analyze-api-ui-plugin">Analyze UIというプラグイン</a>の紹介をしました、ごく簡単にですが。</p>

<p>第2回では、Kibanaのプラグインの作成方法を順を追って見ていこうと思います。今回は、プラグインのプロジェクトの作り方を説明します。
どんなファイルがあるのかなどについては第3回で説明します（2018/02月現在の方法になります。残念ながら、Kibanaのプラグイン作成自体はまだExperimentalな話になっていますので、変更がある可能性があります）。</p>

<!-- more -->


<p>実はそれほど難しいというわけではありません。Kibanaのプラグインを作成するためのテンプレートが用意されています。<a href="https://github.com/elastic/template-kibana-plugin/">template-kiban-plugin</a>です。
テンプレートのリポジトリのREADMEに作業手順の記載があります。</p>

<ol>
<li>KibanaのリポジトリをClone、Checkout</li>
<li>Node.jsの環境を用意する</li>
<li>Kibanaを起動できるようにする</li>
<li>SAOのインストール</li>
<li>テンプレートによるプロジェクトファイルの生成</li>
</ol>


<p>順を追って説明します。
<code>PLUGIN_DEV_DIR</code>というディレクトリ配下で作業をしている想定になります。</p>

<h2>1. KibanaのリポジトリをClone、Checkout</h2>

<p>開発環境として、Kibanaが必要です。Kibanaのプラグインを作るので。
手順などは<a href="https://github.com/elastic/kibana/blob/6.2/CONTRIBUTING.md#contributing-code">KibanaのCONTRIBUTING.md</a>に記載があります。
ということで、まずはKibanaのリポジトリをCloneします。</p>

<pre><code>cd PLUGIN_DEV_DIR
git clone git@github.com:elastic/kibana.git
</code></pre>

<p>このままだと、masterブランチなので、開発したい対象のKibanaのバージョンのブランチもしくはタグをcloneします。今回は6.2.1向けということで、次のようになります。</p>

<pre><code>git checkout v6.2.1
</code></pre>

<p>これで、ソースが6.2.1向けになりました。</p>

<h2>2. Node.jsの環境を用意する</h2>

<p>Node.jsをインストールします。
Kibanaのリポジトリに<code>.node-version</code>というファイルがあります。
こちらにNode.jsのバージョンが記載されています。
Kibanaが使用しているNode.jsを利用できるようにします。ローカルでは<a href="https://github.com/creationix/nvm#installation">nvm</a>利用してインストールしました。後から、切り替えが可能だからです。
nvm自体のインストールについては<a href="https://github.com/creationix/nvm">nvmのサイト</a>をご覧ください。
nvmがインストールできたら、次のコマンドで、Kibanaが使用しているバージョンをインストールします。</p>

<pre><code>cd kibana
nvm install "$(cat .node-version)"
</code></pre>

<p>すでにnvmを利用している場合などは、Kibana起動時にKibanaのバージョンに合わせたNode.jsに切り替えるようにしてください。</p>

<h2>3. Kibanaを起動できるようにする</h2>

<p>Kibanaでは<a href="https://yarnpkg.com/lang/en/">yarn</a>というjavascript向けのパッケージマネージャーを利用して起動やビルドなどを行います。まずはyarnをインストールします。<a href="https://github.com/elastic/kibana/pull/15485">最近npmからyarnに切り替えた</a>ようです。
私はMacだったので、<a href="https://yarnpkg.com/en/docs/install">brewでインストール</a>しました。
インストールできたら、次のコマンドを実行します。</p>

<pre><code>yarn
</code></pre>

<p>これにより、package.jsonから必要なライブラリなどをダウンロードして来てくれます。
問題なければ「✨  Done in 439.30s.」というような表示がされます（結構時間かかりますね）。
では、Kibanaを起動できるか確認してみましょう。
さらに、Elasticsearchも起動してみます。
Kibanaのpackage.jsonの中にはElasticsearchを起動するためのスクリプトも用意されています。実際には<a href="https://gruntjs.com">grunt</a>を利用してタスクを実行しているようです。Elasticsearchの起動にはJavaが必要になります。
今回は6.2.1なので、JDK 8以降がインストールされている必要があります。
こちらはインストールされているものとします。</p>

<pre><code>yarn elasticsearch
</code></pre>

<p>で起動できます。</p>

<pre><code>&gt;&gt; Started 1 Elasticsearch nodes.
</code></pre>

<p>という表示が出てればOKです。
次にKibanaです。別のTerminalを起動して、以下のコマンドで起動できます。</p>

<pre><code>yarn start
</code></pre>

<p>これだけです。
<code>
server    log   [06:58:56.930] [info][listening] Server running at http://localhost:5603
</code>
この辺りが出てればKibanaのServerは起動済みです。また、Elasticsearchに接続できていれば、次のログが出ているはずです。</p>

<pre><code>server    log   [07:02:18.010] [info][status][plugin:elasticsearch@6.2.1] Status changed from red to green - Ready
</code></pre>

<p>Elasticsearch接続用のKibanaのプラグインの状態になります。
これで、Kibanaの環境が整ったことが確認できました。
もちろん、Elasticsearchに関しては、yarnで起動せずに、tar.gzなどでダウンロードして来たElasticsearchを起動しておき、アクセスするといったことも可能です。プラグインなどをElasticsearchにもいれてテストしたい場合などはそちらの方が便利かもしれません。</p>

<h2>4. SAOのインストール</h2>

<p>では、一度、ElasticsearchとKibanaを停止しましょう。フォワグラウンドで起動しているので、それぞれのTerminalでCtrl+Cで停止できます。
Kibanaのプラグイン作成むけに、テンプレートが作られています。<a href="https://sao.js.org">sao.js</a>というGitHubのリポジトリやnpmのパッケージをテンプレートとして使うことができるツールを利用してプラグインのプロジェクト（リポジトリ）を作成します。
実際にテンプレートとなるリポジトリは<a href="https://github.com/elastic/template-kibana-plugin">template-kibana-plugin</a>になります。
まずはSaoのインストールです。</p>

<pre><code>npm install -g sao
</code></pre>

<p>プラグインのテンプレートのページには上記のようにnpmを利用したインストール方法になっていますが、次のようにyarnでも可能です。</p>

<pre><code>yarn global add sao
</code></pre>

<p>これで、saoがインストールできました。</p>

<h2>5. テンプレートによるプロジェクトファイルの生成</h2>

<p>あとは、テンプレートを元にプロジェクトを作成します。
<code>PLUGIN_DEV_DIR</code>ディレクトリ配下に、kibanaと同じ階層で作成するプラグイン用のディレクトリを作成します。</p>

<pre><code>mkdir simple-sample-kibana-plugin
</code></pre>

<p>以下のような構成になります。</p>

<pre><code>kibana                      simple-sample-kibana-plugin
</code></pre>

<p>次にテンプレートを適用していきます。
<code>
cd simple-sample-kibana-plugin
sao kibana-plugin@7.2.4
</code></p>

<p>2行目がsaoを利用してプロジェクトを作成しているコマンドになります。
すると、次のような質問が出て来ます。
これらに答えるとプロジェクトに必要なファイル（package.jsonやREADME.mdなど）に入力した情報を適用したものを作ってくれます。</p>

<pre><code>? Name of your plugin?
? Provide a short description
? What Kibana version are you targeting?
? Should an app component be generated?
? Should translation files be generated?
? Should an hack component be generated?
? Should a server API be generated?
</code></pre>

<p>実際に答えた内容はこちら。</p>

<pre><code>? Name of your plugin? simple-sample-kibana-plugin
? Provide a short description Sample plugin for explaining how to make kibana app
? What Kibana version are you targeting? 6.2.1
? Should an app component be generated? Yes
? Should translation files be generated? Yes
? Should an hack component be generated? Yes
? Should a server API be generated? Yes
</code></pre>

<p>プラグインの名前などは、ディレクトリ名と同じものを入力補完してくれているので、そのままEnterでもOKです。
Descriptionについてはわかりやすいものを入力しましょう。
バージョンは、先ほどのKibanaのリポジトリに合わせて、<code>6.2.1</code>にしてあります。
あとは、作るプラグインの種類に応じて、必要なコンポーネントを作るかどうかの質問にYes/Noで答えます。
今回はサンプルの説明ということもあるので、全てYesで答えました。
ちなみに、私が実際に作成した<a href="https://github.com/johtani/analyze-api-ui-plugin/">analyze-api-ui-plugin</a>では、<code>app</code>と<code>translation</code>と<code>server</code>の3つを作成しました。
ただし、<code>translation</code>については現在はテンプレートで作成したままのファイルが入っており、実際には利用してないです。</p>

<p>完了したら、プラグインのサンプル入りのプロジェクトが完成です。
もう一度、Elasticsearchを立ち上げて、プラグインのプロジェクトからKibanaを起動してアクセスしてみます。まずは、<code>PLUGIN_DEV_DIR/kibana</code>ディレクトリの下で、Elasticsearchを起動します。</p>

<pre><code>yarn elasticsearch
</code></pre>

<p>次に、<code>PLUGIN_DEV_DIR/simple-sample-kibana-plugin</code>ディレクトリの下で、以下のコマンドを実行し、プラグインが入った状態のKibanaを起動します。</p>

<pre><code>yarn start
</code></pre>

<p>問題なく起動すれば、ブラウザでアクセスすると次のような画面が表示されるはずです。</p>

<p><img src="/images/entries/20180214/sample_start.jpg" width="800"></p>

<p>左側にメニューが1つ増えています。
クリックすると、上記画像のような画面が表示されるはずです。</p>

<p>これで、カスタムプラグインの開発ができる環境ができました！
次回は、プロジェクトのディレクトリ構成や、どんなツールが内部で使用されてデータのやり取りが行われているかについて説明します。お楽しみに。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Analyze UIとKibanaのプラグインの作成方法（第1回）]]></title>
    <link href="http://blog.johtani.info/blog/2018/01/19/how-to-make-kibana-plugin-example-analysis-ui/"/>
    <updated>2018-01-19T15:36:46+09:00</updated>
    <id>http://blog.johtani.info/blog/2018/01/19/how-to-make-kibana-plugin-example-analysis-ui</id>
    <content type="html"><![CDATA[<p>あけましておめでとうございます。今年はサボりがちだったブログをちょっとずつ復活させようかと。
ということで、第1弾として、昨年少し作っていたKibanaのプラグインを何度かに分けて紹介したいと思います。</p>

<p>今回は<a href="https://github.com/johtani/analyze-api-ui-plugin">Analyze UIというプラグイン</a>の紹介です。</p>

<!-- more -->


<p>今回はインストール方法と簡単な機能紹介です。
細かな紹介は個別にやりたいと思います。</p>

<h3>Analyze UI pluginとは？</h3>

<p>Elasticsearchの<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/indices-analyze.html"><code>_analyze</code>というAPI</a>(個人的に好きなAPIです)をご存知でしょうか？</p>

<p>Elasticsearchは全文検索エンジンで、データの検索には<a href="https://ja.wikipedia.org/wiki/%E8%BB%A2%E7%BD%AE%E3%82%A4%E3%83%B3%E3%83%87%E3%83%83%E3%82%AF%E3%82%B9">転置インデックス</a>というものを使用します。
Elasticsearchにデータを登録する際に、<code>text</code>型のデータの場合、この転置インデックスのキーとなる単語を決める処理のことを<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis.html">Analysis</a>と呼びます（Analysisの詳細については割愛します。後日説明するかも？）。
このAnalysisの処理が、入力されたデータの文字列に対してどのように行われて、結果としてどんな単語がキーとして用いられているかを確認できる機能が<code>_analyze</code> APIです。検索で単語がうまくヒットしないな？とか、なんで、こんなので検索結果に出てくるんだ？といった場合、このAPIを利用すると、どのような単語で転置インデックスが作られているかがわかるので、検索にヒットしない/する理由を見つけることができます。</p>

<p>Elasticsearchの便利な点はRESTfulなAPI＋JSONでやりとりができる点なのですが、<code>_analyze</code> APIの結果をJSONで受け取っても、見るのにちょっと苦労します。。。こんな感じ。</p>

<p>リクエスト：
<code>
POST _analyze
{
  "analyzer": "kuromoji",
  "text": "今年はブログをいっぱい書きますよ！"
}
</code></p>

<p>レスポンス：
<code>
{
  "tokens": [
    {
      "token": "今年",
      "start_offset": 0,
      "end_offset": 2,
      "type": "word",
      "position": 0
    },
    {
      "token": "ブログ",
      "start_offset": 3,
      "end_offset": 6,
      "type": "word",
      "position": 2
    },
    {
      "token": "いっぱい",
      "start_offset": 7,
      "end_offset": 11,
      "type": "word",
      "position": 4
    },
    {
      "token": "書く",
      "start_offset": 11,
      "end_offset": 13,
      "type": "word",
      "position": 5
    }
  ]
}
</code></p>

<p>このくらいの量であればまだなんとかなりますが、文章が長くなると辛いですよね。</p>

<p>ということで、GUIがあると便利だろうなぁと。で、作ってみましたというのが今日紹介するKibana用のAnalyze UIプラグインです。
こんな感じで、Kibanaのアプリの一部として動作しブラウザ上で、入力テキストの文字列がどのようにanalyzeされて、単語になるかがわかります。</p>

<p><img src="/images/entries/20180119/analyze_ui_sample_1.jpg" width="800"></p>

<p>（先ほどのAPIのサンプルと同じものを画面で入力した結果になります）。</p>

<h3>インストール方法</h3>

<p>現時点の最新版Kibana（6.1.2）に対応しています。
Kibanaのディレクトリで<code>kibana-plugin</code>コマンドを利用してインストールします。</p>

<pre><code>./bin/kibana-plugin install https://github.com/johtani/analyze-api-ui-plugin/releases/download/6.1.2/analyze-api-ui-plugin-6.1.2.zip
</code></pre>

<p>これだけです。
で、Kibanaを起動していただくと、左のメニューに「Analyze UI」という項目が増えています。</p>

<p><img src="/images/entries/20180119/kibana_menu.jpg" width="400"></p>

<p>クリックすると、Analyze UIが表示されます。</p>

<p>初期画面は入力された文字を特定のAnalyzerで処理した場合の結果を見るための画面です。綱目の説明は画像をご覧ください。</p>

<p><img src="/images/entries/20180119/intro_analyze_ui_1.jpg" width="800"></p>

<p>先ほどのJSONよりは見やすくなったかと思います。
そのほかにもいくつか画面や機能があるのですが、今日はこの辺りで。
「<code>_analyze</code> API便利なんだけど、JSONは。。。」とか「検索うまくできないなぁなんでだろう？」と思っている方は、ぜひ試して見ていただければと。
問題点などありましたら、GitHubのIssueを登録してください。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Lucene Kuromoji for NEologdで指定した品詞の単語を抜き出すIngest Pluginを書いてみた #elasticsearchjp]]></title>
    <link href="http://blog.johtani.info/blog/2016/07/22/making-ingest-processor-plugin-with-cookiecutter/"/>
    <updated>2016-07-22T13:26:56+09:00</updated>
    <id>http://blog.johtani.info/blog/2016/07/22/making-ingest-processor-plugin-with-cookiecutter</id>
    <content type="html"><![CDATA[<p>久しぶりに、技術的なブログ書いてます。</p>

<p>Ingest Processorのプラグインを作ってみたくなったので、書いてみました。
ただ書いてみるんじゃ3番煎じになりそうなので、<a href="https://cookiecutter.readthedocs.io/en/latest/readme.html">cookiecutter</a>を使ってみました。</p>

<!-- more -->


<p>と言っても、同僚のAlexが<a href="https://discuss.elastic.co/t/cookiecutter-template-for-writing-ingest-processors/52985">cookiecutter-elasticsearch-ingest-processor</a>と言うテンプレートを作ってくれているのを使っただけですが。（<a href="https://discuss.elastic.co">https://discuss.elastic.co</a> に投稿された記事で、使い方がアニメgifで説明されててわかりやすいです）</p>

<p><a href="https://cookiecutter.readthedocs.io/en/latest/readme.html">cookiecutter</a>とは、コマンドラインで質問に答えると、テンプレートからプロジェクトが生成できるツールです。
Elasticでは、カスタムBeatを作る時に利用する例がいつかの日本語ブログや発表資料で話題になっていました。
これのIngest Processorのプラグインバージョンです。</p>

<p>今回は、NEologdも使ってみたかったので、Lucene Kuromoji for NEologdを利用して
指定した品詞の単語だけを抽出するProcessorを作ってみました。</p>

<p>GitHubのプロジェクト：<a href="https://github.com/johtani/elasticsearch-ingest-kuromoji-pos-extract">https://github.com/johtani/elasticsearch-ingest-kuromoji-pos-extract</a></p>

<h3>Cookiecutterの使い方</h3>

<p><a href="https://cookiecutter.readthedocs.io/en/latest/readme.html">Cookiecutterのインストールはサイト</a>をご覧ください。</p>

<pre><code>cookiecutter gh:spinscale/cookiecutter-elasticsearch-ingest-processor
</code></pre>

<p>あとは、出てくる以下の項目を指定するだけです。</p>

<ul>
<li><code>processor_type</code> : Ingest Processorのタイプ名です。<code>kuromoji_part_of_speech_extract</code>としました。（Alexのだと<code>_</code>を使うとちょっと問題があるので後述）</li>
<li><code>description</code> : readme.mdに利用されます。</li>
<li><code>developer_name</code> : 名前を記載。Javaのファイルのヘッダに利用</li>
<li><code>elasticsearch_version</code> : デフォルトで<code>5.0.0-alpha4</code>が指定されているので、特に指定せず</li>
</ul>


<p>以上の質問に答えたら、プロジェクトのディレクトリ構造が出来上がってます。
プロジェクトのビルドなどにはGradleを利用します。</p>

<h3>プロジェクトのIntelliJ IDEA用のファイルを生成</h3>

<p>build.gradleファイルでGradleのideaプラグインがapplyされているので、以下のコマンドを叩けばIntelliJ IDEAのプロジェクトファイル（？）が生成され、IntelliJで開けばすぐに開発ができる状態にできます。</p>

<pre><code>gradle idea
</code></pre>

<h3>コーディング</h3>

<p>あとは、必要処理をコーディングします。
実際にコーディングするクラスは<code>org.elasticsearch.plugin.ingest.kuromoji_part_of_speech_extract</code>のパッケージにある以下の2つです。（パッケージ名にはprocessor_typeの名前が指定されている）</p>

<ul>
<li>IngestKuromojiPartOfSpeechExtractPlugin</li>
<li>KuromojiPartOfSpeechExtractProcessor</li>
</ul>


<h4>IngestKuromojiPartOfSpeechExtractPlugin</h4>

<p>Pluginというクラスは、プラグインをNodeのModuleとして登録する処理を書くクラスとなります。
生成してすぐは、次のような形になっています。（※importやクラス定義の部分は省略しています。）</p>

<pre><code class="Java">...
    public static final Setting&lt;String&gt; YOUR_SETTING =
            new Setting&lt;&gt;("ingest.kuromoji_part_of_speech_extract.setting", "foo", (value) -&gt; value, Setting.Property.NodeScope);

    @Override
    public List&lt;Setting&lt;?&gt;&gt; getSettings() {
        return Arrays.asList(YOUR_SETTING);
    }

    public void onModule(NodeModule nodeModule) throws IOException {
        nodeModule.registerProcessor(KuromojiPartOfSpeechExtractProcessor.TYPE,
                (registry) -&gt; new KuromojiPartOfSpeechExtractProcessor.Factory());
    }
...
</code></pre>

<p><code>YOUR_SETTING</code>プロパティと<code>getSettings()</code>メソッドは<code>elasticsearch.yml</code>で指定したい設定を記述する場合の例になります。今回は特に必要ないので両方削除しました。
最終系は<a href="https://github.com/johtani/elasticsearch-ingest-kuromoji-pos-extract">GitHubのコード</a>をご覧ください。</p>

<h4>KuromojiPartOfSpeechExtractProcessor</h4>

<p>Processorは実際にIngest Nodeで行う処理を書くところです。</p>

<pre><code class="Java">
    public static final String TYPE = "kuromoji_part_of_speech_extract";

    private final String field;
    private final String targetField;

    public KuromojiPartOfSpeechExtractProcessor(String tag, String field, String targetField) throws IOException {
        super(tag);
        this.field = field;
        this.targetField = targetField;
    }

    @Override
    public void execute(IngestDocument ingestDocument) throws Exception {
        String content = ingestDocument.getFieldValue(field, String.class);
        // TODO implement me!
        ingestDocument.setFieldValue(targetField, content);
    }

    @Override
    public String getType() {
        return TYPE;
    }

    public static final class Factory extends AbstractProcessorFactory&lt;KuromojiPartOfSpeechExtractProcessor&gt; {

        @Override
        public KuromojiPartOfSpeechExtractProcessor doCreate(String processorTag, Map&lt;String, Object&gt; config) throws Exception {
            String field = readStringProperty(TYPE, processorTag, config, "field");
            String targetField = readStringProperty(TYPE, processorTag, config, "target_field", "default_field_name");

            return new KuromojiPartOfSpeechExtractProcessor(processorTag, field, targetField);
        }
    }
</code></pre>

<p><code>TYPE</code>が<a href="https://www.elastic.co/guide/en/elasticsearch/reference/master/put-pipeline-api.html">Ingest APIのPipelineでProcessorを指定するときに使う名前</a>になります。ここは、cookiecutterの時にprocessor_typeに入力した文字列になっています。
<code>kuromoji_part_of_speech_extract</code>だと長いので、<code>kuromoji_pos_extract</code>に変えました。</p>

<p><code>execute()</code>メソッドに<code>// TODO implement me!</code>とあります。
この部分に実際の処理を記述していきます。</p>

<p>あとは、<code>Factory</code>クラスでIngest APIで指定された設定項目を読み込みます。
今回作成した<code>elasticsearch-ingest-kuromoji-pos-extract</code>では品詞を指定する必要があるので、<code>pos_tags</code>を指定できるように処理を追加しました。</p>

<p>私が実装したものの説明をするとちょっと長くなりそうなので、<a href="https://github.com/johtani/elasticsearch-ingest-kuromoji-pos-extract">GitHubのコード</a>をご覧ください。</p>

<h3>テストのコーディング</h3>

<p>テストのクラスもテンプレートで生成されています。</p>

<ul>
<li>KuromojiPartOfSpeechExtractProcessorTests</li>
<li>KuromojiPartOfSpeechExtractRestIT</li>
</ul>


<h4>KuromojiPartOfSpeechExtractProcessorTests</h4>

<p>Processorクラスのテストになります。生成直後は次のような感じです。</p>

<pre><code class="Java">public void testThatProcessorWorks() throws Exception {
    Map&lt;String, Object&gt; document = new HashMap&lt;&gt;();
    document.put("source_field", "fancy source field content");
    IngestDocument ingestDocument = RandomDocumentPicks.randomIngestDocument(random(), document);

    KuromojiPartOfSpeechExtractProcessor processor = new KuromojiPartOfSpeechExtractProcessor(randomAsciiOfLength(10), "source_field", "target_field");
    processor.execute(ingestDocument);
    Map&lt;String, Object&gt; data = ingestDocument.getSourceAndMetadata();

    assertThat(data, hasKey("target_field"));
    assertThat(data.get("target_field"), is("fancy source field content"));
    // TODO add fancy assertions here
}
</code></pre>

<p>テストメソッドも実装されていますが、パラメータの追加の設定処理やアサーションが書かれてません。
実装に合わせて、アサーションや設定処理を追加しましょう。</p>

<h4>KuromojiPartOfSpeechExtractRestIT</h4>

<p>こちらはIntegration Testになります。
実際にElasticsearchに対して外部からAPIを叩くような感じです。
APIを叩くときに利用するJSONの設定やアサーションは<code>src/test/resources</code>にyamlファイルがあります。</p>

<ul>
<li>10_basic.yaml</li>
<li>20_kuromoji_part_of_speech_extract_processor.yaml</li>
</ul>


<p><code>10_basic.yaml</code>はプラグインがインストールされているかの確認のテストです。特に変更する必要はないです。</p>

<p><code>20_kuromoji_part_of_speech_extract_processor.yaml</code>は実際にコーディングしたProcessorが動くかどうかのテストです。</p>

<p>テストの内容については、<a href="https://github.com/johtani/elasticsearch-ingest-kuromoji-pos-extract">GitHubのコード</a>をご覧ください。</p>

<h3>テストの実行とZipの生成</h3>

<p>テストの実行とZipの生成は次のコマンドを実行すればOKです。</p>

<pre><code>gradle check
</code></pre>

<p>テストに問題があった場合は、コケますし、問題なければ<code>SUCCESS</code>と表示が出ます。
成功した場合は<code>build/distributions/</code>というディレクトリにzipファイルができています。
これをElasticsearchのpluginコマンドでインストールすれば動きます。</p>

<pre><code>bin/plugin install file:///path/to/elasticsearch-ingest-kuromoji-pos-extract/build/distribution/ingest-kuromoji_part_of_speech_extract-0.0.1-SNAPSHOT.zip
</code></pre>

<h3>kuromoji_pos_extractの利用方法</h3>

<p>Ingest APIには便利な<a href="https://www.elastic.co/guide/en/elasticsearch/reference/master/simulate-pipeline-api.html">Simulate Pipeline API</a>があります。</p>

<p>ということで、<a href="https://github.com/neologd/mecab-ipadic-neologd/blob/master/README.ja.md">mecab-ipadic-NEologd</a>にあったサンプルの文章を使って、使い方の説明です。</p>

<pre><code class="JSON">POST _ingest/pipeline/_simulate
{
  "pipeline" : {
    "description" : "kuromoji neologd extract test",
    "processors" : [
      {
        "kuromoji_pos_extract" : {
        "field" : "body",
        "target_field" : "noun_field",
        "pos_tags" : [
          "名詞-固有名詞-組織",
          "名詞-固有名詞-一般",
          "名詞-固有名詞-人名-一般",
          "名詞-固有名詞-地域-一般",
          "名詞-固有名詞-地域-国"
          ]
        }
      }
      ]
  },
  "docs" : [
    {
      "_index": "index",
      "_type": "type",
      "_id": "id",
      "_source": {
        "body" : "10日放送の「中居正広のミになる図書館」（テレビ朝日系）で、SMAPの中居正広が、篠原信一の過去の勘違いを明かす一幕があった。"
      }
    }
    ]
}
</code></pre>

<p>結果はこちら。</p>

<pre><code class="JSON">{
  "docs": [
    {
      "doc": {
        "_index": "index",
        "_id": "id",
        "_type": "type",
        "_source": {
          "noun_field": [
            "10日",
            "中居正広のミになる図書館",
            "テレビ朝日",
            "SMAP",
            "中居正広",
            "篠原信一"
          ],
          "body": "10日放送の「中居正広のミになる図書館」（テレビ朝日系）で、SMAPの中居正広が、篠原信一の過去の勘違いを明かす一幕があった。"
        },
        "_ingest": {
          "timestamp": "2016-07-22T06:18:49.007+0000"
        }
      }
    }
  ]
}
</code></pre>

<p><code>noun_field</code>に固有名詞の単語が抜き出せているのがわかるかと思います。</p>

<h3>Alexのテンプレートで困った点</h3>

<p>テンプレートは便利だったのですが、<code>processor_type</code>に<code>_</code>を使用したタイプ名を指定すると次のような問題（？）が発生しました。</p>

<ul>
<li>クラス名が<code>Kuromoji_part_of_speech_extractProcessor</code>となってしまう</li>
</ul>


<p>深刻な問題ではないのですが、JavaだとCamel Caseが普通なのでちょっと気になって。
ということで、<a href="https://github.com/spinscale/cookiecutter-elasticsearch-ingest-processor/pull/1">プルリク</a>作って出してみました。まだ取り込まれてないかな。</p>

<p>取り込み前に使いたい方は以下のコマンドを実行してください。
<code>processor_class_name</code>という項目が増えています。
デフォルトだと<code>processor_type</code>の<code>_</code>の部分を取り除きつつCamel Caseにしたものが入ります。</p>

<pre><code>cookiecutter gh:johtani/cookiecutter-elasticsearch-ingest-processor
</code></pre>

<h3>まとめ</h3>

<p>ということで、とりあえず作ってみましたというものになります。
特徴的な単語（固有名詞だけ）を抜き出して、別のフィールドにできるので、タグみたいなものをこれを使って前処理で作れるようになるかなぁと。</p>

<h2>参考ブログ（元ネタ？）</h2>

<p>インスパイア元となったブログです。</p>

<ul>
<li><a href="http://dev.classmethod.jp/server-side/elasticsearch/ingest-plugin-useragent/">User Agentを解析するIngest Pluginを書いてみた</a></li>
<li><a href="http://blog.cybozu.io/entry/2016/07/05/080000">Elasticsearch 5.0.0のIngest Node用プラグインを書いた話</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Sonatypeのバージョン番号で困ったので]]></title>
    <link href="http://blog.johtani.info/blog/2014/10/15/versioning-of-sonatype/"/>
    <updated>2014-10-15T15:26:08+09:00</updated>
    <id>http://blog.johtani.info/blog/2014/10/15/versioning-of-sonatype</id>
    <content type="html"><![CDATA[<p><a href="http://blog.johtani.info/blog/2014/10/02/elasticsearch-1-4-0-beta-released-ja/">Elasticsearch 1.4.0.Beta1がリリース</a>されました。</p>

<p>個人で<a href="https://github.com/johtani/elasticsearch-extended-analyze">elasticsearch-extended-analyze</a>というプラグインを開発してます。
こちらも1.4.0.Beta1に対応するべく作業をしてて、少し戸惑ったことがあったので、メモをば。</p>

<!-- more -->


<p>ここ最近はプラグインのバージョン番号をElasticsearchのバージョン番号と同じものを利用していました。
（プラグインの機能追加をサボってる？？）
その時に、<code>1.4.0.Beta1</code>という番号を指定したのですが、意味不明なエラーに悩まされてしまいまして。</p>

<p>プラグインのリリースでは、以下のコマンドを実行します。</p>

<pre><code>$ mvn release:prepare
$ mvn release:perform
</code></pre>

<p>最初のコマンド（prepare）で、パッケージングを実施し、Githubにリリースタグを打ったバージョンがpushされます。
次のコマンド（perform）で、パッケージングされたzipファイルがsonatypeのサイトに公開するためにアップロードされます。</p>

<p><code>1.4.0.Beta1</code>というバージョン文字列を利用した場合、prepareは問題なく実行できたのですが、
performで以下の様なエラーが返ってきました。</p>

<pre><code>Return code is: 401, ReasonPhrase: Unauthorized.
</code></pre>

<p>バージョン番号が<code>1.3.0</code>では特に問題はなかったのですが、、、
結局、バージョン番号を<code>1.4.0-beta1</code>に変更すると問題なくリリースが完了しました。</p>

<p>mike_neckさんと話をしていて、<a href="http://semver.org">Semantic Versioning</a>に関係しているのかなぁという話にはなったのですが、
詳しく調べていません。。。</p>

<p>そのうち調べようかなぁ。。。。</p>
]]></content>
  </entry>
  
</feed>
