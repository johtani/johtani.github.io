<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[@johtaniの日記 2nd]]></title>
  <link href="http://blog.johtani.info/atom.xml" rel="self"/>
  <link href="http://blog.johtani.info/"/>
  <updated>2015-11-11T02:10:31+09:00</updated>
  <id>http://blog.johtani.info/</id>
  <author>
    <name><![CDATA[johtani]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[第13回Elasticsearch勉強会を開催しました。#elasticsearchjp]]></title>
    <link href="http://blog.johtani.info/blog/2015/11/10/13th-elasticsearch-jp/"/>
    <updated>2015-11-10T17:22:58+09:00</updated>
    <id>http://blog.johtani.info/blog/2015/11/10/13th-elasticsearch-jp</id>
    <content type="html"><![CDATA[<p><a href="https://elasticsearch.doorkeeper.jp/events/33631">第13回Elasticsearch勉強会</a>を開催しました。
スタッフの皆さん、スピーカーの皆さん、会場提供していただいた<a href="http://recruit-tech.co.jp">リクルートテクノロジーズさん</a>、ありがとうございました！
来年もよろしくお願いします！参加していただき盛り上げていただいた参加者の皆さんもありがとうございました。</p>

<p>7月同様、<a href="http://samuraism.com">サムライズム</a>の<a href="https://twitter.com/yusuke">@yusuke</a>さんに
テキスト翻訳していただき、大変助かりました。</p>

<!-- more -->


<h3>チェックイン数など</h3>

<ul>
<li>チェックインした人：100名</li>
<li>キャンセルしなかった人：36名</li>
</ul>


<p>でした。
今回は当日の時点でキャンセル待ちがない状態にしていました。
雨もあって、これなかった人もいるのでしょうか。</p>

<h2>&ldquo;Beyond the basics with Elasticsearch&rdquo; / Honza Král / Elastic</h2>

<p>スライド：<a href="https://speakerdeck.com/elasticsearch/beyond-the-basics-with-elasticsearch  ">https://speakerdeck.com/elasticsearch/beyond-the-basics-with-elasticsearch  </a>
参考ビデオ（別のカンファレンスで話した時のビデオ）：<a href="https://www.youtube.com/watch?v=yIixWzjTNog">https://www.youtube.com/watch?v=yIixWzjTNog</a></p>

<p>Pycon HKでアジアに来ていたHonzaに、ついでに日本で話をしてもらうという企画で、
前回から1カ月足らずでの開催となりました。
Elasticsearchの基本的な検索機能とは別の機能に関して少し話をしてもらった感じです。
<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-percolate.html">Percolator</a>と<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations.html">Aggregation</a>の話でした。</p>

<p>詳しくはビデオやスライドを見てもらうのがいいかなと。</p>

<h2>&ldquo;How did we use Found.no for our services?&rdquo; / 株式会社アイリッジ　Takuya Noguchi さん @tn961ir</h2>

<p>スライド：未定</p>

<ul>
<li>Foundユーザー。1.7までの話。</li>
<li>社内で独自にクラスタを構築していたが、managed serviceを利用したいと思っていた。</li>
<li>Found用のACLがShieldに</li>
<li>マルチバイトのインデックス名とかも使いたいが、Nginxとの連携でちょっと。。。</li>
<li>セキュリティ関連の話も。Securityに関する報告はこういうものも用意されてるので、こちらに相談してもらうのがいいかも。<a href="https://www.elastic.co/community/security">https://www.elastic.co/community/security</a></li>
<li>要望がいくつか。</li>
</ul>


<h2>&ldquo;ログ収集の仕組みを再考しよう！　あとマウンテンビューに行ってきました。&rdquo; / Acroquest Technology株式会社 谷本 心さん @cero_t</h2>

<p>スライド：<a href="http://www.slideshare.net/shintanimoto/lets-reconsider-about-collecting-logs-plus-visiting-elasticmoutain-view">http://www.slideshare.net/shintanimoto/lets-reconsider-about-collecting-logs-plus-visiting-elasticmoutain-view</a></p>

<p>ログの小話から始まり、ログに関する考え方とかを披露してもらいました。
さらに踏み込んだログの活用の方法の話になるかと思いきや、
思いっきり話が飛んで、マウンテンビューのElasticオフィスに遊びに行った写真が出てきましたw</p>

<p>写真の後は、弊社のTanya（<a href="https://www.elastic.co/elasticon/tour/2015/tokyo">来月のElastic{ON} Tour Tokyo</a>で来日予定）から
聞いた弊社製品に関する話をしていただきました。
きっと、Beatsに関して次は話してくれるんだろうなぁ（棒）。
流れ的には、<a href="https://www.elastic.co/elasticon/conf/2016/sf">来年の2月にサンフランシスコで開催されるElastic{ON}16</a>につながりそうだったので、ここで宣伝しときますね。
今年3月に開催されたイベントには残念ながら日本の方はいなかったので、次回は日本の方がいると嬉しいなぁと。</p>

<h2>LT &ldquo;「Elasticsearch を使った単語共起頻度の計算」&rdquo; / 株式会社はてな　id:takuya-a さん</h2>

<p>スライド：未定</p>

<p>一風変わったElasticsearchの使い方的な話でした。
検索用にデータを登録してあるElasticsearchから単語の頻度情報を抜き出して、
別のインデックスに登録するという感じでしょうか。
こういうのが、実は、Elasticsearchに機能としてあると便利だったりするのかもなぁと思ってみたり。</p>

<p>LTよりはちょっと長かったですかねw</p>

<h2>その他、感想などのブログ</h2>

<ul>
<li><a href="http://arika.hateblo.jp/entry/2015/11/09/204652">elasticsearch勉強会</a></li>
</ul>


<h2>まとめ＋宣伝</h2>

<p>今回も@yusukeさんのテキスト翻訳に助けていただきました。ほんとありがとうございます。
今年の勉強会はこれがラストになります。
来月は、トレーニングと<a href="https://www.elastic.co/elasticon/tour/2015/tokyo">Elastic{ON} Tour Tokyo</a>があるので忙しくなりそうですが、
参加予定の方は楽しみにしていてください！</p>

<ul>
<li>Operations : <a href="http://training.elastic.co/class/Operations/Japan/Dec">http://training.elastic.co/class/Operations/Japan/Dec</a></li>
<li>Developer : <a href="http://training.elastic.co/class/Developer/Japan/Dec">http://training.elastic.co/class/Developer/Japan/Dec</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Senseの歴史 - Sense 2.0.0-beta1の紹介(日本語訳)]]></title>
    <link href="http://blog.johtani.info/blog/2015/10/30/sense-2-0-0-beta1-ja/"/>
    <updated>2015-10-30T17:55:06+09:00</updated>
    <id>http://blog.johtani.info/blog/2015/10/30/sense-2-0-0-beta1-ja</id>
    <content type="html"><![CDATA[<p><strong>※この記事は次のブログを翻訳したものになります。</strong></p>

<p>原文：<a href="https://www.elastic.co/blog/sense-2-0-0-beta1">The Story of Sense - Announcing Sense 2.0.0-beta1</a></p>

<!-- more -->


<h2>誕生</h2>

<p>よくある良いプロジェクト同様、Senseもビールを飲みながら考えつきました。
<a href="https://en.wikipedia.org/wiki/Amstel">Amstel</a>での手漕ぎボートのセッションの後で。
友人の<a href="https://twitter.com/jkaizer">Jasper</a>と私はJasperの<a href="http://q42.nl/">会社</a>で毎年行われる
<a href="http://w00t.camp/">ハッカソン</a>について話をしていました。
このハッカソンはどのようなアイデアでどんなチームで行うかを聞き取りされる、厳密なハッカソンです。
その時、私とJasperはChromeブラウザに別のヒストリーを表示するという作業をやると<a href="https://twitter.com/anneveling">Anne Veling</a>に話をしていました。</p>

<p>Jasperと私はElasticsearchのユーザでしたが、リッチなREST APIにリクエストを送信するための
便利なツールがないと知っていました。
恥ずべきことに、cURLコマンドを利用するターミナルがその時の一番良いツールでした。
皆さん、ターミナルでボディつきのリクエストをサブミットするのがどのくらい不便かというのをわかるために、
5秒ほどターミナルで実行してみてください。
タイプミスのような単純なことでさえ、すべてのコマンドを再タイプしなければならなかったり、
複数行サポートのターミナルと戦ったりです。
ウェブベースのJSONエディタを見つけ出して、それをベースにすることが必要でした。</p>

<h2>終わりなきウィークエンド</h2>

<p>リサーチをして、Anneに電話しました。
私は彼に、History Pageのプロジェクトにもコミットするが、
Elasticsearchユーザなので、便利なコンソールを開発する時間も欲しいという話をしました。
私たちは、<a href="https://ace.c9.io/">Ace</a>オンラインエディタを利用して、
自動でAPIを認識するナレッジベースを構築し、
コンテキストに沿ったサジェストを大なうようにしました。
Anneはすぐに、それが素晴らしいと同意してくれました。
しかし、彼は、ハッカソンの基本的なルール（週末にそれが終わる必要がある）に違反しているので、
そのアイデアを却下するしかありませんでした。
確かに、私たちが提案していたものは行えませんでした。
最後に、私たちは、ChromeのHistory Pageの素晴らしい置き換えについて実装しました。</p>

<p>それでも、私はチャレンジし、それが終わるであろうことを終わるであろうことを証明しなければなりませんでした。
次の週末（といくつかの終業後 :)）に、私はそれを作りました。
Senseの誕生です。
それは、まだバグだらけでしたが、動きました。
これを見せるとみんな興奮しました。</p>

<h2>初期</h2>

<p>Knowledge Baseの拡張とバグのフィックスで数日を過ごしました。
Senseは広まり始め、ずっと古いバグのあるバージョンを利用しないといけないのかと私は恐れました。
SenseをChromeのExtentionとしてリリースすることを決め、リリースすると自動的に更新されるようにしました。
History Panelのような機能を一つづつ追加するようにしました。</p>

<p>Elasticにジョインしてから、会社の人たちがSenseを使用しているということを聞き、とても幸せでした。
特に、<a href="https://twitter.com/clintongormley">Clint</a>と話をしたときのことを覚えています。
彼は、&#8221;You know what Sense should do? It should use this format and allow you to have multiple requests in the editor&#8221;
「Senseになにをすべきかわかる？フォーマットを使うべきだし、エディタで複数のリクエストを持つようにするべきだ」
と言いました。
もちろん、その他のチャレンジも行いました。これは、簡単なものではなく、Aceの詳細を知る必要がありました。
それは新しいAceモード（Aceによって利用されているハイライティングロジック）です。
これは、Senseのサジェストエンジンに密に統合されました。</p>

<p>次のものが古いSenseのスクリーンショットです。</p>

<p>画像あり。Figure 1. Sense 0.7
<a href="https://www.elastic.co/blog/sense-2-0-0-beta1">※画像に関しては原文をご覧ください。</a></p>

<p>APIのURLを入力すると、JSONのボディが入力されます。
うまく切り離すことができ、AceのスタンダードJSONモードを使っていました。
しかし、ここで、次のようなフォーマットをどうやってサポートするか考える必要がありました。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>GET _cluster/health
</span><span class='line'>POST index/_settings
</span><span class='line'>{
</span><span class='line'>  "index": { "number_of_replicas": 3 }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>これは、Aceが3つの異なるものをどうやってパースするかを知る必要があるということです。
HTTPメソッドとURLとJSONボディです。
また、困ったことに、前に説明した前に説明した通り、明らかに別々にはならないものでした。
JSONボディが完全であることを知る唯一の方法はかっこを数えることです。
それは、いくつかの作業とAceのカスタマイズが必要でしたが、それらを切り離すことができました。
そして、Senseのシンタックスが生まれたのです（Thanks Clint!）</p>

<h2>Marvel時代</h2>

<p>就業時間中、私の優先すべき仕事は<a href="https://www.elastic.co/products/marvel">Marvel</a>の開発になりました。
これは、Elasticsearchのための管理と監視のためのソリューションです。
（side note: Marvelは生まれ変わっています。（&#8221;<a href="https://www.elastic.co/blog/shield-watcher-and-marvel-2-0-ga-released">Shield, Watcher, and Marvel 2.0.0 GA Released</a>&ldquo;））
Marvelは開発環境ではフリーなので、MarvelにSenseを組み込むことにしました。
これにより、Senseの開発が日中も行えるようになり、多くのユーザに利用され始めました。
また、Senseは実際に真の<a href="https://twitter.com/spenceralger">JavaScript開発者</a>によって開発されました。
彼は、コードをクリーンにし、ブラウザにおける最新の技術を私に教えてくれました。</p>

<p>この期間のSenseは数回書き換えられています。
最も顕著なものは、個別のURLとJSONのサジェストエンジンを書き換えて、
1つのサジェストエンジンにしこれらのコンテキストで動作するようにし、さらに3つ目のコンテキスト（URLパラメータ）を追加したことです。</p>

<p>新しいエンジンはまた、複数のサジェストコンテキストをメンテナンスするのが簡単になりました。
例えば、<code>_search API</code>のソートパラメータを考えます。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>GET _search
</span><span class='line'>{
</span><span class='line'>  "sort": [
</span><span class='line'>     "timestamp": "desc",
</span><span class='line'>     "price": {
</span><span class='line'>        "order": "desc".
</span><span class='line'>        "missing": "last"
</span><span class='line'>     },
</span><span class='line'>     "nested_filter": { "term": { ... }},
</span><span class='line'>     "_score"
</span><span class='line'>  ]
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<p>ユーザがどこにいるかによって、Senseは単純な値（<code>_score</code>のような）か、
複雑な構造（<code>order</code>と<code>missing</code>のような）やフィルタ（<code>nested_filter</code>のような）も
サジェストする必要があります。
これらのサジェストのパスが一度に処理され、無関係なものは除外されます。</p>

<h2>Sense 2.0の紹介！</h2>

<p>Marvel 1.xはKibana 3.0をベースにしていました。
これは、データの探索やダッシュボードツールとして素晴らしいものでした。
しかし、Kibanaチームはさらに素晴らしいものを出しました。
Kibana 4.xはElasticsearchをバックエンドとするUIアプリを簡単に構築することができる
プラットフォームとして設計されています。
実際に、<a href="https://www.elastic.co/guide/en/marvel/current/index.html">Marvel 2.0</a>はKibanaの
プラットフォームで利用できる最初のアプリです。</p>

<p>Senseの話に戻します。
ElasticsearchのAPIとやりとりする一般的なコンソールです。
これをKibanaのアプリぴったりだと気付きました。
ということで、<a href="https://github.com/elastic/sense/">Sense 2.0</a>をKibanaアプリとしてオープンソースで公開しました。
開発及び本番環境で利用してください。</p>

<p>Figure 2. Screenshot Sense 2.0
<a href="https://www.elastic.co/blog/sense-2-0-0-beta1">※画像に関しては原文をご覧ください。</a></p>

<h2>リリースのハイライト</h2>

<p>Sense 2.0の新しい機能をここで簡単に紹介します。
（すべての変更点については<a href="https://www.elastic.co/guide/en/sense/current/release_notes.html#_2_0_0_beta1">こちら</a>をご覧ください。）</p>

<h4>Elasticsearch 2.0</h4>

<p>SenseのナレッジベースをElasticsearch 2.0サポートに更新しました。
新しいPipeline aggregationにも対応しています。</p>

<h4>複数リクエストの実行</h4>

<p>テストやいくつかの一連のコマンドを繰り返し実行したい時があるでしょう。
その時に、それら全てをSenseに記述し、
実行したいリクエストを選択状態にしてElasticsearchにリクエストできます。</p>

<p>Figure 3. Submit multiple requests
<a href="https://www.elastic.co/blog/sense-2-0-0-beta1">※画像に関しては原文をご覧ください。</a></p>

<p>Senseは、Elasticsearchにリクエストを一つずつ送信し、それぞれの出力結果を右のパネルに表示します。
これは、問題のデバッグや複数のシナリオでのクエリの組み合わせの実行に非常に便利です。</p>

<h4>複数リクエストのコピーペースト</h4>

<p>複数リクストを選択し、フォーマットしたり、cURLのコマンドとしてコピーすることも可能です。</p>

<p>Figure 4. Copy multiple requests as cURL
<a href="https://www.elastic.co/blog/sense-2-0-0-beta1">※画像に関しては原文をご覧ください。</a></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># Delete all data in the `website` index
</span><span class='line'>curl -XDELETE "http://localhost:9200/website"
</span><span class='line'># Create a document with ID 123
</span><span class='line'>curl -XPUT "http://localhost:9200/website/blog/123" -d'
</span><span class='line'>{
</span><span class='line'>  "title": "My first blog entry",
</span><span class='line'>  "text":  "Just trying this out...",
</span><span class='line'>  "date":  "2014/01/01"
</span><span class='line'>}'</span></code></pre></td></tr></table></div></figure>


<p>もちろん、複数のcURLコマンドをコピーしてSenseにペースとすると、Senseはそれらをパースしてくれます。</p>

<h2>まとめ</h2>

<p>Sense 2.0.0のベータリリースです。
実際に多くの作業が終わった認識です。すぐにGAが出るでしょう。</p>

<p>Sense 2.0を知り、試していただくために、新しい<a href="https://www.elastic.co/guide/en/sense/current/index.html">ドキュメント</a>を参考にしてください。
バグやリクエストがある場合は、<a href="https://discuss.elastic.co/c/ecosystem">フォーラム</a>や<a href="https://github.com/elastic/sense/issues">GitHubのIssue</a>に登録をお願いします。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Shield、Watcher、Marvel 2.0.0 GAリリース（日本語訳）]]></title>
    <link href="http://blog.johtani.info/blog/2015/10/30/shield-watcher-and-marvel-2-0-ga-released-ja/"/>
    <updated>2015-10-30T16:21:31+09:00</updated>
    <id>http://blog.johtani.info/blog/2015/10/30/shield-watcher-and-marvel-2-0-ga-released-ja</id>
    <content type="html"><![CDATA[<p><strong>※この記事は次のブログを翻訳したものになります。</strong></p>

<p>原文：<a href="https://www.elastic.co/blog/shield-watcher-and-marvel-2-0-ga-released">Shield, Watcher, and Marvel 2.0.0 GA Released</a></p>

<!-- more -->


<p>本日（10/28）Shield、WatcherおよびMarvel 2.0をリリースしました。
これが、<a href="https://www.elastic.co/blog/elasticsearch-2-0-0-released">Elasticsearch 2.0</a>に対応したこれらのプラグインの最初のリリースです。</p>

<p>Elasticsearch 2.0対応のほかに、ShieldとWatcher 2.0は、
セキュリティとアラートを拡張するいくつかの新しい素敵な機能も備えています。</p>

<h2>Shield</h2>

<ul>
<li><p>拡張可能なレルム - Sheild 1.xはユーザ認証のコア的なものを定義するのにフォーカスし
3つの認証メカニズム（<em>esusers</em>、LDAP/AD、PKI）を提供しました。
これらを提供することで、多くのユーザおよびユースケースをカバー出来ましたが、
追加の認証メカニズムを統合する必要があることもわかっていました。
ということで、Shieldのレルムベースの認証システムをユーザが利用、拡張できるようにオープンにし、
ユーザ認証を扱うためのレルム実装をプラグインとして拡張できるようにしました。
特定もしくはプロプライエタリな認証メカニズムが必要なユーザもShieldの強力な
セキュリティ機能（ロールベースの認証、セキュアな通信など）をフルに活用できるようになりました。
カスタムレルムの詳細については、<a href="https://www.elastic.co/guide/en/shield/current/custom-realms.html">こちら</a>をご覧ください。</p></li>
<li><p>フィールドとドキュメントのACL - Shield 2.0はフィールドとドキュメントレベルのアクセス制御機能を提供します。
これは、ロールごとにアクセス可能なフィールドやドキュメントを定義できます。
この新しい機能は、設定の変更するよりも便利です。
このアクセス制御はElasticsearchのLuceneインデックスという最も低レベルで実装されています。
その結果として、このメンテナンスがより簡単であるだけでなく、より良くなっています。
詳細については<a href="https://www.elastic.co/guide/en/shield/current/setting-up-field-and-document-level-security.html">こちら</a>をご覧ください。</p></li>
<li><p>ユーザなりすまし - Shield 2.0で、ユーザなりすましの機能が実装されました。
これは、ユーザ（適切なパーミッションを持った）が、他のユーザになることができ、
それらのユーザのためにリクエストを実行できます。
これは、Elasticsearch上に構築されたアプリケーションがすでにユーザ認証を行いますが、
認可はElasticsearchサイドで行う必要があるような場合に有用です。
このシナリオで、アプリケーションの&#8221;main&#8221;ユーザを設定でき、正しくなりすましを割り当て、
ElasticsearchにアプリケーションユーザとしてリクエストをElasticsearchに実行させることができます。
詳細については、<a href="https://www.elastic.co/guide/en/shield/current/submitting-requests-for-other-users.html">こちら</a>をご覧ください。</p></li>
</ul>


<h2>Watcher</h2>

<ul>
<li><p>SlackとHipChatインテグレーション - SlackとHipChatはチーム/グループコラボレーションツールです。
これらは、急速に主流になり、組織の主な内部コミュニケーションハブとなっています。
Watcher 2.0はチャンネル/ルームやユーザにこれらのコミュニケーションチャネル経由で、Watchの通知を行うことができるアクションを
実装しました。
<a href="https://www.elastic.co/guide/en/watcher/current/configuring-slack.html">slack</a>や<a href="https://www.elastic.co/guide/en/watcher/current/configuring-hipchat.html">hipchat</a>アクションについてはドキュメントをご覧ください。</p></li>
<li><p>Array Compare Condition - 新しいconditionはタイムシリーズのデータのスパイクを検知するのを簡単にします。
<a href="https://www.elastic.co/guide/en/watcher/current/condition.html#condition-compare">compare</a> conditionは1.xで導入されましたが、このコンディションはElasticsearchのダイナミックスクリプト機能を有効にする必要がアンク使えます。
詳細については<a href="https://www.elastic.co/guide/en/watcher/current/condition.html#condition-array-compare">array_compare</a> conditionをご覧ください。</p></li>
<li><p>Watchの有効・無効化 - ユーザからの多かったリクエストとして、Watchの無効化がありました。
1.xには、登録済みのWatchを無効にする機能がありませんでした。
これは、Watchを消すか、Watchのトリガーを変更することで回避していました。
これは、全体としてはWatchを管理するのを難しくする回避方法でしかありません。
2.0では、APIを呼び出すだけで、Watchの変更をすることなく、簡単にWatchの有効化・無効化が可能になりました。
これは1.0からあるべき基本的な機能でしたが、ついにこの問題を解決しました。
詳細は<a href="https://www.elastic.co/guide/en/watcher/current/watch-active-state.html#watch-active-state">こちら</a>をご覧ください。</p></li>
</ul>


<h2>Marvel</h2>

<p>Marvel 2.0を紹介するのに興奮しています。
Kibana 4をベースとした、再設計されたUIを持っています。
Marvel 1.xで学んだ多くのことを導入し、より使いやすく監視しやすいUIになっています。
ShieldとWatcherと同様に、最初のMarvelのリリースは将来的な成長の基盤となり
Elasticsearch2.0を効率的に管理するための主要なメトリックにフォーカスしています。</p>

<p>画像あり。
<a href="https://www.elastic.co/blog/shield-watcher-and-marvel-2-0-ga-released">※画像に関しては原文をご覧ください。</a></p>

<p>再設計により、インタフェースを6ページに減らしています。</p>

<h3>Cluster list</h3>

<p>画像あり。
<a href="https://www.elastic.co/blog/shield-watcher-and-marvel-2-0-ga-released">※画像に関しては原文をご覧ください。</a></p>

<p>ユーザやカスタマーの多くは複数のクラスタを利用しています。
新しいMarvelはそれらを集中的にモニタリングする一つのクラスタからそれらを簡単に監視できます。
各クラスタのデータ送信先をこのモニタリングクラスタにするだけです。</p>

<h3>Cluster Overview</h3>

<p>画像あり。
<a href="https://www.elastic.co/blog/shield-watcher-and-marvel-2-0-ga-released">※画像に関しては原文をご覧ください。</a></p>

<p>クラスタオーバービューはある一つのクラスタの主要な性能メトリックを見ることができ、
素早くスパイクを発見できます。
このページはまた、アクティブなシャードのリカバリやリロケーションも見ることができます。</p>

<h3>Indices List</h3>

<p>画像あり。
<a href="https://www.elastic.co/blog/shield-watcher-and-marvel-2-0-ga-released">※画像に関しては原文をご覧ください。</a></p>

<p>インデックスのリストにはクラスタにあるすべてのインデックスとその属性が表示されます。
テーブルはライブでアップデートされ、フィルタリングやソートも可能です。
一番大きなインデックスは？といったことも調べられます。</p>

<h3>Index Detail</h3>

<p>画像あり。
<a href="https://www.elastic.co/blog/shield-watcher-and-marvel-2-0-ga-released">※画像に関しては原文をご覧ください。</a></p>

<p>インデックス詳細ページはインデックスの主な性能メトリックを見ることができ、シャードの配置についても表示します。</p>

<h3>Nodes List</h3>

<p>画像あり。
<a href="https://www.elastic.co/blog/shield-watcher-and-marvel-2-0-ga-released">※画像に関しては原文をご覧ください。</a></p>

<p>ノードリストはクラスタにあるノードとその主な性能メトリックを見ることができます。
テーブルはライブでアップデートされ、フィルタリングも可能です。
高いCPU利用率やディスクの残り容量なども簡単にわかるようになっています。</p>

<h3>Node Detail</h3>

<p>画像あり。
<a href="https://www.elastic.co/blog/shield-watcher-and-marvel-2-0-ga-released">※画像に関しては原文をご覧ください。</a></p>

<p>ノード詳細ページは個別のノードに関する主な性能メトリックを見ることができ、ノードにあるシャードのリストも見ることができます。</p>

<p>新しいMarvelはKibana 4の上に構築されたので、管理方法が変わっています。
Marvelのインストールは2つのステップがあります。
marvel-agentとmarvel user interfaceです。</p>

<h2>Marvel Agent</h2>

<p>marvel-agentはElasticsearchクラスタにプラグインとしてインストールします。
主なパフォーマンス情報を取得し、ローカルもしくは分離されたモニタリングクラスタにデータを保存・送信します。</p>

<h2>Marvel User Interface</h2>

<p>Marvel UIはKibanaのプラグインとしてインストールします。
これは、Kibana 4.2の新しいプラグインインフラを利用し、
Marvel Appとして、Kibanaのインタフェースとは個別に提供されます。
Kibanaのアプリの切り替えは次の画像の通りです。</p>

<p>画像あり。
<a href="https://www.elastic.co/blog/shield-watcher-and-marvel-2-0-ga-released">※画像に関しては原文をご覧ください。</a></p>

<p>2.0リリースは私たちのプロダクトの大きな一歩です。またユーザの意見を常にお待ちしています。
ぜひ、Webフォーラム（<a href="https://discuss.elastic.co%EF%BC%89%E3%82%84%E3%83%A1%E3%83%BC%E3%83%AB%EF%BC%88info@elastic.co%EF%BC%89%E3%81%A7%E3%81%94%E6%84%8F%E8%A6%8B%E3%82%92%E3%80%82">https://discuss.elastic.co%EF%BC%89%E3%82%84%E3%83%A1%E3%83%BC%E3%83%AB%EF%BC%88info@elastic.co%EF%BC%89%E3%81%A7%E3%81%94%E6%84%8F%E8%A6%8B%E3%82%92%E3%80%82</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Elasticsearch 2.0.0リリース(日本語訳)]]></title>
    <link href="http://blog.johtani.info/blog/2015/10/29/elasticsearch-2-0-0-released-ja/"/>
    <updated>2015-10-29T16:20:43+09:00</updated>
    <id>http://blog.johtani.info/blog/2015/10/29/elasticsearch-2-0-0-released-ja</id>
    <content type="html"><![CDATA[<p><strong>※この記事は次のブログを翻訳したものになります。</strong></p>

<p>原文：<a href="https://www.elastic.co/blog/elasticsearch-2-0-0-released">Elasticsearch 2.0.0 GA released</a></p>

<!-- more -->


<p>Elasticsearch 1.0.0のリリース以降、
477のコミッター2,799のpull requestがあった、
<strong>Elasticsearch 2.0.0 GA（Lucene 5.2.1ベース）</strong>をリリースしました。</p>

<p>それだけでなく、<a href="#shield-watcher">Shield（セキュリティプラグイン）とWatcher（アラーティングプラグイン）</a>、
新しくなった<a href="#marvel">Marvel（モニタリングプラグイン）</a>（プロダクション環境でフリー！）、
また、新しくオープンソースとなった<a href="#sense">Sense editor</a>の2.0.0もリリースしました。</p>

<p><a href="https://www.elastic.co/downloads/past-releases/elasticsearch-2-0-0">Elasticsearch 2.0.0</a>のダウンロードはこちらから。
また、<a href="https://www.elastic.co/guide/en/elasticsearch/reference/2.0/breaking-changes-2.0.html">2.0.0での重要な変更点についてはこちら</a>をご覧ください。
全ての変更点については、次をご覧ください。</p>

<ul>
<li><a href="https://www.elastic.co/downloads/past-releases/elasticsearch-2-0-0">Changes list for Elasticsearch 2.0.0</a></li>
<li><a href="https://www.elastic.co/downloads/past-releases/elasticsearch-2-0-0-rc1">Changes list for Elasticsearch 2.0.0-rc1</a></li>
<li><a href="https://www.elastic.co/downloads/past-releases/elasticsearch-2-0-0-beta2">Changes list for Elasticsearch 2.0.0-beta2</a></li>
<li><a href="https://www.elastic.co/downloads/past-releases/elasticsearch-2-0-0-beta1">Changes list for Elasticsearch 2.0.0-beta1</a></li>
</ul>


<p>商用プラグインについてはこちらです。</p>

<ul>
<li><a href="https://www.elastic.co/guide/en/shield/2.0.0/release-notes.html#_2_0_0">Shield 2.0.0 change logs</a></li>
<li><a href="https://www.elastic.co/guide/en/watcher/2.0.0/release-notes.html#_2_0_0">Watcher 2.0.0 change logs</a></li>
</ul>


<h2>Elasticsearchの新機能</h2>

<p>Elasticsearch 2.0.0には素晴らしい新機能があります。</p>

<h4>Pipeline Aggregations</h4>

<p>Aggregationsで導関数や移動平均のような他のAggregationの結果に対する計算が可能となります。
この機能はクライアントサイドで実装しなければなりませんでしたが、
Elasticsearchに計算させることで、より強力な解析のクエリを簡単に組み立て、クライアントのコードを簡略化できます。
これは、予測解析や予測解析や例外検知といった可能性をもたらします。
Pipeline Aggregationについては次をご覧ください。</p>

<ul>
<li><a href="https://www.elastic.co/blog/out-of-this-world-aggregations">Out of this world aggregations.</a></li>
<li><a href="https://www.elastic.co/blog/staying-in-control-with-moving-averages-part-1">Staying in Control with Moving Averages - Part 1.</a></li>
<li><a href="https://www.elastic.co/blog/staying-in-control-with-moving-averages-part-2">Staying in Control with Moving Averages - Part 2.</a></li>
</ul>


<h4>Query/Filter merging</h4>

<p>フィルタはもうありません。
全てのフィルタ条件はクエリとなりました。
クエリコンテキストで使用した場合、関連度のスコアに影響し、フィルタコンテキストで使用した場合、
これまでのフィルタのように、ヒットしなかったドキュメントを除外するだけとなります。
この変更はクエリの実行時に自動的に最も効率的な順序で実行するように最適化されることを意味します。
例えば、遅いクエリ（フレーズやgeo）の最初の実行は速い近似フェーズで実行され、
それから、遅い正確なフェーズで結果を修正します。
フィルタコンテキストでは、直近でよく使われた条件が自動的にキャッシュされます。
詳細については、&#8221;<a href="https://www.elastic.co/blog/better-query-execution-coming-elasticsearch-2-0">Better query execution coming to Elasticsearch 2.0</a>&ldquo;をご覧ください。</p>

<h4>設定可能な圧縮率</h4>

<p><code>_source</code>のようなStored fieldsは高速なLZ4（デフォルト）で圧縮するか、インデックスサイズを小さくできるDEFLATE
で圧縮できます。
これは、特にロギングのケースで便利です。
古いインデックスをオプティマイズする前に<code>best_compression</code>に変更することができます。
詳細については&#8221;<a href="https://www.elastic.co/blog/store-compression-in-lucene-and-elasticsearch">Store compression in Lucene and Elasticsearch</a>&ldquo;をご覧ください。</p>

<h4>堅牢に</h4>

<p>新しいElasticsearchはJava Security Managerの元で実行されます。
これは、セキュリティの観点で大きな前進です。
Seciruty ManagerはElastcsearchにより制限をかけ、ハッカーによりシステムに対して何でもできるようなものを制限します。
Elasticsearchはまた、インデキシングの観点でも堅牢になっています。</p>

<ul>
<li>ドキュメントはインデキシングリクエストに答える前に、耐久性のためにディスクに<code>fsync</code>されます。</li>
<li>すべてのファイルはチェックサムにより、早期に障害を検知します。</li>
<li>すべてのファイルはどんなファイルへの書き込みもアトミックです</li>
</ul>


<p>最後に、システム管理者から要請の多かった変更として、
設定されて居ないノードがパブリックなネットワークから参加しないようになりました。
Elasticsearchは<a href="https://manage.contentstack.io/blog/elasticsearch-unplugged">デフォルトではローカルホストのみにバインド</a>します。マルチキャストは無くなりました。（プラグインとして残っています。）</p>

<h4>パフォーマンスと信頼性</h4>

<p>上記以外にも細かな修正がElasticsearchとLuceneにはあります。
より安定し、信頼性をあげ、簡単に設定できるようにするものです。例えば、次のようなものです。</p>

<ul>
<li>ヒープの使用率の低減（doc valuesがデフォルト、マージ時のメモリ使用率の削減、
roaring bitsetsによるフィルタキャッシュ）</li>
<li>構造化され読みやすくなった例外</li>
<li>設定の代わりに、フィードバックループを使用した自動調整</li>
<li>安全で明確で信頼性のあるタイプマッピングの大きな修正</li>
<li>クラスタ状態の差分変更による伝搬の高速化および、大きなクラスタでのより安定的に</li>
<li>normsの圧縮の改善。これまではヒープスペースを大きく利用していた。</li>
<li>マージの自動的な調整（不可解な設定の微調整が必要ない）</li>
<li>より詳細なLuceneのメモリリポート</li>
<li>最適化されたクエリ実行を活用するためにParent/childを書き換え</li>
</ul>


<h4>コアプラグイン</h4>

<p>公式にサポートされたコアプラグインはElasticsearchと同じバージョン番号で同じタイミングでリリースされます。
インストールするプラグインとElasticsearchの複雑なバージョンの対応表に悩まされる必要はもうありません。
コアプラグインのインストールは次のように簡略化されています。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>bin/plugin install analysis-icu</span></code></pre></td></tr></table></div></figure>


<h2><a name="shield-watcher">ShieldとWatcherの新機能</a></h2>

<p>商用プラグインも新しい機能をリリースしました。</p>

<h4>Shield</h4>

<ul>
<li>フィールドおよびドキュメントレベルのアクセス制御</li>
<li>ユーザのなりすまし</li>
<li>カスタム拡張可能な認証レルム</li>
</ul>


<h4>Watcher</h4>

<ul>
<li>個別のWatchを有効/無効に</li>
<li>SlackやHipChatへの通知</li>
</ul>


<p>これらの詳細については“<a href="https://www.elastic.co/blog/shield-watcher-and-marvel-2-0-ga-released">Shield, Watcher, and Marvel 2.0.0 GA Released</a>”をご覧ください。</p>

<p>コアプラグイン同様、商用プラグインもElasticsearchのバージョンと同じものが同時にリリースされます。
インストールは次の通りです。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>bin/plugin install license
</span><span class='line'>bin/plugin install shield
</span><span class='line'>bin/plugin install watcher</span></code></pre></td></tr></table></div></figure>


<h2><a name="marvel">Marvel 2.0.0はプロダクションでの利用もフリーに</a></h2>

<p>Marvelモニタリングプラグインはカスタマに非常に価値のあるもので、
ユーザの発展とともに問題を診断したり見つけたりするのに役に立ってきました。
私たちは、何を改善でき、Mαrvelを一から書き直すことで、いろいろとわかったことがあります。</p>

<ul>
<li>Marvel UIを新しい<a href="https://www.elastic.co/blog/kibana-4-2-0">Kibanaプラットフォーム</a>上に構築</li>
<li>ダッシュボードにはより簡単に問題を発見するために、最も重要なメトリックを可視化</li>
<li>1つのインストールで、複数のクラスタのモニタリングをサポート（商用サポート対象）</li>
</ul>


<p>一番良い点はMarvelがすべてのElasticsearchユーザに対してプロダクション環境でフリーになったことです！
ライセンスが必要ですが、課金の必要はありません。
もし、マルチクラスタモニタリングサポートが必要な場合、それは商用サポート対象となります。</p>

<p>詳細に関しては“<a href="https://www.elastic.co/blog/shield-watcher-and-marvel-2-0-ga-released">Shield, Watcher, and Marvel 2.0.0 GA Released</a>”をご覧ください。</p>

<h2><a name="sense">Sense editorがオープンソースに</a></h2>

<p>Sense（ブラウザベースのElasticsearchリクエストとDSL向けのエディタ）を
<a href="https://www.elastic.co/blog/kibana-4-2-0">Kibanaプラットフォーム</a>のアプリとして、オープンソースにしました。
また、このリリースで新しい機能が追加されています。</p>

<ul>
<li>複数のcURLリクエストをペースとすると、Sense表記に変更</li>
<li>複数のSenseリクエストをcURL表記にしてコピー</li>
<li>複数のリクエストを一度に実行可能</li>
<li>Elasticsearch 2.0サポートとなった自動補完機能</li>
</ul>


<p>SenseはKibanaのアプリとして次のようにインストールします。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>./bin/kibana plugin --install elastic/sense</span></code></pre></td></tr></table></div></figure>


<p>Senseの詳細については、&#8221;<a href="https://www.elastic.co/blog/sense-2-0-0-beta1">The Story of Sense - Announcing Sense 2.0.0-beta1</a>&ldquo;をご覧ください。</p>

<h2>Elasticsearch Migration Plugin</h2>

<p>Elasticsearch Migration PluginはElasticsearch 1.xから2.0にアップグレードする時の良い出発点となります。
1.xのElasticsearchクラスタにサイトプラグインとしてインストールすると、
アップグレードする前に解決すべき問題があるかどうかを検知してくれます。
（例えば、Lucene 3のような古いインデックスや、2.0.0にした場合に動作しない問題のある
マッピング（<a href="https://www.elastic.co/blog/great-mapping-refactoring">The Great Mapping Refactoring</a>）のような問題）</p>

<p>プラグインに関して<a href="http://github.com/elastic/elasticsearch-migration">Elasticsearch Migration repository</a>をご覧ください。</p>

<h2>まとめ</h2>

<p>ぜひ、<a href="https://www.elastic.co/downloads/past-releases/elasticsearch-2-0-0">Elasticsearch 2.0.0</a>をダウンロードして、試してみてください。
そして、感想をTwitter(<a href="https://twitter.com/elastic">@elastic</a>)や<a href="https://discuss.elastic.co/c/elasticsearch">Webフォーラム</a>などで教えて下さい。
また、問題がありましたら、<a href="https://github.com/elastic/elasticsearch/issues">GitHub issues page</a>で報告をお願いします。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Kibana 4.2.0リリース（日本語訳）]]></title>
    <link href="http://blog.johtani.info/blog/2015/10/29/kibana-4-2-0-ja/"/>
    <updated>2015-10-29T16:20:19+09:00</updated>
    <id>http://blog.johtani.info/blog/2015/10/29/kibana-4-2-0-ja</id>
    <content type="html"><![CDATA[<p><strong>※この記事は次のブログを翻訳したものになります。</strong></p>

<p>原文：<a href="https://www.elastic.co/blog/kibana-4-2-0">Kibana 4.2.0 released</a></p>

<!-- more -->


<p>Elasticsearch 2.0 + Kibana 4.2 = 💚
Elasticsearch 2.0サポートのKibanaの最初のリリースです。
これが何を意味するでしょう？
速さ、安定さ、新しい機能。
試してみたい方は、<a href="https://www.elastic.co/downloads/kibana">いますぐダウンロード</a>してください。
そうでない方は、Kibana 4.2の楽しい機能について読んでみてください。</p>

<h3>暗黒面は怖い？</h3>

<p>そんなことありません。
私たちは常にチャートチャートとダッシュボードを組み立てている組み立てている間は明るいバックグラウンドを使うことを推奨してきましたが、
時々、巨大なスクリーンで暗い部屋で誰も明るい画面から目を背けないようにしたいでしょう。
その影響を小さくするためにダークモードを導入しました。
あなたは、NOCや天文台、その他の暗い場所でKibanaのダッシュボードを楽しむことができます。</p>

<p>画像あり。
<a href="https://www.elastic.co/blog/kibana-4-2-0">※画像に関しては原文をご覧ください。</a></p>

<h3>地図のカスタマイズ</h3>

<p>Kibanaの地図は素晴らしいですが、もっと多くのオプションが望まれていると聞きました。
もし地図に関して知識があるなら、Kibana 4.2のWMSバックグラウンド地図サポートを試してみてください。
WMSは非常に強力で、US Geological Surveyを含む多くの無料サービスがあります。
<a href="http://viewer.nationalmap.gov/example/services/serviceList.html">http://viewer.nationalmap.gov/example/services/serviceList.html</a></p>

<p>画像あり。
<a href="https://www.elastic.co/blog/kibana-4-2-0">※画像に関しては原文をご覧ください。</a></p>

<h3>シナリオは？</h3>

<p>何かおかしい時、何が起こっているかを正しく知ってもらいたいので、Kibanaがそのタイミングで注目したいコンポーネントがあるなら、
どのように動いているかという概要を知るためのサーバステータスページを作りました。
もちろん、全てがOKであるというのを知りたいだけの場合でも、settingメニューのStatusタブからいつでも呼び出せます。</p>

<p>画像あり。
<a href="https://www.elastic.co/blog/kibana-4-2-0">※画像に関しては原文をご覧ください。</a></p>

<h3>全てにおいて速く</h3>

<p>ブラウザリフレッシュはKibana 4.2の新しいコードビルディングシステムのおかげで、さらに早くなりました。
また、メモリを覚えてます？<strike>Pepperidge Farm</strike>Kibanaが覚えています。
Kibana 4.2は小さな小さな小さなメモリフットプリントを管理している間、長い長い長い時間実行されているダッシュボードを見ることができるような
大きなメモリのクリーンアップも含んでいます。</p>

<h3>もっとありますが。。。</h3>

<p>小さな微調整がいくつもあります。また、今後紹介する本当に刺激的なものの基礎を気づき上げてきました。
これからも<a href="http://elastic.co/blog">Elasticのブログ</a>、<a href="https://twitter.com/elastic">Twitter</a>、<a href="https://github.com/elastic/kibana">KibanaのGitHubリポジトリ</a>に注目し、<strike>モンスタートラック</strike><strong>アナリティクス</strong>の瞬間に立ち会ってください。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Logstash 2.0.0リリース（日本語訳）]]></title>
    <link href="http://blog.johtani.info/blog/2015/10/29/logstash-2-0-0-released-ja/"/>
    <updated>2015-10-29T16:19:57+09:00</updated>
    <id>http://blog.johtani.info/blog/2015/10/29/logstash-2-0-0-released-ja</id>
    <content type="html"><![CDATA[<p><strong>※この記事は次のブログを翻訳したものになります。</strong></p>

<p>原文：<a href="https://www.elastic.co/blog/logstash-2-0-0-released">Logstash 2.0.0 released</a></p>

<!-- more -->


<p>Logstash 2.0.0が本日（10/28）リリースされました。
この<a href="https://www.elastic.co/downloads/logstash">リリース</a>は
いくつかの設定に関する重要な変更があります。
詳細については、<a href="https://github.com/elastic/logstash/blob/2.0/CHANGELOG.md">changelog</a>または、新しい<a href="https://www.elastic.co/guide/en/logstash/2.0/breaking-changes.html">breaking changes</a>ドキュメントをご覧下さい。</p>

<p>これまでの2.0.0直前のリリースに関する変更点はこちらをご覧ください。</p>

<ul>
<li><a href="https://www.elastic.co/blog/logstash-2-0-0-beta1-released">beta1</a></li>
<li><a href="https://www.elastic.co/blog/logstash-2-0-0-beta2-released">beta2</a></li>
<li><a href="https://www.elastic.co/blog/logstash-2-0-0-beta3-released">beta3</a></li>
<li><a href="https://www.elastic.co/blog/logstash-2-0-0-rc1-released">RC</a></li>
</ul>


<p>ここでは、2.0の主な変更点の概要を説明します。</p>

<h3>Elasticsearch 2.0との互換性</h3>

<p>多くの機能および改善を含んだ<a href="https://www.elastic.co/blog/elasticsearch-2-0-0-released">Elasticsearch 2.0がリリース</a>されました。
Logstash 2.0はこのリリースに対応しています。
Logstashのこれまでのリリースでは、デフォルトで、Javaの <code>node client</code>をElasticsearchとの通信として
使用してきました。
2.0では、HTTPクライアントがデフォルトになります。
これにより、シームレスにユーザのデータを取り込み、付加価値をつけ、Elasticsearchに保存して解析することができます。</p>

<p>HTTPは他のプロトコル（<code>node</code>や<code>transport</code>）同等の機能を持っていますが、
単一のクライアントに接続する時に、少しだけ遅いですが、管理や動作がより簡単です。
HTTPプロトコルを使うことで、Elasticsearchのバージョンのアップグレードが、Logstashのアップグレードすることなく
行うことができます。
デフォルトをHTTPに変更したさらに詳しい情報については<a href="https://www.elastic.co/blog/logstash-2-0-0-beta1-released">beta1のブログ</a>をご覧ください。</p>

<p>他のプロトコル（<code>node</code>と<code>transport</code>）もサポートしますが、これらを利用する場合には、
プラグインを別途インストールする必要があります。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>bin/plugin install --version 2.0.0 logstash-output-elasticsearch_java</span></code></pre></td></tr></table></div></figure>


<h4>互換性のマトリックス</h4>

<p>LogstashとElasticsearchのバージョンの互換性は次のようになります。</p>

<p>画像あり。
<a href="https://www.elastic.co/blog/kibana-4-2-0">※画像に関しては原文をご覧ください。</a></p>

<h1>Image <a href="https://www.elastic.co/assets/bltde5b69e2164aa82f%2Fcompat_matrix.png">https://www.elastic.co/assets/bltde5b69e2164aa82f%2Fcompat_matrix.png</a></h1>

<h2>Shield 2.0との互換性</h2>

<p>このリリースはShield 2.0リリースにも対応しています。
HTTPプロトコルで、追加のプラグインは必要ありません。
<a href="https://www.elastic.co/guide/en/shield/current/logstash.html">こちらのドキュメント</a>をご覧ください。
<code>transport</code>プロトコルでは、Shield 2.0対応のプラグインを個別にインストールする必要があります。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>bin/plugin install --version 2.0.0 logstash-output-elasticsearch_java_shield</span></code></pre></td></tr></table></div></figure>


<h2>パフォーマンスの改善</h2>

<p>このリリースはまた、多くの部分のパフォーマンスの改善を含んでおり、Logstashを利用してデータをより早く処理することができます。
いくつかをここで説明します。</p>

<ul>
<li><p><strong>UserAgentとGeoIPフィルタ</strong>：これらのフィルタで、LRUキャッシュを追加して改善しています。
これにより、IPとユーザエージェントがまとまって現れるというWebリクエストの特性を用いています。
ユーザエージェントフィルタのケースでは、サンプルデータセットにおいて3.7倍ほど早くなりました。
GeoIPでは、1.69倍早くなっています。</p></li>
<li><p><strong>JSONプロセシング</strong>：LogstashでJSONのsiriaraizu/でシリアライズに利用しているJrJacksonを新しいバージョンにしました。
これにより、JSONの処理が改善されています。</p></li>
<li><p><strong>フィルタワーカーのより良い値をデフォルトに</strong>：以前のリリースでは、<code>filter_workers</code>の設定は1がデフォルトでした。
これは、フィルタの処理を行うワーカーが1つであるという意味です。
<code>filter_workers</code>の設定のデフォルト値はCPUコア数の半分の値を設定します。フィルタ実行の並列性が上がります。
ですので、複雑なgrokパターンやuseragentフィルタの処理がにとっては重要です。</p></li>
</ul>


<h2>Filebeat Support</h2>

<p><a href="https://www.elastic.co/products/beats/filebeat">Filebeat</a>のベータバージョンを<a href="https://www.elastic.co/blog/beats-beta4-filebeat-lightweight-log-forwarding">先日リリース</a>しました。
これは、Logstash Forwarderの次期バージョンです。
Filebeatはファイルベースのログをさらに処理するためにLogstashに送るためのエージェントです。
2.0.0は<a href="https://www.elastic.co/guide/en/logstash/2.0/plugins-inputs-beats.html">logstash-input-beatsプラグイン</a>を使えばFilebeat 1.0.0-beta4とすぐに動作します。</p>

<h2>シャットダウン操作</h2>

<p>これまでのLogstashでは、シャットダウンが開始した時に、例外の機構でシャットダウンが開始したことを
プラグインに通知していました。
この処理はサードパーティのコードを使ったプラグインで問題を起こしていました。
Logstashはどの例外を処理するか知らないため、予期しない動作をしていました。
これを修正するためにAPI呼び出し（例えば<code>stop</code>）を各プラグインにシャットダウンのイベントを通知し、
プラグイン自身がきちんと停止するようにしました。
これは、200以上のプラグインに新しいAPIを利用するように修正しないといけないことを意味しました。
しかし、Logstashの停止についてはまだ完全にはフィックスしていません。
とちゅうでおわっているoutputがシャットダウンを遅らせる可能性があるからです。
2.0でAPIの破壊的な変更は適切なリリースでの変更を繰り返すことができる出発点です。</p>

<p>プラグインの開発者へ：もし、Logstash　1.5のプラグインを開発しているなら、
シャットダウンに関する新しいAPIのリストに関するbreaking changesのドキュメントに助言をください。
また、<a href="https://github.com/logstash-plugins/logstash-input-example">example input</a>リポジトリにて、新しいシャットダウンメカニズムの使い方のサンプルコードを提供しています。</p>

<h2>ドキュメント</h2>

<p>2.0に更新された<a href="https://www.elastic.co/guide/en/logstash/2.0/index.html">ドキュメントはこちら</a>です。設定の変更についてもこちらをご覧ください。</p>

<h3>2.0へのアップデート</h3>

<p>2.0へアップデートする前に、<a href="https://www.elastic.co/guide/en/logstash/2.0/upgrading-logstash.html">アップデートガイド</a>もご覧ください。</p>

<h2>フィードバック</h2>

<p>2.0のリリースできたことに、多くのコントリビューター、ユーザに感謝しています。
このリリースに含まれている多くのパッチと全てのプレリリースのテストにも感謝しています。
将来の修正やリリースなどについては<a href="https://www.elastic.co/guide/en/logstash-roadmap/current/index.html">ロードマップ</a>をご覧ください。
2.0は<a href="https://www.elastic.co/downloads/logstash">今日リリース</a>されました。
ご意見ご感想は<a href="https://discuss.elastic.co/c/logstash">Webフォーラム</a>で！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Release, we have（日本語訳）]]></title>
    <link href="http://blog.johtani.info/blog/2015/10/29/release-we-have-ja/"/>
    <updated>2015-10-29T14:18:59+09:00</updated>
    <id>http://blog.johtani.info/blog/2015/10/29/release-we-have-ja</id>
    <content type="html"><![CDATA[<p><strong>※この記事は次のブログを翻訳したものになります。</strong></p>

<p>原文：<a href="https://www.elastic.co/blog/release-we-have">Relase, we have</a>
※画像に関しては原文をご覧ください。</p>

<!-- more -->


<p>Elasticにとって大きな1日（社内では「release bonanza」と呼んでいる）です。
多くの主要なプロダクトを新たにリリースしました。
そして、本日、それらを一緒に利用する時にそれらを一緒に利用する時にユーザの体験についてまとめてみました。</p>

<p>次の通りです。</p>

<p><a href="https://www.elastic.co/blog/elasticsearch-2-0-0-released">Elasticsearch 2.0</a>リリース。
大きなマイルストーン、チームによる改善、そして、コミュニティからの素晴らしい貢献。
Pipeline Aggsと呼ばれる新しいタイプのaggregations、
クエリとフィルタのコンセプトを統合することにより簡素化されたクエリDSL、
better compressionオプション、
JavaのSecurity Managerを有効にすることによる強化されたセキュリティ、
FSの挙動に関する強化（fsync、checksum、atmicなリネーム）、
パフォーマンス、マッピングの挙動の一貫性などなどです。
また、我々のチームによる改善も含まれているLucene 5ベースにアップグレードしています。</p>

<p><a href="https://www.elastic.co/blog/kibana-4-2-0">Kibana 4.2</a>リリース。
Elasticsearch 2.0対応、ダークテーマ、カスタマイズ可能な地図、多くの改善。
Kibana 4.2の多くに作業については外部プラグインサポートといった、内蔵に関するものでした。
この後の説明に続きます。</p>

<p><a href="https://www.elastic.co/blog/shield-watcher-and-marvel-2-0-ga-released">Marvel 2.0</a>リリース。
Elasticsearch 2.0対応、合理化されたメトリックス、簡素化されたUI、
多くはKibanaプラグイン（Kibanaプラットフォーム上に構築）としての書き換えです。
このKibana拡張の最初の努力は、Kibanaのプラグインをどうやって書くか、
Kibanaユーザに公式に何をする必要があるかといったものを特定するのに役立ちました。
おっと、忘れるところでした、Marvelを全てのユーザにフリーで使えるようにしました。
マルチクラスタサポートについては有償となります。</p>

<p><a href="https://www.elastic.co/blog/sense-2-0-0-beta1">Sense 2.0</a>リリース。
2つ目のKibanaプラグインがこれです。
SenseをKibanaプラグインとして書き換えました。
Elasticsearch 2.0サポート、複数リクエストの実行、
curlへのコピーなどです。
おっと、忘れるところでした。オープンソースとすることにしました！</p>

<p><a href="https://www.elastic.co/blog/shield-watcher-and-marvel-2-0-ga-released">Shield + Watcher 2.0</a>リリース。ElasticsearchのためのセキュリティプラグインであるShieldと、アラート管理のためのプラグインであるWatcherにも
多くの結果が入っています。
最も要求のあった機能である、フィールドお呼びドキュメントレベルでのセキュリティについて、Luceneに落とし込んで実装しました。
また、セキュリティの操作についてプラガブルに実装できるように変更しました。
Watcherは監視の無効化、SlackやHipChatへの通知（bot ops向け）が可能です。</p>

<p><a href="https://www.elastic.co/blog/logstash-2-0-0-released">Logstash 2.0</a>リリース。
Elasticsearch 2.0のサポート、クリーンな停止、全面的なパフォーマンス改善、<a href="https://www.elastic.co/products/beats">Beats</a>サポート。</p>

<p>ご覧の通り、すべてのプロダクトに関する大きな結果です。
チーム間およびFoundの開発者との間での密な連携に感謝します。
これらが私たちが公式にElasticsearch / Kibanaをホストしている<a href="https://www.elastic.co/found">Found</a>で
利用可能です。</p>

<p>ひゅう、息切れしました。
チームがしてきたことは、感動的で、謙虚で、刺激的です！
Elasticが会社として、全てのユーザ、コントリビュータがどのように私たちの大きなミッションに対する結果をもたらしたかという素晴らしい良い例です。
ユーザに愛され、楽しまれ、成功に導き、革新させる製品を是非ご利用ください。ありがとうございます。</p>

<p>&ldquo;A Lion, in Africa?&rdquo; - まだまだ終わりではありません。この文言で終わりにしますが、すぐに（本当にすぐに）戻ってきます。;)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Elasticsearch 2.0.0-beta2リリース（日本語訳）]]></title>
    <link href="http://blog.johtani.info/blog/2015/09/18/elasticsearch-2-0-0-beta2-released-ja/"/>
    <updated>2015-09-18T17:31:41+09:00</updated>
    <id>http://blog.johtani.info/blog/2015/09/18/elasticsearch-2-0-0-beta2-released-ja</id>
    <content type="html"><![CDATA[<p><strong>※この記事は次のブログを翻訳したものになります。</strong></p>

<p>原文：<a href="https://www.elastic.co/blog/elasticsearch-2-0-0-beta2-released">Elasticsearch 2.0.0-beta2 released</a></p>

<p>本日（9/17）、<strong>Lucene 5.2.1</strong>ベースの<strong>Elasticsearch 2.0.0-beta2</strong>をリリースしました。
本リリースが2.0.0のRCの前の最後のベータリリースになります。</p>

<p><strong>注意事項</strong>
本リリースはベータリリースであり、テストを目的としたものとなります。
Elasticsearch 2.0.0-beta2はElasticsearch 2.0.0-beta1と互換がありません。
また、Elasticsearch 2.0.0 GAと互換性があるかどうかの保証はありません。</p>

<p><strong>本番環境には利用しないでください。</strong></p>

<!-- more -->


<p><a href="https://www.elastic.co/downloads/past-releases/elasticsearch-2-0-0-beta2">Elasticsearch 2.0.0-beta2のダウンロードおよび、すべての変更についてはリンク</a>をごらんください。</p>

<p>2.0.0-beta1をテストし、問題点を報告していただいた皆様、ありがとうございます。
2.0.0-beta1のあとのElasticsearchのコアの部分の修正のほとんどはバグフィックスになりますが、
<a href="https://github.com/elastic/elasticsearch/pull/12893">geo_shapeフィールドの<code>points_only</code>最適化</a>のようなちょっとした改善も含んでいます。</p>

<p>また、本リリースでは、商用プラグインの重要な新機能もあります。
こちらについては<a href="https://www.elastic.co/blog/shield-and-watcher-2.0.0-beta2-released">Shield and Watcher 2.0.0-beta2 released</a>をごらんください。
簡単な紹介は次の通りです。</p>

<h3>Shieldの新機能</h3>

<h5>ドキュメントおよびフィールドレベルのセキュリティ</h5>

<p>Shieldは、クエリを利用したインデックスにあるドキュメントへのアクセスを制御するためのロールを定義できるようになりました。
また、ドキュメントにある特定のフィールドに関するアクセス制限も可能です。
フィルタされたエイリアスのような形ではなく、ドキュメントを検索したり、IDで取得したりする場合にこれらの制限が利用できます。
詳細は<a href="https://www.elastic.co/guide/en/shield/2.0.0-beta2/setting-up-field-and-document-level-security.html">Field- and Document-level Security</a>をごらんください</p>

<h5>ユーザなりすまし</h5>

<p>特定のユーザーに他のユーザーに扮して、彼らのためにリクエストを実行する能力を与えることが、現在できます。
これは、認証がアプリケーションによって実行される場合に便利です。
そして、それは、ユーザの許可レベルを考慮するようにElasticsearchにリクエストします。
詳細は<a href="https://www.elastic.co/guide/en/shield/2.0.0-beta2/submitting-requests-for-other-users.html">Submitting Requests for Other Users</a>をごらんください。</p>

<h5>プラガブルな認証レルム</h5>

<p>このリリースで、サードパーティの拡張のための認証レルムのインフラを公開しました。
もし、特定の認証要求があり、Shieldがサポートしていない（が、内部の認証管理システムを使いたいような）場合、
これらの要求に見合う新しい認証レルムを利用するプラグインを作成可能です。
詳細は<a href="https://www.elastic.co/guide/en/shield/2.0.0-beta2/custom-realms.html">Custom Realms</a>をごらんください。</p>

<h3>Watcherの新機能</h3>

<h5>監視の一時</h5>

<p>新しく、<code>active</code> / <code>inactive</code> の状態がwatchに追加されました。
これらは、Watchを中断したり、要求に応じて再開させたりできます。
詳しくは、<a href="https://www.elastic.co/guide/en/watcher/2.0.0-beta2/watch-active-state.html">Active State</a>をごらんください。</p>

<h5>チャットのための新しいアクション</h5>

<p><code>slack</code>と<code>hipchat</code>アクションが追加されました。
これは、Watcherが通知を、SlackやHipchatのユーザに直接送ったり、
チームのチャットルームに送ったりすることが出来るようにします。
詳細については、<a href="https://www.elastic.co/guide/en/watcher/2.0.0-beta2/actions.html#actions-slack">Slack action</a>および、<a href="https://www.elastic.co/guide/en/watcher/2.0.0-beta2/actions.html#actions-hipchat">Hipchat action</a>をごらんください。</p>

<h2>2.0に関するこれまでのブログ記事</h2>

<p>これまでのリリースについての情報はこれらのブログ記事をごらんください。</p>

<ul>
<li><a href="https://www.elastic.co/blog/elasticsearch-2-0-0-beta1-released">Elasticsearch 2.0.0.beta1 released</a></li>
<li><a href="https://www.elastic.co/blog/elasticsearch-2.0.0.beta1-coming-soon">Elasticsearch 2.0.0.beta1 coming soon!</a></li>
<li><a href="https://www.elastic.co/blog/great-mapping-refactoring">The Great Mapping Refactoring</a></li>
<li><a href="https://www.elastic.co/blog/store-compression-in-lucene-and-elasticsearch">Store compression in Lucene and Elasticsearch</a></li>
<li><a href="https://www.elastic.co/blog/better-query-execution-coming-elasticsearch-2-0">Better query execution coming to Elasticsearch 2.0</a></li>
<li><a href="https://www.elastic.co/blog/out-of-this-world-aggregations">Out of this world aggregations</a></li>
<li><a href="https://www.elastic.co/blog/staying-in-control-with-moving-averages-part-1">Staying in Control with Moving Averages - Part 1</a></li>
<li><a href="https://www.elastic.co/blog/staying-in-control-with-moving-averages-part-2">Staying in Control with Moving Averages - Part 2</a></li>
<li><a href="https://www.elastic.co/blog/core-delete-by-query-is-a-plugin">The Delete by Query API Is now a plugin</a></li>
<li><a href="https://www.elastic.co/blog/elasticsearch-unplugged">Elasticsearch unplugged - Networking changes in 2.0</a></li>
</ul>


<p>また、<a href="https://www.elastic.co/guide/en/elasticsearch/reference/2.0/index.html">Elasticsearch 2.0.0-beta2のドキュメント</a>や<a href="https://www.elastic.co/guide/en/elasticsearch/reference/2.0/breaking-changes-2.0.html">2.0のbreaking changesのリスト</a>もごらんください。</p>

<h2>Elsticsearch Migration Plugin</h2>

<p>Elasticsearch Migration Pluginは、既存のインデックスをアップグレードする
必要があるか、他に必要な行動がないかについて、Elasticsearch
2.0.0-beta2を試す前に確認する助けとなります。
Lucene 3のような古いインデックスや、2.0.0にした場合に動作しない問題のある
マッピングのような問題を発見できます。</p>

<p>プラグインの動作に関しては<a href="Elasticsearch%20Migration%20repository">Elasticsearch Migration repository</a>をごらんください。</p>

<h2>テストしましょう！</h2>

<p>Elasticsearch 2.0.0 GAをすぐにリリースできるようにより多くのベータテスターをお待ちしています。</p>

<p>ぜひ、<a href="https://www.elastic.co/downloads/past-releases/elasticsearch-2-0-0-beta2">Elasticsearch 2.0.0-beta2</a>をダウンロードして、試してみてください。
そして、感想をTwitter(<a href="https://twitter.com/elastic">@elastic</a>)や<a href="https://discuss.elastic.co/c/elasticsearch">Webフォーラム</a>などで教えて下さい。
また、問題がありましたら、<a href="https://github.com/elastic/elasticsearch/issues">GitHub issues page</a>で報告をお願いします。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Elasticsearch unplugged - 2.0におけるネットワークの変更(日本語訳)]]></title>
    <link href="http://blog.johtani.info/blog/2015/08/28/elasticsearch-unplugged-ja/"/>
    <updated>2015-08-28T12:01:30+09:00</updated>
    <id>http://blog.johtani.info/blog/2015/08/28/elasticsearch-unplugged-ja</id>
    <content type="html"><![CDATA[<p><strong>※この記事は次のブログを翻訳したものになります。</strong></p>

<p>原文：<a href="https://www.elastic.co/blog/elasticsearch-unplugged">Elasticsearch unplugged - Networking changes in 2.0</a></p>

<p>Elasticsearchをローカルのマシンで起動します。
そして、昨日試したデータを削除するために<code>DELETE *</code>を実行します。
すると、悲しそうな叫びを同僚が発していることに気づき、なぜそんなことになっているのか不思議に思うでしょう。。。</p>

<!-- more -->


<p>Elasticsearchはいつも、親しみやすいものでした。
複数ノードのクラスタがどのように機能するのかをテストするには、
ローカルのマシンでいくつかのElasticsearchのインスタンスを起動するだけでした。
起動したインスタンスはマルチキャストを利用して自動的にお互いを見つけて、1つのクラスタになり、負荷を共有し始めます。
しかし、これは親しみやすすぎました。
カンファレンスなどで、ローカルのマシンでElasticsearchを起動してみてください。
すると100ノードのクラスタに参加しているのがすぐにわかるでしょう。</p>

<p>もうすぐリリースされる、2.0.0-beta1では、Elasticsearchが通信先を選択するネットワークの機能に関する変更があります。
ただし、これまで通り、簡単に開発者が経験できる機能も残っています。</p>

<h2>localhostへのバインド</h2>

<p>以前、Elasticsearchはデフォルトで、利用可能なネットワークインタフェース全てにバインドしていました。
そこから、一番適したインタフェースを<code>publish_host</code>として選択しようとします。
このアドレスはElasticsearchがクラスタの他のノードとやりとりするためのアドレスです。</p>

<p>Elasticsearch 2.0では、デフォルトでは、<code>localhost</code>にのみバインドします。
<code>127.0.0.1</code>（IPv4）と<code>[::1]</code>（IPv6）の両方にバインドしようとします。
また、どちらかのみの環境でも動作します。
この変更は、特に指定がない限り、Elasticsearchがネットワーク上の他のノードと接続しません。
本番環境に移行する場合は、<code>network.host</code>パラメータを使って設定しましょう。
設定は、<code>elasticsearch.yml</code>に記述するか、コマンドラインで指定します。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>bin/elasticsearch --network.host 192.168.1.5
</span><span class='line'>bin/elasticsearch --network.host _non_loopback_</span></code></pre></td></tr></table></div></figure>


<p><code>network.host</code>の全てのオプションについては、<a href="https://www.elastic.co/guide/en/elasticsearch/reference/2.0/modules-network.html">network settingsのドキュメント</a>をごらんください。</p>

<h2>マルチキャストは廃止</h2>

<p>Elasticsearch 1.xはネットワークの他のノードに接続・探索するためにマルチキャストを使用しました。
マルチキャストは魔法のような挙動です。。。
残念ながら、マルチキャストのサポートは良くも悪くもあります。
Linuxはローカルホストでマルチキャストの待ち受けをしていません。
OS/Xは構成されたアドレスの全てのインタフェースにマルチキャストで配信できます。
また、ネットワークによってはマルチキャストはデフォルトでは使用できなくなっています。</p>

<p>Elasticsearch 2.0は異なるアプローチを採用しました。
マルチキャストを廃止します（ただし、新たにプラグインとして提供します）。
代わりに、ローカルホストでは、Elasticsearchは<code>transport.tcp.port</code>で指定されている範囲（デフォルトは<code>9300-9400</code>）の最初の5ポートに対してユニキャストを使用できるようにします。</p>

<p>これは、開発者のための、設定することなく自動的にクラスタを組むという機能を残しています。
しかし、本番に移行するときは、<a href="https://www.elastic.co/guide/en/elasticsearch/reference/2.0/modules-discovery-zen.html#unicast">unicast hosts</a>で次のようにリストを指定する必要があります。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>discovery.zen.ping.unicast.hosts: [ 192.168.1.2,  192.168.1.3 ]</span></code></pre></td></tr></table></div></figure>


<p>unicast hostsとしてクラスタにあるノードの全てのリストを指定する必要はありません。
少なくとも、マスタノードとして選出されるべきものを指定します。
巨大なクラスタでは、3つの専用のマスタノードを持っており、この3つをunicast hostsとして設定することを推奨しています。</p>

<p>これにより、開発の知識・経験が、私たちの推奨する本番でのネットワーク設定に、より近いものとなります。</p>

<h2>ノード情報の変更</h2>

<p>最後に、<code>inet[/127.0.0.1:9200]</code>といったシンタックスを廃止します。
これは、Elasticsearchが<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/cluster-nodes-info.html">nodes-info API</a>などで、使用していたIPアドレスのためのシンタックスです。
今は、RFCに準拠した形で表示します。
<code>127.0.0.1:9200</code>（IPv4）や<code>[::1]:9200</code>（IPv6）のようにです。</p>

<p>質問がある場合は、<a href="https://discuss.elastic.co/c/elasticsearch">ElasticsearchのWebフォーラム</a>で質問してください。ベータはもうすぐです！（翻訳した時点で、すでにベータリリースされています。）</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Elasticsearch 2.0.0-beta1リリース（日本語訳）]]></title>
    <link href="http://blog.johtani.info/blog/2015/08/27/elasticsearch-2-0-0-beta1-released-ja/"/>
    <updated>2015-08-27T10:29:12+09:00</updated>
    <id>http://blog.johtani.info/blog/2015/08/27/elasticsearch-2-0-0-beta1-released-ja</id>
    <content type="html"><![CDATA[<p><strong>※この記事は次のブログを翻訳したものになります。</strong></p>

<p>原文：<a href="https://www.elastic.co/blog/elasticsearch-2-0-0-beta1-released">Elasticsearch 2.0.0-beta1 released</a></p>

<p>本日（8/26）、<strong>Lucene 5.2.1</strong>ベースの<strong>Elasticsearch 2.0.0-beta1</strong>をリリースしました。
本リリースは469名のコミッターからの2,500以上ものpull requestを含んでいます。
pull requestのうち、約850が2.0のための新規のものとなります。</p>

<p><strong>注意事項</strong>
本リリースはベータリリースであり、テストを目的としたものとなります。
Elasticsearch 2.0.0-beta1は Elasticsearch 2.0.0 GAと互換性があるかどうかの保証はありません。</p>

<p><strong>本番環境には利用しないでください。</strong></p>

<!-- more -->


<p><a href="https://www.elastic.co/downloads/past-releases/elasticsearch-2-0-0-beta1">Elasticsearch 2.0.0-beta1のダウンロードおよび、すべての変更についてはリンク</a>をごらんください。</p>

<p>Elasticsearch 2.0.0-beta1には次の新しい変更が含まれています。</p>

<ul>
<li>Pipeline Aggregations：これは、他のaggregationsの結果に対するAggregationを実行できます（導関数、移動平均、Holt Winter予測アルゴリズムなども含む）</li>
<li>ディスクやファイルシステムキャッシュにより適したより良いデータの圧縮</li>
<li>doc-valuesがデフォルトになったこと、マージ実行時のメモリ使用量の低減、フィルターキャッシュのためのroaring bitsetsなどにより、ヒープの使用率がより効率的に。</li>
<li>構造化された例外</li>
<li>最適化されたクエリ実行順序、フィルタの自動キャッシュ、より高速なクエリに書き換えられたparent-child</li>
<li>設定の代わりに、フィードバックループを使用した自動調整</li>
<li>トランザクションログへの書き込みがデフォルトで、アトミックでかつ冗長に</li>
<li>安全で明確で信頼性のあるタイプマッピング</li>
<li>デフォルトでローカルホストでのみクラスタを構成</li>
<li>クラスタ状態の差分によりより高速に変更を伝搬</li>
</ul>


<p>上記の変更以外にも、多くのElasticsearchおよびLuceneに対する継続的な変更が含まれています。
これらは、Elasticsearch 2.0をより安全に、より簡単に、より良いものにしています。
本リリースに関するより詳しい情報が次のブログにあるので、参考にしてください。</p>

<ul>
<li><a href="https://www.elastic.co/blog/elasticsearch-2.0.0.beta1-coming-soon">Elasticsearch 2.0.0.beta1 coming soon!</a></li>
<li><a href="https://www.elastic.co/blog/great-mapping-refactoring">The Great Mapping Refactoring</a></li>
<li><a href="https://www.elastic.co/blog/store-compression-in-lucene-and-elasticsearch">Store compression in Lucene and Elasticsearch</a></li>
<li><a href="https://www.elastic.co/blog/better-query-execution-coming-elasticsearch-2-0">Better query execution coming to Elasticsearch 2.0</a></li>
<li><a href="https://www.elastic.co/blog/out-of-this-world-aggregations">Out of this world aggregations</a></li>
<li><a href="https://www.elastic.co/blog/staying-in-control-with-moving-averages-part-1">Staying in Control with Moving Averages - Part 1</a></li>
<li><a href="https://www.elastic.co/blog/staying-in-control-with-moving-averages-part-2">Staying in Control with Moving Averages - Part 2</a></li>
<li><a href="https://www.elastic.co/blog/core-delete-by-query-is-a-plugin">The Delete by Query API Is now a plugin</a></li>
<li><a href="https://www.elastic.co/blog/elasticsearch-unplugged">Elasticsearch unplugged - Networking changes in 2.0</a></li>
</ul>


<p>また、<a href="https://www.elastic.co/guide/en/elasticsearch/reference/2.0/index.html">Elasticsearch 2.0.0-beta1のドキュメント</a>も参考になります。
特に、<a href="https://www.elastic.co/guide/en/elasticsearch/reference/2.0/breaking-changes-2.0.html">2.0での重大な変更点について</a>は必ずごらんください。</p>

<h2>Core plugins</h2>

<p>コアプラグインの開発の方法を変更しました。
公式にサポートしているプラグインは、現在<a href="https://github.com/elastic/elasticsearch/tree/master/plugins">elasticsearchのリポジトリ</a>に含まれています。
これにより、コアと一緒にテストされ、Elasticsearchと同じタイミングでリリースされます。
コアプラグインはElasticsearchと同じバージョン番号隣ます。
インストールは次のようになります。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sudo bin/plugin install analysis-icu</span></code></pre></td></tr></table></div></figure>


<p><a href="https://www.elastic.co/guide/en/elasticsearch/plugins/2.0/index.html">プラグインの新しいドキュメント</a>は私たちのWebサイトの<a href="https://www.elastic.co/guide/index.html">Guide</a>にあります。</p>

<h2>Commercial plugins</h2>

<p>私たちの商用プラグインもElasticsearchと同じバージョン番号となり、Elasticsearchと一緒にリリースされます。
ShieldやWatcherはすでに2.0.0-beta1が利用可能です。
インストールのコマンドはは次のようになります。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sudo bin/plugin install license
</span><span class='line'>sudo bin/plugin install shield
</span><span class='line'>sudo bin/plugin install watcher</span></code></pre></td></tr></table></div></figure>


<p>MarvelおよびSenseに関する新しい情報もありますが、もう少しお待ちください。</p>

<p>2.0.0-beta1の商用プラグインに関するドキュメントは次のリンクからごらんください。</p>

<ul>
<li><a href="https://www.elastic.co/guide/en/shield/2.0.0-beta1/index.html">Shield 2.0.0-beta1</a></li>
<li><a href="https://www.elastic.co/guide/en/watcher/2.0.0-beta1/index.html">Watcher 2.0.0-beta1</a></li>
</ul>


<h2>Elasticsearch Migration plugin</h2>

<p>Elasticsearch 2.0.0-beta1を試す前に、
既存のインデックスのアップグレードするためになにか行う必要があるかどうかを確認するためのElasticsearch Migration Pluginもリリースしました。
2.0.0では機能しない、問題のあるマッピングなどを見つけるために便利なプラグインです。</p>

<p>このプラグインの利用方法については<a href="http://github.com/elastic/elasticsearch-migration">Elasticsearch Migration repository</a>をごらんください。</p>

<h2>既知の問題</h2>

<p>同じインデックスの異なるタイプに、同じ名前の<code>ip</code>タイプのフィールドを追加した時に、問題があることがわかっています。
この問題は次のリリースでフィックスされます。詳細は<a href="https://github.com/elastic/elasticsearch/issues/13112">#13112</a>をごらんください。</p>

<h2>テストしましょう！</h2>

<p>Elasticsearch 2.0.0 GAをすぐにリリースできるようにより多くのベータテスターをお待ちしています。</p>

<p>ぜひ、<a href="https://www.elastic.co/downloads/past-releases/elasticsearch-2-0-0-beta1">Elasticsearch 2.0.0-beta1</a>をダウンロードして、試してみてください。
そして、感想をTwitter(<a href="https://twitter.com/elastic">@elastic</a>)や<a href="https://discuss.elastic.co/c/elasticsearch">Webフォーラム</a>などで教えて下さい。
また、問題がありましたら、<a href="https://github.com/elastic/elasticsearch/issues">GitHub issues page</a>で報告をお願いします。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Delete by Query APIはプラグインへ（日本語訳）]]></title>
    <link href="http://blog.johtani.info/blog/2015/08/20/core-delete-by-query-is-a-plugin-ja/"/>
    <updated>2015-08-20T13:24:04+09:00</updated>
    <id>http://blog.johtani.info/blog/2015/08/20/core-delete-by-query-is-a-plugin-ja</id>
    <content type="html"><![CDATA[<p><strong>※この記事は次のブログを翻訳したものになります。</strong></p>

<p>原文：<a href="https://www.elastic.co/blog/core-delete-by-query-is-a-plugin">The Delete by Query API Is now a plugin</a></p>

<p>Elasticsearchの2.0.0-beta1では、これまであった <a href="https://www.elastic.co/guide/en/elasticsearch/reference/1.6/docs-delete-by-query.html">Delete by Query API</a>が<a href="https://github.com/elastic/elasticsearch/pull/10859">削除</a>され、
新しく <a href="https://www.elastic.co/guide/en/elasticsearch/plugins/2.0/plugins-delete-by-query.html">Delete by Query plugin</a>に<a href="https://github.com/elastic/elasticsearch/pull/11516">置き換え</a>られています。</p>

<!-- more -->


<p>もし、Delete by Query を利用する場合、2.0にアップグレードしたあとは、プラグインをインストールし、ドキュメントに従ってください。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>bin/plugin install delete-by-query</span></code></pre></td></tr></table></div></figure>


<h2>なぜプラグインに？</h2>

<p>ElasticsearchのコアなAPIの品質を保つためであり、以前のDelete by Queryの実装は簡単にはフィックスできない大きな問題がありました。</p>

<ul>
<li>各リクエストのあとに、<a href="https://www.elastic.co/guide/en/elasticsearch/reference/1.6/indices-refresh.html">refresh</a>を実行します。これは、<a href="https://github.com/elastic/elasticsearch/issues/3593">削除されたデータが想定外に検索に出てこないようにするため</a>です。<br/>
また、<a href="https://github.com/elastic/elasticsearch/issues/6025">セグメントが大量にでき、マージが大量に発生し、ヒープが大量に消費されてインデキシングが劇的にスローダウンし</a>、クラスタの複数のノードがクラッシュしてしまう状況も引き起こしました。</li>
<li>このクエリは、プライマリ、レプリカの両方で実行されるため、ことなるドキュメントを削除し、矛盾したレプリカ（データの破損）を引き起こしました。</li>
<li>アップグレードが不安定になります。これは、Delete by Queryリクエストがトランザクションログの中にクエリとして残るためです。そのため、アップグレードのあとに正確にパースされなかったり正確に実行されないかもしれません。例えば、インデックスエイリアスに対するリクエストで、それが削除された後の場合に<a href="https://github.com/elastic/elasticsearch/issues/10262">このようなバグ</a>が発生します。</li>
</ul>


<p>対照的に、<a href="https://www.elastic.co/guide/en/elasticsearch/plugins/2.0/plugins-delete-by-query.html">新しいプラグイン</a>は、安全な実装です。
<a href="https://www.elastic.co/guide/en/elasticsearch/guide/current/scan-scroll.html">scanとscrollリクエスト</a>でクエリにマッチしたIDを見つけ、そのIDを使って、<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-bulk.html">bulk indexing API</a>で削除します。</p>

<p>この実装は、遅い必要があります。特に、クエリが多くのドキュメントを削除する場合です。
もし、多くのドキュメントをこのAPIを利用して削除する場合、アプリケーションをテストしてください。
そして、<a href="https://www.elastic.co/blog/lucenes-handling-of-deleted-documents">代わりにインデックス全体を消す</a>ようなアプローチに切り替えることができないか検討してください。</p>

<p><a href="https://www.elastic.co/guide/en/elasticsearch/plugins/2.0/delete-by-query-plugin-reason.html">Delete by Query pluginのドキュメント</a>に、新しい実装についての違いなどのより詳しい説明があります。</p>

<h2>Elasticsearch coreを最小限に</h2>

<p>プラグインに切り替えることは、簡単な決断ではありませんでした。
多くのユーザは問題なく、Delete by Queryを利用していました。
しかし、危険が常にそこにあり、些細とは言い切れない数のユーザが上記のような深刻な問題に遭遇していました。</p>

<p>さらに、Elsticsearchのコアは信頼できるものでなければなりません。
他のコアAPIを利用して実装できる機能は、コアに含みません。特に、それがバグを含んでいる場合。
コアのすべての機能は強固であるべきで、Delete by Queryは人気があり、高性能ですが、そうではありませんでした。</p>

<p>必要に応じて、このような難しいトレードオフの末、信頼性と品質を選びます。</p>

<h2>マッピングの削除の廃止</h2>

<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/1.6/indices-delete-mapping.html">タイプのマッピングを削除する機能</a>も2.0で<a href="https://github.com/elastic/elasticsearch/issues/8877">廃止</a>されます。
これは、同じフィールド名を、異なるフィールドのタイプで再利用した場合に、インデックスの破損を引き起こす可能性があるためです。</p>

<p>しかし、<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-match-all-query.html">Match All Query</a>で、Delete by Queryプラグインに対してタイプを指定することで、タイプのすべてのドキュメントを削除することはできます。
または、1つのインデックスに異なるタイプを複数含める代わりに、個別のインデックスに分割するようなアプローチに変更することを検討してください。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[第11回Elasticsearch勉強会を開催しました。#elasticsearchjp]]></title>
    <link href="http://blog.johtani.info/blog/2015/07/31/11th-elasticsearch-jp/"/>
    <updated>2015-07-31T14:41:53+09:00</updated>
    <id>http://blog.johtani.info/blog/2015/07/31/11th-elasticsearch-jp</id>
    <content type="html"><![CDATA[<p><a href="https://elasticsearch.doorkeeper.jp/events/28321">第11回Elasticsearch勉強会</a>を開催しました。
スタッフの皆さん、スピーカーの皆さん、会場提供していただいた<a href="http://recruit-tech.co.jp">リクルートテクノロジーズさん</a>、そして、Shayありがとうございました！
次回もよろしくお願いします！参加していただき盛り上げていただいた参加者の皆さんもありがとうございました。</p>

<p>今回は、CTOのShayが来日していたので、英語でいろいろと喋ってもらいました。
4月同様、<a href="http://samuraism.com">サムライズム</a>の<a href="https://twitter.com/yusuke">@yusuke</a>さんに
テキスト翻訳していただき、大変助かりました。
今回はQAベースのトークだったのでちょっときつかったですね、申し訳ない。。。</p>

<!-- more -->


<h3>チェックイン数など</h3>

<ul>
<li>チェックインした人：141名</li>
<li>キャンセルしなかった人：51名</li>
</ul>


<p>でした。
今回はあらかじめ220名（全員が来たらキャパオーバー）としていたので、キャンセル待ちの人は
当日の午後にはいなくなっていた状態です。まぁ、こんなもんかな。結構入りましたね。ありがたいです。</p>

<h2>LT</h2>

<p>今回は、少し趣向を変えて、4社の方達にLTをしていただきました。
Shayが来日しているのもあり、事前に英語でスライドを作っていただけると助かりますとお願いさせていただきました。
英語でスライドを作っていただいていたので、伝わりやすくて助かりました、スピーカーの方々ありがとうございました！<br/>
（海外のユーザにもリンクを紹介しやすいので、英語でスライド作ってもらえるといろいろと知ってもらえるのかも。）</p>

<h3>Elasticsearch and Recruit Technologies Co., Ltd. / 株式会社リクルートテクノロジーズ　守谷 純之介さん</h3>

<p>スライド：未定</p>

<p>N-Gramと形態素のハイブリッドの話などをしていただきました。
@ITで連載もされてますね。ありがとうございます。</p>

<ul>
<li><a href="http://www.atmarkit.co.jp/ait/articles/1507/08/news009.html">リクルート全社検索基盤のアーキテクチャ、採用技術、開発体制はどうなっているのか (&frac12;)</a></li>
<li><a href="http://www.atmarkit.co.jp/ait/articles/1507/29/news010.html">ElasticsearchとKuromojiを使った形態素解析とN-Gramによる検索の適合率と再現率の向上 (1/3)</a></li>
</ul>


<p>Shayからは、<a href="https://www.elastic.co/products/hadoop">elasticsearch-hadoop</a>があるから検討してねと質問（お願い？）がありましたw。</p>

<h3>Elasticsearch as a DMP / 株式会社インティメート・マージャー　松田和樹さん　@mats116</h3>

<p>スライド：<a href="http://www.slideshare.net/im_docs/elasticsearch-as-a-dmp">Elasticsearch as a DMP</a></p>

<p>いくつかのデータソースからAEROSPIKE経由でelasticsearchにデータを登録しているようです。
Data Management Platformのエンジンの一部として、elasticsearchを利用しているようです。</p>

<p>Shayからの質問：「どの機能を使って関心のある単語を抽出していますか？」<br/>
回答：「<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-bucket-significantterms-aggregation.html">Significant Term Aggregation</a>」です。<br/>
Shay：「おぉ、チェックしてみますw」。</p>

<h3>Real-time social big data analytics using elasticsearch / 株式会社ホットリンク宮田洋毅さん　@kakka_jp</h3>

<p>スライド：未定</p>

<p>ソーシャルメディアのデータを解析するのにelasticsearchにデータを入れて解析。
時間軸での解析やテキストマイニングなんかをしているみたいでした。
いろいろと独自のプラグインを作ってるようです。（興味あるなぁ）</p>

<p>Shayからの質問：「ノード数は？」「30ノードで30シャード」</p>

<h3>Elasticsearch in Hatena Bookmark / 株式会社はてな　id:skozawa</h3>

<p>スライド：<a href="http://www.slideshare.net/shunsukekozawa5/elasticsearch-in-hatena-bookmark">Elasticsearch in Hatena Bookmark</a></p>

<ul>
<li>はてなブックマークの検索の歴史（MySQL -> Sedue -> Solr -> Elasticsearch）</li>
<li>はてなブックマークの検索（ユーザが利用）と社内利用と、ログ解析で利用してる</li>
</ul>


<p>Shayからの質問：「昨年会いましたよね？今はクラスタのサイズはどのくらいのサイズですか？」「メインクラスタは9データノード」</p>

<h2>Open QA with Shay</h2>

<p>思い出せるものだけ。。。（あとで追記します）</p>

<ul>
<li>Elasticsearch 2.0の話

<ul>
<li><a href="https://www.elastic.co/blog/out-of-this-world-aggregations">Pipeline Aggregation</a>とか。</li>
</ul>
</li>
<li>Spark Streaming対応してる？

<ul>
<li>まだ検討中</li>
</ul>
</li>
<li>elasticsearch-hadoopってどんなもの？HDFSにインデックス作ったりするの？

<ul>
<li>いえ、Hadoopの入出力先としてelasticsearchが使える感じ</li>
</ul>
</li>
<li>個人的にAWSのCloudSearchとAWSでElasticsearchはどっちがいい？

<ul>
<li>時系列データはCloudSearchだと難しいだろうし、AWS上なら<a href="http://found.no">found.no</a>があるよ！</li>
</ul>
</li>
<li>PostgreSQLみたいに信頼性の高いデータストアを目指してる（まだ、プライマリデータストアには使わないで）</li>
</ul>


<h2>その他、感想などのブログ</h2>

<ul>
<li><a href="http://tech.im-dmp.net/archives/4941">Elasticsearch勉強会でLTしてきました | Intimate Merger Engineer Blog </a></li>
<li><a href="http://togetter.com/li/853331">『第11回elasticsearch勉強会』のまとめ #elasticsearchjp</a></li>
<li><a href="http://suzuki.tdiary.net/20150728.html#p01">[Elasticsearch] 第11回 Elasticsearch 勉強会へ参加してきた - 雑文発散(2015-07-28)</a></li>
<li><a href="http://kakakakakku.hatenablog.com/entry/2015/07/27/224203">第11回 Elasticsearch 勉強会に参加したら英語力に危機感を覚えて最高だった</a></li>
</ul>


<h3>まとめ</h3>

<p>今回はShayが来日したので特別バージョンでした。
もっと英語を翻訳するサポートしないとですね、反省してます。。。ぜんぜん流暢じゃないしw</p>

<p>次回は9月に開催予定ですが、12月にまたShayが再度来日する予定です。
丸1日のイベントを検討中で、Shay以外にも開発者が来日すると思います。
どんな話が聞きたい、どんな人と話をしたいなどあれば、コメントいただければ（対応できるかは。。。）</p>

<p>勉強会のスピーカーは随時募集中ですので、コメント、メール、ツイートなど、コンタクトしていただければと思います。 よろしくお願いいたします。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Elasticsearch 1.7.1 および 1.6.2リリース（日本語訳）]]></title>
    <link href="http://blog.johtani.info/blog/2015/07/29/elasticsearch-1-7-1-and-1-6-2-released-ja/"/>
    <updated>2015-07-29T21:35:53+09:00</updated>
    <id>http://blog.johtani.info/blog/2015/07/29/elasticsearch-1-7-1-and-1-6-2-released-ja</id>
    <content type="html"><![CDATA[<p><strong>※この記事は次のブログを翻訳したものになります。</strong></p>

<p>原文：<a href="https://www.elastic.co/blog/elasticsearch-1-7-1-and-1-6-2-released">Elasticsearch 1.7.1 and 1.6.2 released</a></p>

<p>本日（7/29）、<strong>Lucene 4.10.4</strong>ベースの<strong>Elasticsearch 1.7.1</strong>および<strong>Elasticsearch 1.6.2</strong> のバグフィックス版をリリースしました。
これらのリリースは稀ですが、データの欠損が発生する重要なバグのフィックスを含んでいます。
<strong>すべてのユーザにアップグレードを推奨します。</strong></p>

<p>ダウンロードおよびすべての変更については次のリンクをごらんください。</p>

<ul>
<li>最新安定版：<a href="https://www.elastic.co/downloads/past-releases/elasticsearch-1-7-1">Elasticsearch 1.7.1</a></li>
<li>1.6系バグフィックス：<a href="https://www.elastic.co/downloads/past-releases/elasticsearch-1-6-2">Elasticsearch 1.6.2</a></li>
</ul>


<!-- more -->


<p>問題のバグ(<a href="https://github.com/elastic/elasticsearch/pull/12487">#12487</a>)は、
同時に複数のノードが故障またはリスタートをした場合の非常にまれな状況で、
シャードのすべてのコピーがクラスタから削除されてしまう状況を発生させます。
このバグは1.5.0から含まれています。</p>

<p>このリリースはまた、IPv4アドレスのCIDRマスクのバグのフィックス、
Shieldユーザがmore-like-this APIを利用できないバグのフィックスなど、
いくつかの変更も含んでいます（詳細は<a href="https://www.elastic.co/downloads/past-releases/elasticsearch-1-7-1">更新リスト</a>をごらんください）。</p>

<p>ぜひ、<a href="https://www.elastic.co/downloads/past-releases/elasticsearch-1-7-1">Elasticsearch 1.7.1</a>をダウンロードして、試してみてください。
そして、感想をTwitter(<a href="https://twitter.com/elastic">@elastic</a>)などで教えて下さい。
また、問題がありましたら、<a href="https://github.com/elastic/elasticsearch/issues">GitHub issues page</a>で報告をお願いします。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Elasticsearch 1.7.0 および 1.6.1リリース（日本語訳）]]></title>
    <link href="http://blog.johtani.info/blog/2015/07/22/elasticsearch-1-7-0-and-1-6-1-released-ja/"/>
    <updated>2015-07-22T15:33:37+09:00</updated>
    <id>http://blog.johtani.info/blog/2015/07/22/elasticsearch-1-7-0-and-1-6-1-released-ja</id>
    <content type="html"><![CDATA[<p><strong>※この記事は次のブログを翻訳したものになります。</strong></p>

<p>原文：<a href="https://www.elastic.co/blog/elasticsearch-1-7-0-and-1-6-1-released">Elasticsearch 1.7.0 and 1.6.1 released</a></p>

<p>本日（7/16）、<strong>Lucene 4.10.4</strong>ベースの<strong>Elasticsearch 1.7.0</strong>および<strong>Elasticsearch 1.6.1</strong> のバグフィックス版をリリースしました。
これらのリリースはセキュリティフィックスを含んでおり、<strong>すべてのユーザにアップグレードを推奨します。</strong></p>

<p>ダウンロードおよびすべての変更については次のリンクをごらんください。</p>

<ul>
<li>最新安定版：<a href="https://www.elastic.co/downloads/past-releases/elasticsearch-1-7-0">Elasticsearch 1.7.0</a></li>
<li>1.6系バグフィックス：<a href="https://www.elastic.co/downloads/past-releases/elasticsearch-1-6-1">Elasticsearch 1.6.1</a></li>
</ul>


<!-- more -->


<p>1.7.0が1.x系の最後のリリースとなります。
今後の新機能については、Elasticsearch 2.0以降で取り込まれる予定です。</p>

<p>Elasticsearch 1.7.0は小さなリリースですが、2つの重要なセキュリティフィックスと
クラスタの安定化とリカバリに関する2つの重要な機能を含んでいます。</p>

<ul>
<li><a href="#security">セキュリティフィックス</a></li>
<li><a href="#delayed">シャードアロケーションを遅らせる</a></li>
<li><a href="#prioritization">インデックスリカバリの優先度</a></li>
</ul>


<h2><a name="security">セキュリティフィックス</a></h2>

<p>Elasticsearch 1.6.1 と 1.7.0 は次の2つのセキュリティフィックスを含んでいます。</p>

<h3>リモートコード実行の脆弱性</h3>

<p>Elasticsearch 1.6.1より前のバージョンには、transport protocol（ノードとJavaクライアント間での通信に利用）により、
リモートでコードが実行される脆弱性があります。
これは、<a href="http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2015-3253">CVE-2015-3253</a>でのGroovyに関係しています。</p>

<p>Groovyのダイナミックスクリプティングがオフでも脆弱性があります。
アップグレードをしないユーザは、transport protocol のポート（デフォルトで9300）信頼したエージェントからのみの
アクセスに限定することで、脆弱性から保護できます。</p>

<p>この問題を<a href="https://www.elastic.co/community/security">CVE-2015-5377</a>としました。</p>

<h3>ディレクトリ探索の脆弱性</h3>

<p>Elasticsearch 1.0.0から1.6.0までのバージョンで、ElasticsearchのJVMプロセスによって読み込みが可能なファイルを
取得することができるディレクトリ探索攻撃の脆弱性があります。
アップグレードをしないユーザは、信頼できない場所からの<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/modules-snapshots.html">Snapshot-Restore API</a>の呼び出しを防ぐためにファイアウォール、リバースプロキシやShieldを使用することができます。</p>

<p>この問題を<a href="https://www.elastic.co/community/security">CVE-2015-5531</a>としました。</p>

<h2><a name="delayed">シャードアロケーションを遅らせる</a></h2>

<p>Elasticsearch 1.6.0で<a href="https://www.elastic.co/blog/elasticsearch-1-6-0-released#synced-flush">Synced Flushing</a>が導入されました。
これは、ノードのリスタート時に、更新が止まっているシャードのリカバリを劇的にスピードアップします。
しかし、この変更は、シャードの配置を無効にしている環境でのみうまく実行されます。
ノードが一時的にクラスタから外れている場合や予期せぬリブートの場合には役に立ちません。</p>

<p>このシナリオとは次のようなものです。</p>

<ul>
<li>ノードの想定外のシャットダウン</li>
<li>マスタがたのノードにシャードを再配置</li>
<li>各シャードが新しい場所にネットワーク越しにコピー</li>
<li>その間に、外れていたノードが再度クラスタにジョイン</li>
<li>マスタは新しいノードにシャードを再配置。新しいノードに存在する既存のシャードが全く再利用されない可能性がある</li>
</ul>


<p>ノードレベルとクラスタレベルの両方の並列的なリカバリを抑制しても、
この&#8221;シャードシャッフル&#8221;がクラスタに対して負荷をかける可能性があります。
これは、外れたノードが再度ジョインするのを単に待つことにより防げるかもしれません。</p>

<h3>待ちましょう！</h3>

<p>Elasticsearch 1.7.0は<a href="https://www.elastic.co/guide/en/elasticsearch/reference/1.7/delayed-allocation.html"><code>index.unassigned.node_left.delayed_timeout</code></a>設定を追加しました。デフォルトでは1分です。
これは、ノードがクラスタから外れたとき、ほかのノードにこれらのノードを再配置するまでマスタが1分待つということです。
ノードがこの1分の間に復帰した場合、マスタはローカルにあるシャードを再度配置します。</p>

<h3>なぜ1分？</h3>

<p>ノードがシャットダウンし、リスタートし、復帰するために十分な時間が1分だからです。
しかし、ノードが復帰しない場合にはまだ再配置が発生することを意味します。
デフォルト値を決定するのは難しいです。
この設定をどのくらいに減らすか、増やすかを決める必要があるかもしれません。</p>

<p>このデフォルト値は、<code>config/elasticsearch.yml</code>ファイルに設定できますが、<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/indices-update-settings.html">インデックス設定の更新API</a>を使って設定することも可能です。</p>

<p>このデフォルトに関する知見をぜひフィードバックしてください。</p>

<h2><a name="prioritization">インデックスリカバリの優先度</a></h2>

<p>1.7.0の2つ目の重要な機構はフルクラスタリスタートのような後に、
どの順番でインデックスをリカバリするかという優先度をつけることができるという機能です。</p>

<p>電源故障による、ロギング用のクラスタのダウンを想像してください。
クラスタが普及した場合、500個のインデックスをリカバリするような場合、499個のインデックスのデータは古く、
500番目のインデックスが重要です。
もっとも最近作成されたインデックスがリカバリされるまで、インデキシングを待つというようなことはできません。</p>

<p>これまでは、インデックスはランダムな順序でリカバリされ、重要なインデックスがリカバリされるまで待つしかありませんでした。
1.7.0では、インデックスは優先度の順番でリカバリされます。
この優先度は次のプロパティで指定できます。</p>

<ul>
<li><code>index.priority</code>設定（大きな値が優先度が高い）</li>
<li>インデックス作成日（新しいものが優先度が高い）</li>
<li>インデックス名</li>
</ul>


<p>既存のクラスタについて特に変更せずとも、最も最近作成されたインデックスが古いものよりも復旧されます。
古いインデックスの優先度を上げるためには、<code>index.priority</code>設定に0よりも大きな値を設定します。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>PUT important_index/_settings
</span><span class='line'>{
</span><span class='line'>  "index.priority": 5
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>この設定は、存在するインデックスに対して更新できます。リカバリ中にもです。</p>

<h2>まとめ</h2>

<p>ぜひ、<a href="https://www.elastic.co/downloads/past-releases/elasticsearch-1-7-0">Elasticsearch 1.7.0</a>をダウンロードして、試してみてください。
そして、感想をTwitter(<a href="https://twitter.com/elastic">@elastic</a>)などで教えて下さい。
また、問題がありましたら、<a href="https://github.com/elastic/elasticsearch/issues">GitHub issues page</a>で報告をお願いします。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[大阪と京都でElasticsearch勉強会を開催しました。 #elasticsearchjp]]></title>
    <link href="http://blog.johtani.info/blog/2015/07/16/kansai-1st-elasticsearch-jp/"/>
    <updated>2015-07-16T10:40:57+09:00</updated>
    <id>http://blog.johtani.info/blog/2015/07/16/kansai-1st-elasticsearch-jp</id>
    <content type="html"><![CDATA[<p>東京以外での勉強会の第2弾として、関西で勉強会を開催してきました。</p>

<ul>
<li><a href="https://elasticsearch.doorkeeper.jp/events/27555">Elasticsearch勉強会 in 大阪</a></li>
<li><a href="https://elasticsearch.doorkeeper.jp/events/27553">Elasticsearch勉強会 in 京都</a></li>
</ul>


<p>会場提供をしていただいた、Yahoo!大阪、はてなのみなさん、ご協力ありがとうございました！</p>

<p><img src="http://blog.johtani.info/images/entries/20150715/osaka.jpg"></p>

<!-- more -->


<p><img src="http://blog.johtani.info/images/entries/20150715/kamogawa.jpg"></p>

<p>ここからはいつものメモです。
ちなみに、大阪の勉強会に、<a href="https://twitter.com/takuya_a">@takuya_a</a>さんと<a href="https://twitter.com/5kozawa">@5kozawa</a>さんの両名にお越しいただき話をしていただきました。
なので、勉強会の内容はほぼ同一になります。</p>

<h2>Introduction Elastic @johtani</h2>

<p>スライド：<a href="https://speakerdeck.com/johtani/introduction-elastic-1">Introduction Elasticsearch</a></p>

<p>初めての関西での勉強会ということで、ElasticsearchのOSSおよび商用プラグインの紹介をしてきました。
もちろん、Kibanaのデモもちょっとだけ。スプラトゥーンに関するデータをKibanaでちょっとだけ。
突貫でデータをかき集めたのでもう少し改良しないとですが。</p>

<h2>Elasticsearch での類似文書検索と More Like This API 詳解 / 株式会社はてな　id:takuya-a</h2>

<p>スライド：<a href="https://speakerdeck.com/takuyaa/elasticsearch-defalselei-si-wen-shu-jian-suo-to-more-like-this-query-api-xiang-jie">Elasticsearch での類似文書検索と More Like This Query API 詳解</a></p>

<p>Elasticsearchの<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-mlt-query.html">More Like This</a>のソースコードリーディングみたいな感じで、
内部でどうやって処理されているかの説明を詳しくしてもらいました。</p>

<p>前のはてなエンジニアセミナーで話をされていた検索精度の件に絡んだ内容になっているかと。
（大阪で発表してもらった時より京都での発表が分かりやすくなってました。1日で改善されたのすごい！）
MoreLikeThisだとチューニングつらいので、自分で作るために<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-termvectors.html">TermVectorAPI</a>でやってみたという流れかと。</p>

<p>以下は発表後に出てきた質問のいくつかです。</p>

<p>Q:MoreLikeThisに対してTermVectorで柔軟にできる？
A:TermVectorのAPIで統計情報が取れるので、それを使うことでさらなるデータの更新ができる。</p>

<p>Q:TFとかの統計情報が必要なら、すべてインデックスをしたあとじゃないとちゃんとした値はとれないのでは？
A:TermVectorで取得したものをどうやって使うか</p>

<p>Q:TermVectorAPi&hellip;聞こえなかった
A:。。。</p>

<h2>Elasticsearchを用いたはてなブックマークのトピック生成 / 株式会社はてな　id:skozawa</h2>

<p>スライド：<a href="http://www.slideshare.net/shunsukekozawa5/elasticsearch-in">Elasticsearchを用いたはてなブックマークのトピック生成</a></p>

<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-bucket-significantterms-aggregation.html">Significant Terms Aggregation</a>を活用してる話。
トピックページの生成のために、Significant Terms Aggregationをどうやって利用しているかなどのお話でした。</p>

<p>トピックの集合の重複だったり、精度の判定方法とかいろいろ詳しく説明していただきました。</p>

<p>Q:2011年と12年で11年の方が多いのは？
A:ブックマークの件数に比例</p>

<p>Q:Significant terms aggsのsizeはいくつをつかってますか？
A:20を指定してます。</p>

<p>Q:Yahooとかニュースをストップワードとしてますが、Yahoo自体のニュースに関してはどーしてるんですか？
A:本文とタイトルから別々に作っていて、タイトルからは弾かれますが、本文から作った時に出てきます。</p>

<h2>はてなブックマークにおける Elasticsearch の運用まわりの話 / 株式会社はてな　id:hagihala</h2>

<p>スライド：未定（おそらく公開される）</p>

<p>体調が回復しきっていない中の発表ありがとうございました。
大幅に修正された資料が出てくるかなと。（ツイートできない数値がちらほらあったので）</p>

<p>Elasticsearchのクラスタの構成、どういった点で困ってたのでどういう調べ方をしたのか、どういった対処をしたのか。
どのあたりが次の課題かなどの話もありました。</p>

<h2>感想・反省点など</h2>

<p>大阪、京都ともに30名弱の方の参加をしていただきました。ありがとうございました。
反省点としては、ハッシュタグを告知し忘れてました。。。</p>

<p>勉強会はやはり、東京が異常に活発で、大阪や京都はまだそれほどでもないのかなぁとも。
大阪はエンジニアの人や会社も多い気がするんですが。私の告知の仕方もあるかもなぁと。
次回があれば、大阪での事例も聞きたいので、スピーカーをもっと探さないとなと。</p>

<h2>関連ブログなど</h2>

<p>見つけたら、リンク追加していきます。</p>

<ul>
<li><a href="http://skozawa.hatenablog.com/entry/2015/07/17/194709">Elasticsearch勉強会 in 大阪/京都で発表しました</a></li>
<li><a href="http://stop-the-world.hatenablog.com/entry/2015/07/22/014047">「Elasticsearch での類似文書検索と More Like This Query API 詳解」というタイトルで発表しました</a></li>
</ul>


<h2>その他（余談）</h2>

<p>大阪のYahoo!さんは立地条件（梅田のすぐそば）がよく、</p>

<p><img src="http://blog.johtani.info/images/entries/20150715/yahoo_osaka.jpg" width="300"></p>

<p>夜景も綺麗でした。大阪城とかも見えてました。（夜景じゃないけど。。。）</p>

<p><img src="http://blog.johtani.info/images/entries/20150715/view_from_yahoo.jpg" width="600"></p>

<p>京都は祇園祭の真っ最中。</p>

<p><img src="http://blog.johtani.info/images/entries/20150715/naginata2.jpg" width="300"></p>

<p>水曜日はお休みをいただいて、観光してました。ちょっと日焼けが。。。
おかげで、リフレッシュできました。三十三間堂とか良かった:)</p>

<p>あまり、関西に縁がない（大阪15年ぶり、京都10年ぶり）ので、
もっとユーザが増えて勉強会の機運が高まると嬉しいなと。:)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mappingのすばらしいリファクタリング（日本語訳）]]></title>
    <link href="http://blog.johtani.info/blog/2015/07/08/great-mapping-refactoring-ja/"/>
    <updated>2015-07-08T18:11:31+09:00</updated>
    <id>http://blog.johtani.info/blog/2015/07/08/great-mapping-refactoring-ja</id>
    <content type="html"><![CDATA[<p><strong>※この記事は次のブログを翻訳したものになります。</strong></p>

<p>原文：<a href="https://www.elastic.co/blog/great-mapping-refactoring">The Great Mapping Refactoring</a></p>

<!-- more -->


<p>Elasticsearchのユーザの悩みの最も大きなものの一つは、
タイプとフィールドのマッピングに関する多義性です。
この多義性は、インデックス時の例外やクエリ時の例外、
正しくない結果、リクエストからリクエストへ変化する結果、
また、インデックスの故障やデータのロスを結果として引き起こします。</p>

<p>Elasticsearchをより強固で予測可能な振る舞いをするようにする作業において、
フィールドやタイプのマッピングをより厳格でより信頼性を高くするかといったことに
多くの変更を費やしました。
多くのケースで、Elasticsearch v2.0で新しいインデックスを作るときにのみ、
新しいルールを強制し、これまでのインデックスに関しては後方互換性を保つようにします。</p>

<p>しかし、幾つかのケースでは、先ほど説明したようなフィールドマッピングの
コンフリクトなどが存在するため、それらを利用できないです。</p>

<blockquote><p>コンフリクトしたフィールドのマッピングをもつインデックスはElasticsearch v2.0にはアップグレードできません。</p></blockquote>

<p>もし、これらのインデックスのデータが必要ない場合は、インデックスを消せばいいです。
そうでない場合はマッピングを正しくして再度インデックスする必要があるでしょう。</p>

<p>マッピングを正しく変更することは、私たちが簡単に決めることではありません。
ここからは、現在ある問題点と、私たちがどのように実装して解決したかについて説明します。</p>

<ul>
<li><a href="#conflicting-field-mappings">フィールドマッピングのコンフリクト</a></li>
<li><a href="#ambiguous-field-lookup">あいまいなフィールドのルックアップ</a></li>
<li><a href="#type-meta-fields">タイプのメタフィールド</a></li>
<li><a href="#analyzer-settings">アナライザ設定</a></li>
<li><a href="#index_name-and-path"><code>index_name</code>と<code>path</code></a></li>
<li><a href="#mapping-update">同期的なマッピングの更新</a></li>
<li><a href="#delete-mapping">マッピングの削除</a></li>
<li><a href="#prepare-2_0">2.0のための準備</a></li>
</ul>


<h2><a name="conflicting-field-mappings">フィールドマッピングのコンフリクト</a></h2>

<p>これまで、わたしたちはドキュメントのタイプは「データベースのテーブルのようなもの」と説明していました。
タイプの目的を説明する簡単な方法だったからです。
しかし、残念なことにこれは、真実ではありません。
「同じ」インデックスの「異なるタイプ」にある同じ名前のフィールドは、
内部的に、Luceneのフィールド名が同じものになります。</p>

<p>もし<code>error</code>フィールドとして、ドキュメントタイプが<code>apache</code>のものには数値（integer）を、
ドキュメントタイプが<code>nginx</code>のものには文字列（string）を割り当てた場合、
Elasticsearchは同じLuceneのフィールドに数値と文字列のデータをもつことになります。
このフィールドに対して、検索やaggregationを行う場合、おかしな結果を受け取るか、例外が帰ってくるか、
インデックスが破損することになります。</p>

<p>この問題を解決するために、まず、ドキュメントタイプの名前をフィールドの名前の前に追加することを考えました。
各フィールドは完全に別のものとなります。
このアプローチの利点はドキュメントタイプが実際のテーブルのようになることです。</p>

<p>しかし、この方法には多くの欠点があります。</p>

<ul>
<li>フィールドは常に、他のタイプとは異なるものであると区別するためもしくは、複数のタイプに同じフィールドのクエリのためにワイルドカードをつけた場合、
ドキュメントタイプを前につける必要があります。</li>
<li>複数のドキュメントタイプに対して同じフィールド名で検索する場合、クエリを個別に発行しなければならなく遅くなります。</li>
<li>多くの検索で、既存の多くのクエリを壊してしまうために、単純な<code>match</code>や<code>term</code>クエリの代わりに、multi-fieldクエリを使う必要があります。</li>
<li>圧縮の効率の悪さから、ヒープ利用量、ディスク使用量、I/Oなどが、増加します。</li>
<li>複数のドキュメントタイプに対するaggregationは、global ordinalの利点を利用できなくなるために、遅くなり、メモリの使用量も増えます。</li>
</ul>


<h3>解決方法</h3>

<p>最終的に、同じインデックスの同じ名前を持つ全てのフィールドは、同じマッピングを持つ必要があるというルールを採用することに決めました。
ただ、<code>copy_to</code>や<code>enabled</code>のようなパラメータはタイプごとに指定することができるようになっています。
これにより、データの破損、クエリ時の例外そして、おかしな結果が発生する問題を防ぎます。
クエリとaggregationは現在でも高速なままで、圧縮率を最大化し、ヒープ使用量やディスク使用率の低減させます。</p>

<p>この解決方法の欠点は、個別のテーブルとしてタイプを扱いたいユーザが彼らの考え方を変える必要があるということです。
これは、思ったよりも問題ではありません。
実際には、多くのフィールド名はデータの明確なタイプを表現しています。
<code>created_date</code>は常に、日付ですし、<code>number_of_hits</code>フィールドはいつも数値です。
フィールドマッピングがコンフリクトしているユーザはデータを失ったり、おかしなデータを受け取ったり、データを欠損させています。
ベストプラクティスにユーザが従っているかどうかによらず、インデックス時に正しい振る舞いを強制することが現在の違いです。</p>

<p>ユーザの多くがコンフリクトしていないフィールドマッピングをもっていれば、
コンフリクトが起きた場合、技術がこれらのシチュエーションを扱うことが可能になると思いませんか？
そこにはいくつかの解決方法があります。</p>

<h4>タイプの代わりにインデックスを別々に</h4>

<p>最も簡単な解決方法です。インデックスを別々のインデックスとし、実際のデータベーステーブルのようにします。
インデックスをまたいだ検索はタイプをまたいだ検索のように動作しますし、
ソートやaggregationも同じデータタイプへのクエリのように動作します。これまでと同じ制限です。</p>

<h4>コンフリクトしたフィールドの名前の変更</h4>

<p>コンフリクトがごくわずかな場合、（Logstashやアプリケーションで使っているものも一緒に）よりわかりやすいフィールド名に変更することで解決できます。
例えば、2つの<code>error</code>フィールドがあった場合に、<code>error_code</code>と<code>error_message</code>に変更します。</p>

<h4><code>copy_to</code>もしくはmulti-fieldsを利用</h4>

<p>異なるドキュメントタイプのフィールドは別々の<code>copy_to</code>を設定できます。
元の<code>error</code>フィールドは<code>index</code>の設定に<code>no</code>が設定してあり、全てのドキュメントタイプで無効化されていますが、
特定のタイプだけ、<code>error</code>フィールドの値を数値の<code>error_code</code>フィールドにコピーすることができます。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>PUT my_index/_mapping/mapping_one
</span><span class='line'>{
</span><span class='line'>  "properties": {
</span><span class='line'>    "error": {
</span><span class='line'>      "type": "string",
</span><span class='line'>      "index": "no",
</span><span class='line'>      "copy_to": "error_code"
</span><span class='line'>    },
</span><span class='line'>    "error_code": {
</span><span class='line'>      "type": "integer"
</span><span class='line'>    }
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>他のタイプでは文字列の<code>error_message</code>にコピーします。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>PUT my_index/_mapping/mapping_two
</span><span class='line'>{
</span><span class='line'>  "properties": {
</span><span class='line'>    "error": {
</span><span class='line'>      "type": "string",
</span><span class='line'>      "index": "no",
</span><span class='line'>      "copy_to": "error_message"
</span><span class='line'>    },
</span><span class='line'>    "error_message": {
</span><span class='line'>      "type": "string"
</span><span class='line'>    }
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>同様の解決方法として<a href="https://www.elastic.co/guide/en/elasticsearch/reference/master/mapping-core-types.html#multi-fields">multi-field</a>も使えます。</p>

<h4>各データタイプに対してネストしたフィールドに</h4>

<p>ときどき、Elasticsearchに送ったドキュメントやドキュメントがもっているフィールドを制御できない場合があります。
部分的なコンフリクトに加え、闇雲に、ユーザが送ってきたフィールドを受け入れると、マッピングが肥大化します。
タイムスタンプやIPアドレスをフィールド名に使うようなドキュメントがあると考えてください。</p>

<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping-nested-type.html"><code>nested</code> フィールド</a>にすることで、<code>str_val</code>、<code>int_val</code>、<code>date_val</code>というような各データタイプを利用できます。</p>

<p>このアプローチによって、次のドキュメントは</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>{
</span><span class='line'>  "message": "some string",
</span><span class='line'>  "count":   1,
</span><span class='line'>  "date":    "2015-06-01"
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>アプリケーションによって、次のようにフォーマットしなおす必要があります。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>{
</span><span class='line'>  "data": [
</span><span class='line'>    {"key": "message", "str_val":  "some_string" },
</span><span class='line'>    {"key": "count",   "int_val":  1             },
</span><span class='line'>    {"key": "date",    "date_val": "2015-06-01"  }
</span><span class='line'>  ]
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>この解決方法は、アプリケーションサイドでより多くの作業が必要ですが、コンフリクトの問題とマッピングの肥大化の問題を同時に解決します。</p>

<h2><a name="#ambiguous-field-lookup">あいまいなフィールドのルックアップ</a></h2>

<p>現在、フィールドの指定には&#8221;short name&#8221;、フルパス、ドキュメントタイプを前につけたフルパスが利用できます。
これらのオプションがあいまいさをもたらしています。
サンプルとして次のマッピングをご覧ください。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>{
</span><span class='line'>  "mappings": {
</span><span class='line'>    "user": {
</span><span class='line'>      "properties": {
</span><span class='line'>        "title": {
</span><span class='line'>          "type": "string"
</span><span class='line'>        }
</span><span class='line'>      }
</span><span class='line'>    },
</span><span class='line'>    "blog": {
</span><span class='line'>      "properties": {
</span><span class='line'>        "title": {
</span><span class='line'>          "type": "string"
</span><span class='line'>        },
</span><span class='line'>        "user": {
</span><span class='line'>          "type": "object",
</span><span class='line'>          "fields": {
</span><span class='line'>            "title": {
</span><span class='line'>              "type": "string"
</span><span class='line'>            }
</span><span class='line'>          }
</span><span class='line'>        }
</span><span class='line'>      }
</span><span class='line'>    }
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<ul>
<li><code>title</code>は<code>user.title</code>、<code>blog.title</code>、<code>blog.user.title</code>のどれでしょう？</li>
<li><code>user.title</code>は<code>user.title</code>または<code>blog.user.title</code>のどちらでしょう？</li>
</ul>


<p>答えは「場合によります。」です。Elasticsearchが最初に見つけたものになります。
フィールドはリクエストごとに変わるため、各ノードでマッピングがどのようにシリアライズされたかに依存します。</p>

<p>2.0では、フィールドを指定する時に、ドキュメントタイプを除いたフルパス名を使用するべきでしょう。</p>

<ul>
<li><code>user.title</code>は、<code>blog</code>タイプの<code>user.title</code>を意味します。</li>
<li><code>title</code>は、<code>user</code>と<code>blog</code>タイプの<code>title</code>フィールドを意味します。</li>
<li><code>*title</code>は<code>user.title</code>と<code>title</code>フィールドの両方にマッチします。</li>
</ul>


<p><code>user</code>タイプの<code>title</code>フィールドと<code>blog</code>タイプの<code>title</code>の違いはどのように指定するのでしょう？</p>

<p>指定できません。<a href="#conflicting-field-mappings">フィールドマッピングのコンフリクト</a>で説明した変更により、
<code>title</code>フィールドは両方のタイプで同じフィールドになります。
本質的に<code>title</code>と呼ばれる1つのフィールドになります。</p>

<p><code>user.</code>や<code>blog.</code>のようなタイプのプレフィックスはタイプを指定することによるフィルタリングで効果があります。
クエリの<code>blog.title</code>フィールドは<code>blog</code>タイプのドキュメントだけを検索し、<code>user</code>タイプのドキュメントを検索しません。
このシンタックスは誤解を招きやすいです。なぜなら、いつでも動作するわけではないからです。
aggregationやsuggestionはすべてのタイプに関する結果を含みます。
この利用のため、上記の例のあいまいさがあるので、タイプのプレフィックスはサポートしません。</p>

<p><strong>重要</strong> short nameやタイププレフィックスを利用したpercolatorは更新する必要があります。</p>

<h2><a name="type-meta-fields">タイプのメタフィールド</a></h2>

<p>すべてのタイプはメタフィールドを持っています。<code>_id</code>、<code>_index</code>、<code>_routing</code>、<code>_parent</code>、<code>_timestamp</code>などです。
これらのほとんどは<code>index</code>、<code>store</code>、<code>path</code>のような幾つかの設定をサポートしています。
これらの設定について次のようにシンプルにしました。</p>

<ul>
<li><code>_id</code>と<code>_type</code>は変更不可</li>
<li><code>_index</code>は、ドキュメントのもつインデックスを保存するために<code>enabled</code></li>
<li><code>_routing</code>は<code>required</code>のみを指定</li>
<li><code>_size</code>は<code>enabled</code>のみ</li>
<li><code>_timestamp</code>はデフォルトで保存される</li>
<li><code>_boost</code>と<code>_analyzer</code>は廃止。古いインデックスのものは無視される</li>
</ul>


<p>ドキュメントのフィールドから<code>_id</code>と<code>_routing</code>と<code>_timestamp</code>の値を抽出することができました。
この機能は廃止されます。これは、ドキュメントのパースとコンフリクトを起こすためです。
代わりに、これらの値はURLもしくはquery stringで指定可能です。</p>

<p><code>_boost</code>と<code>_analyzer</code>フィールドは例外で、すでにあるメタフィールドの設定は古いインデックスのものが採用されます。</p>

<h2><a name="analyzer-settings">アナライザ設定</a></h2>

<p>これまで、indexとsearchのアナライザがインデックス、タイプ、フィールド、ドキュメント（<code>_analyzer</code>フィールドで）の
それぞれのレベルで指定可能でした。
同じフィールドに対して異なるanalysis chainの組み合わせができることにより、おかしな関連度を引き起こしていました。
フィールドマッピングのコンフリクトを解消することに加え、アナライザの設定も簡略化します。</p>

<ul>
<li>Analyzedな文字列フィールドは、<code>analyzer</code>設定と<code>search_analyzer</code>設定（<code>analyzer</code>設定の値をデフォルトとする）を指定できます。<code>index_analyzer</code>設定は<code>analyzer</code>となります。</li>
<li>複数のタイプで同じ名前のフィールドがある場合、フィールドはすべて、同じアナライザの設定を持たなければなりません。</li>
<li>タイプレベルのデフォルト設定の<code>analyzer</code>、<code>index_analyzer</code>、<code>search_analyzer</code>設定は廃止されます。</li>
<li>デフォルトアナライザはインデックスごとにインデックスの<code>analysis</code>設定で設定します。これらは<code>default</code>もしくは<code>default_search</code>という名前で設定します。</li>
<li>ドキュメントごとの<code>_analyzer</code>フィールドはサポートしません。既存のインデックスのものは無視されます。</li>
</ul>


<h2><a name="index_name-and-path"><code>index_name</code>と<code>path</code></a></h2>

<p><code>index_name</code>と<code>path</code>設定は（Elasticsearch v1.0.0から利用できる）<code>copy_to</code>によって置き換わりました。
既存のインデックスについてはこれらは機能しますが、新しいインデックスでは指定できません。</p>

<h2><a name="mapping-update">同期的なマッピングの更新</a></h2>

<p>現在、これまで存在していないフィールドを含むドキュメントをインデキシングするとき、
フィールドはローカルのマッピングに追加され、それから、マスターに変更（新しいマッピングをすべてのシャードに適用する更新）が送信されていました。
同時に2つのシャードに同じフィールドを追加することができます。
また、そのとき、異なる2つのマッピングがある可能性があります。
1つは<code>double</code>でもう1つは<code>long</code>だったり、<code>string</code>と<code>date</code>だったりと。</p>

<p>このような場合、マスターに最初に届いたマッピングが採用されます。
しかし、「負けた」マッピングをもつシャードでは、すでに異なるデータのタイプを利用しているため、
これを利用し続けます。
そのご、ノードをリスタートしたときに、シャードが別のノードに移動し、マスターにあるマッピングを適用します。
このとき、インデックスが破損したりデータを失ったりします。</p>

<p>これを防ぐために、シャードはインデキシングを続ける前に、新しいマッピングがマスターによって採用されるかどうかを待つようになりました。
これはすべてのマッピングが安全に更新されます。
新しいフィールドをもっているドキュメントをインデキシングすると、前よりも処理が遅くなるでしょう。
受け入れられることを待つ必要があるためです。
しかし、クラスタの状態の更新処理のスピードが次の2つの新しい機能によって大きく改善されています。</p>

<ul>
<li><strong>クラスタ状態の差分</strong>：可能であれば、クラスタの状態の変更はクラスタ状態全体の変更ではなく、部分的なものとする。</li>
<li><strong>シャードへのリクエストの非同期化</strong>：シャードアロケーション処理中に、マスタノードは、
割り当てられていないシャードのコピーの日付が最新のものを持っているかを見つけるために、リクエストをデータノードに対して送信します。
ここで、クラスタ状態を変更する呼び出しがブロッキングで行われていました。v1.6.0から、このリクエストはバックグラウンドで非同期で実行されます。
これにより、マッピング更新のようなペンディングタスクをより早く処理できるようになります。</li>
</ul>


<h2><a name="delete-mapping">マッピングの削除</a></h2>

<p>（そのタイプのドキュメントがある場合）タイプマッピングを削除できないようにします。
マッピングを削除した後に、削除されたフィールドの情報は、Luceneレベルでは存在し続け、
もし、後から同じ名前のフィールドが追加されたときにインデックスの破損を引き起こします。
そのようなマッピングは残しておくか、新しいインデックスに再インデックスすることができます。</p>

<h2><a name="prepare-2_0">2.0のための準備</a></h2>

<p>マッピングがコンフリクトしているかどうかを決めることは、手動で行うには慎重に行う必要があります。
私たちは、<a href="https://github.com/elastic/elasticsearch-migration">Elasticsearch Migration Plugin</a>を提供します。
これは、2.0で非推奨になったり廃止された機能を利用しているかどうかを見つけるために役に立つでしょう。</p>

<p>もし、コンフリクトしたマッピングを持っている場合、
正しいマッピングを持つ新しいインデックスにデータを再インデックスするか、
必要ないなら削除します。
これらのコンフリクトを解決しない限り2.0にはアップグレードできないでしょう。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Elasticsearch 2.0.0.beta1リリース間近（日本語訳）]]></title>
    <link href="http://blog.johtani.info/blog/2015/07/07/elasticsearch-2-dot-0-0-dot-beta1-coming-soon-ja/"/>
    <updated>2015-07-07T15:25:00+09:00</updated>
    <id>http://blog.johtani.info/blog/2015/07/07/elasticsearch-2-dot-0-0-dot-beta1-coming-soon-ja</id>
    <content type="html"><![CDATA[<p><strong>※この記事は次のブログを翻訳したものになります。</strong></p>

<p>原文：<a href="https://www.elastic.co/blog/elasticsearch-2.0.0.beta1-coming-soon">Elasticsearch 2.0.0.beta1 coming soon!</a></p>

<p>Elasticsearch 2.0.0.beta1のリリースの準備をしています。
これは、Lucene 5.2.1に含まれる多くの改善が利用できるようになります。
このリリースに関するいくつかの機能は次のようなものです。</p>

<!-- more -->


<h4>Pipeline Aggregations</h4>

<p>差分や移動平均、他のAggregationsの結果に対する
series arithmeticのようなaggregationが利用可能になります。
この機能は、これまでは、クライアントサイドで実行する必要がありました。
しかし、この計算をより強力な解析クエリを構築してElasticsearchで
実行することができるようになります。
クライアントのコードをより簡潔にすることができます。
これにより、予測解析や異常検知のようなことができるようになります。</p>

<h4>Query/Filter merging</h4>

<p>Filterはなくなります。全てのフィルタは、クエリになります。
クエリコンテキストで利用されると、効率的に関連度スコアを計算し、
フィルタコンテキストで利用されると、単に、
マッチしていないドキュメントを除外する（今のフィルタのようなもの）だけです
この変更は、クエリ実行が自動的に、より効率的な順番で実行されるように
最適化されることを意味します。
例えば、フレーズやgeoクエリのような遅いクエリは
まず、近似フェーズを実行し、それから、より遅い実際のフェーズが
結果に対して行われます。
フィルタコンテキストにおいて、頻繁に利用される条件は自動的にキャッシュされます。</p>

<h4>Configurable store compression</h4>

<p><code>index.codec</code>設定により、高速化のためのLZ4圧縮（<code>default</code>）か
インデックスサイズを小さくするためのDEFLATE（<code>best_compression</code>）を
選択できます。これは、ロギングでとくに役に立ちます。
これにより、古いインデックスオプティマイズする前に<code>best_compression</code>に
変更できます。</p>

<p>これらに関するブログ記事がすぐに公開されるでしょう。</p>

<h3>Performance and resilience</h3>

<p>以降では、新しいメジャーリリースに関して簡単に紹介します。
2.0の変更の多くは内部の機能に関するものであり、
直接ユーザに関連するわけではないからです。</p>

<p>新しいメジャーバージョンのテーマは、パフォーマンス、安定性、
堅牢性、予測可能性、そして使い勝手の良さです。</p>

<ul>
<li>物事が予測した通りに動作する</li>
<li>何か問題があった場合に、Elasticsearchから役立つフィードバックがある</li>
<li>ローレベルの設定を扱う必要はなく、Elasticsearchが良い設定を決定する</li>
<li>これらに加え、データがより安全に</li>
</ul>


<p>これらの目標は完全ではありません。
まだ、多くの改善があります。しかし、2.xブランチで、
すでに500コミットを超える大きな改善が実施されています。</p>

<ul>
<li>on-diskの doc valuesをデフォルトで利用（これまではfielddata）。
ヒープ使用量を減らして、スケーラビリティを向上</li>
<li>セグメントマージ処理中のメモリ使用量の削減</li>
<li>normsの圧縮率の改善。ヒープスペースを利用している大きな処理のひとつだったため。</li>
<li>全てのリクエストの後に、transaction logをfsyncすることで、デフォルトで耐久性を向上</li>
<li>全てのファイル変更をアトミックに（部分的なファイルの書き出しはなし）</li>
<li>マージを自動で制限</li>
<li>フレーズクエリやスパンクエリを高速化</li>
<li>フィルタキャッシュをより効率化するための圧縮されたビットセット</li>
<li>クラスタ状態の差分更新</li>
<li>構造化されたJSON形式の例外</li>
<li>よりきめ細かいLuceneのメモリレポート</li>
<li>デフォルトではlocalhostにのみバインド。開発のノードが他のクラスタにジョインするのを防ぐ</li>
<li>parent/childのクエリ実行最適化のためにリライト</li>
<li>Java Security Managerで必要最小限なパーミッションで実行</li>
<li>全てのコアなプラグインをelasticsearchリポジトリに移行し、Elasticsearchのバージョンに同期してリリースされる予定</li>
</ul>


<h2>アップグレード前に</h2>

<p>メジャーバージョンのアップグレードは問題のあるものを一掃する機会を与えてくれます。
できる限り、これらの変更をアップグレードするために、簡単な方法を提供しようとしています。
しかし、Elasticsearch 2.0にアップグレードする前に、必要な処理が2つあります。</p>

<p>1つ目は、フィールドとタイプマッピングに関することです。
mapping APIは、現在、それほど厳密ではありません。
内蔵された保護機構を提供する代わりに、ユーザがベストプラクティスを知っていると信頼していました。
2.0では、mappingはより厳密で安全ですが、いくつかの変更では、後方互換性を保っていません。
詳細については<a href="https://www.elastic.co/blog/great-mapping-refactoring">The Great Mapping Recatoring</a>をごらんください。</p>

<p>2つ目はElasticsearch 0.20以前のユーザに関する変更です。
これは、Lucene 3.xを使っています。
Elasticsearch 2.xはLucene 5をベースにしています。
Lucene 5はLucene 4.xによって作成されたインデックスの読み込みはサポートしていますが、
Lucene 3.xに関してはサポートしていません。</p>

<p>Elasticsearch 0.20以前のバージョンによって生成されたインデックスを持っている場合、
Elasticsearch 2.xのクラスタをスタートすることはできません。
これらの古いインデックスを削除するか、Elaticsearch 1.6.0以上に含まれている
<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/indices-upgrade.html">upgrade API</a>を使用してアップグレードする必要があります。</p>

<p>upgrade APIの実行は2つのジョブを実行します。</p>

<ul>
<li>古いLuceneフォーマットのセグメントを最新のフォーマットで書き換えます</li>
<li>Elasticsearch 2.xによって読み込めるようという印をインデックスに追加します</li>
</ul>


<p>全てのセグメントを最新バージョンにアップグレードするのも良い案ですが、
アップグレード前に必要な処理を最小限に抑えることも可能です。
（Lucene 3.xのセグメントだけをアップグレード）
その場合は、<code>only_ancient_segments</code>パラメータを指定します。</p>

<h2>Elasticsearch Migration Plugin</h2>

<p>Elasticsearch 2.0 に移行する前に、インデックスがアップグレードが必要なのか、
ほかになにかするべきことがあるのかをチェックする助けになる
Elasticsearch Migration Pluginをリリースしました。</p>

<p>まず、プラグインをインストールします</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>./bin/plugin -i elastic/elasticsearch-migration</span></code></pre></td></tr></table></div></figure>


<p>プラグインのインストール後はノードのリスタートは必要ありません。</p>

<p>以下のリンクをブラウザで開きます。</p>

<p><a href="http://localhost:9200/_plugin/migration">http://localhost:9200/_plugin/migration</a></p>

<p>（<code>localhost:9200</code>はインストールしたホスト名に変更してください。）</p>

<p>Migration pluginに関してバグやご意見がある場合は、<a href="http://github.com/elastic/elasticsearch-migration/issues">GitHubのIssue</a>にお願いします。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[さらに進化したFound（日本語訳）]]></title>
    <link href="http://blog.johtani.info/blog/2015/07/07/we-just-made-found-more-awesome-ja/"/>
    <updated>2015-07-07T15:20:00+09:00</updated>
    <id>http://blog.johtani.info/blog/2015/07/07/we-just-made-found-more-awesome-ja</id>
    <content type="html"><![CDATA[<p>4ヶ月前に、<a href="https://www.elastic.co/blog/welcome-found">Found joined our team at Elastic</a>をアナウンスしました。
Foundの素晴らしいチームと一緒に仕事をしていますが、彼らによって、より素晴らしい
hosted Elasticsearchを提供することになりました。</p>

<!-- more -->


<p>私たちがともに密接に働くことにより、本日（2015/7/1）、
<a href="https://www.elastic.co/products/found">新しい2つのFound</a>を提供することになりました。
Found StandardはこれまでのFoundの機能に加え、さらに低価格を提供します。
Found Premiumは、SLAサポートと、ShieldやWatcherを将来Found上で提供します。</p>

<h2>Found Standard</h2>

<p>Foundは素晴らしいです。専用のElasticsearchクラスタ、簡単なスケール、
ビルトインのセキュリティそして、時間単位での課金などを持っています。
私たちは、hosted Elasticsearchを探している方に、
Foundが適したソリューションであると思っていますし、
すべての方に利用できて手頃な価格であるということを確信したいと思っています。</p>

<p>本日（2015/07/01）からFoundの価格をかなり低価格にし、
<strong>月額50ドル以下</strong>でhosted Elasticsearchを簡単に試してもらえるようにしました。</p>

<p>価格を下げることは正しい重要なステップですが、
Foundを利用している全ての人に、より良い経験を持っていただきたいと考えています。
低価格化と一緒に、<strong>free backups</strong>と<strong>built in SSD</strong>もFoundで提供を始めることになります。</p>

<p>Foundの重要な特徴の一つが、高可用性のために、クラスタをいくつのデータセンターに持つかを
選択できることです。
データは重要です。これが正しい選択でユーザの助けになると考えています。
これにより、私たちの価格は、<strong>複数のデータセンターにより安価に</strong>配置することができます。</p>

<p>また、KibanaもElasticsearchのデータを可視化する素晴らしい方法だと考えています。
Kibana 4が最新バージョンですが、
これは、サーバサイドコンポーネントを持っています。
これは、サービスとしてこれを提供するために、追加の料金がかかることを意味します。
Foundチームが築いた素晴らしい基盤とKibanaチームの努力により、
hosted Elasticsearchクラスタで<strong>無料のKibana 4</strong>を7月15日より提供することになりました。</p>

<h2>Found Premium</h2>

<p>また、私たちは、オープンソースプロダクトに関してサブスクリプションを提供していますが、
Found Standardに対しても提供することになりました。
これが、Found Premiumです。</p>

<p>フォーラムベースのサポートよりもSLAベースのサポートを望んでいる場合、
プロダクトを開発しているチームからのサポートを受けることができるオプションを
提供し始めました。
クリティカルなイベントを持っていたり、私たちのプロダクトに関する
問題を予測するためのベストなヘルプやガイダンス、アドバイスを探しているような場合にサポートします。</p>

<p>さらに近い将来、サブスクリプションの一部として、<a href="https://www.elastic.co/products/shield">Shield</a>（Elasticasearchのセキュリティプラグイン）や<a href="https://www.elastic.co/products/watcher">Watcher</a>（アラーティングプラグイン）が利用できるようになります。</p>

<p>私たちのチームがともに働き、多くのことを可能にし、すばらしい仕事をユーザに提供したかを
将来も楽しみです。
私は非常に誇りに思っていますし、気に入っていただけたらと思っています。
ぜひ、<a href="https://www.elastic.co/webinars/getting-started-with-found">7/15のWebnarに参加して</a>くわしい話を聞いていただき、疑問を解消してください。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JustTechTalk#02 形態素解析のあれやこれや@ジャストシステムに参加しました。]]></title>
    <link href="http://blog.johtani.info/blog/2015/07/06/attend-justsystem-techtalk-no2/"/>
    <updated>2015-07-06T10:49:01+09:00</updated>
    <id>http://blog.johtani.info/blog/2015/07/06/attend-justsystem-techtalk-no2</id>
    <content type="html"><![CDATA[<p><a href="https://justsystems.doorkeeper.jp/events/27174">JustTechTalk#02 形態素解析のあれやこれや@ジャストシステム</a></p>

<p>に参加してきました。
ジャストシステムさんの形態素解析器JMATの話とKagome、Janome、Kuromoji.js、ssslaの開発者の
パネルディスカッションでした。</p>

<p>ということで、いつものメモです。</p>

<!-- more -->


<h2>ジャストシステムの形態素解析その２（機械学習編）</h2>

<ul>
<li><p>JMATの話</p>

<ul>
<li>前回は辞書の話</li>
<li>今回は学習の話</li>
</ul>
</li>
<li><p>教師あり/教師なし</p>

<ul>
<li>JMATは教師あり</li>
<li>教師なしは研究段階</li>
</ul>
</li>
<li><p>ラティス構造を辞書ベースで構築して、コストの総和が最小の経路を求める</p>

<ul>
<li>連接、単語生成とか。</li>
</ul>
</li>
<li>学習は3フェーズ

<ul>
<li>ベース、能動、部分アノテーション</li>
<li>ベース

<ul>
<li>300万文のコーパスから1万文のみを利用（なぜ？今から説明）

<ul>
<li>64GBマシン買ってみたけど、複数実験するには追いつかない</li>
<li>オンライン学習がメジャーでない時代に作り始めたので、つかってない</li>
<li>CRF学習器を改善

<ul>
<li>結果として50万文くらいで精度が良くなる</li>
</ul>
</li>
</ul>
</li>
<li>辞書チームからNGがでて、方向転換</li>
</ul>
</li>
<li>方向転換した結果が3つのフェーズらしい</li>
<li>ピタジョブに採用？</li>
</ul>
</li>
</ul>


<h3>疑問</h3>

<ul>
<li>JMATって、Webの検索の前処理とか分類とかに主に利用するのかな？</li>
<li>ATOKでもこのノウハウって利用してるんかな？</li>
<li>辞書もあるらしいけど、辞書更新されると学習器のデータとかどーなるんだろ？</li>
</ul>


<h2>形態素解析器の実装言語Talkについて</h2>

<ul>
<li>kuromoji.jsの@takuya_aさん

<ul>
<li>Typed Arrayサポートが高速にできてる理由でもあるらしい</li>
</ul>
</li>
<li>Kagomeの@ikawahaさん

<ul>
<li>Goはいろいろないらしい</li>
</ul>
</li>
<li>Janomeの@moco_betaさん</li>
<li><p>sssla（茶筌のRuby clone）</p></li>
<li><p>なんで作ったの？</p>

<ul>
<li>形態素解析の<strike>ライブラリ</strike>「解析部分」はNLPのHelloWorldだから</li>
</ul>
</li>
<li>なんで、その言語？

<ul>
<li>Python 3系は文字列とバイト配列の扱いがすごく楽！</li>
</ul>
</li>
<li>その言語で困った点は？

<ul>
<li>Goだと、辞書を内包するのが大変</li>
<li>JSは苦労したところしかない（1hくらいしゃべれるぞ！）。基本的なデータ構造とかもない</li>
<li>Pythonはパフォーマンスを考えないと</li>
<li>Ruby（1.6だったので）もパフォーマンスが</li>
</ul>
</li>
<li><p>その言語を開発するときに必須のものは？</p>

<ul>
<li>Goはとくにない。エディタはどれでもOK</li>
<li><a href="http://browserify.org/">browserify</a>が便利</li>
</ul>
</li>
<li><p>ほかの人たちの言語をdisってください</p>

<ul>
<li>JSは論外。Pythonのコードフォーマッターが揺れるのが。。。Rubyはバージョンが。。。</li>
<li>Goはブラウザで動かない。Pythonもブラウザで動かない。Rubyも(ry</li>
<li>ほかのは触ったことないので。。。</li>
<li>Pythonは2.xか3.xか決めてくれ！</li>
</ul>
</li>
<li>なんで、Kuromojiベースなの？

<ul>
<li>Java読みやすいから。</li>
</ul>
</li>
<li>MeCabとKuromojiの違いは？

<ul>
<li>未知語の処理が結構違う</li>
</ul>
</li>
</ul>


<h2>感想</h2>

<p>きれいなロビーで良かったのですが、マイクがあると嬉しかったかもしれません。
前回の辞書の話も聞いてみたかったかも。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Hatena Engineer Seminar #5 @ Tokyoに参加しました。 #hatenatech]]></title>
    <link href="http://blog.johtani.info/blog/2015/06/17/attend-hatena-engineer-seminar-5/"/>
    <updated>2015-06-17T00:21:33+09:00</updated>
    <id>http://blog.johtani.info/blog/2015/06/17/attend-hatena-engineer-seminar-5</id>
    <content type="html"><![CDATA[<p>ひさびさに、勉強会メモ。
<a href="http://hatena.connpass.com/event/15973/">Hatena Engineer Seminar #5 @ Tokyo</a>に当選したので行ってきました。</p>

<p>いつもは近寄らないオシャレな街をドキドキしながら行ってきました。</p>

<!-- more -->


<p>ということで、簡単なメモです。</p>

<h2>はてなブックマーク全文検索の精度改善 id:takuya-a</h2>

<h3>問題：検索精度がよくない</h3>

<ul>
<li>京都で検索 →　「ポーランドの京都」「京都大学のまるまる教授」のようなもんがヒット</li>
<li>京都っぽいエントリが出て欲しい。

<ul>
<li>京都っぽい？？？</li>
</ul>
</li>
<li>問題点をブレイクダウン

<h4>課題</h4></li>
<li>クエリ考えるの大変だよね</li>
<li>順序が新着順なのが辛い</li>
<li>適合率と再現率の両立</li>
</ul>


<p>そして（ドラムロール）、できました！（さすが）</p>

<p>アイデア：はてブのタグを利用する。
関連キーワードを抽出して、クエリ拡張する。</p>

<h3>関連キーワードとは？</h3>

<ol>
<li>タグ検索する</li>
<li>検索にヒットしたTerm Vectorsを取得</li>
<li>特徴語をTop25件取得</li>
<li>もっともスコアが高いタームを特徴語とする

<ul>
<li>英語のストップワードとかが問題点となってたり。</li>
<li>→Dynamic stop word listというのを利用して排除（IDF、RIDF、Gain）</li>
</ul>
</li>
</ol>


<h3>今後の課題</h3>

<ul>
<li>再現率の向上</li>
<li>解析用のフィールド・辞書を追加（精度向上や解析ミスなど）</li>
</ul>


<h3>トークに出てきた機能など</h3>

<p>トークに出てきたElasticsearchの機能については、こんなツイートをしてたので、参考にしてもらえれば。</p>

<blockquote class="twitter-tweet" lang="ja"><p lang="ja" dir="ltr">これのkuromoji_stemmerを使ってるっぽい？ <a href="https://twitter.com/hashtag/hatenatech?src=hash">#hatenatech</a> / elastic/elasticsearch-analysis-kuromoji - <a href="https://t.co/3F2sBYXLPH">https://t.co/3F2sBYXLPH</a></p>&mdash; Jun Ohtani (@johtani) <a href="https://twitter.com/johtani/status/610759870564859904">2015, 6月 16</a></blockquote>


<p> <script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script></p>

<blockquote class="twitter-tweet" lang="ja"><p lang="ja" dir="ltr"><a href="https://twitter.com/hashtag/hatenatech?src=hash">#hatenatech</a> Term Vectors APIのドキュメントはこちら - <a href="https://t.co/HhBmTDr46i">https://t.co/HhBmTDr46i</a></p>&mdash; Jun Ohtani (@johtani) <a href="https://twitter.com/johtani/status/610760840170450944">2015, 6月 16</a></blockquote>


<p> <script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script></p>

<blockquote class="twitter-tweet" lang="ja"><p lang="it" dir="ltr"><a href="https://twitter.com/hashtag/hatenatech?src=hash">#hatenatech</a> min_score - <a href="https://t.co/Sc0exzJRC1">https://t.co/Sc0exzJRC1</a></p>&mdash; Jun Ohtani (@johtani) <a href="https://twitter.com/johtani/status/610763959944097793">2015, 6月 16</a></blockquote>


<p> <script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script></p>

<h4>個人的な疑問</h4>

<p>Q：クエリにヒットするタグがそもそもなかったら？</p>

<h2>はてなブックマークに基づく関連記事レコメンドエンジンの開発 id:skozawa</h2>

<h3>課題：一部のエントリに対して関連記事が出ない</h3>

<p>タグがない記事について関連エントリが出ない＝既存はタグを利用している
例：レシピで考える</p>

<h4>現行システム</h4>

<ul>
<li>ユーザがつけたタグ情報を利用してMoreLikeThisで計算</li>
</ul>


<h4>新規システム</h4>

<ol>
<li>類似記事検索</li>
<li>特徴語の抽出</li>
<li>特徴語を分類</li>
<li>関連記事検索</li>
<li>関連記事をスコアリング</li>
</ol>


<h4>個人的な疑問</h4>

<p>Q：毎回計算してるのかな？記事登録とかされたタイミングでやってるのかな？
Q：Termの精度などどうなんだろ？</p>

<h2>『BrandSafe はてな』のアドベリフィケーションのしくみ id:tarao</h2>

<p>BrandSafeはてな：とか。
広告の配信先をフィルタリング</p>

<p>複数の素朴なフィルタの組み合わせ→AdaBoost</p>

<h4>個人的な疑問</h4>

<p>Q：海外とかもいけるのかな？</p>

<h2>まとめと感想</h2>

<p>ということで、簡単なメモでした。ピザごちそうさまでした！
聞いてて少し思ったのは、データ量があるサイトだからうまくいく手法だというのもあるんだろうなというところでした。
あとは、クエリを暗に改善するのとは別に、サジェスト的に表示するのにも使えたりするかも？と思ってみたり。
できるかどうかはわからないですが。。。</p>

<p>Elasticsearchをいろいろと活用してもらってるのがわかって、楽しい勉強会でした。
もっともっといろんなところで宣伝してくださいw</p>

<p>今日の勉強会を聞いて、俄然、京都・大阪でElasticsearch勉強会を開催したい気になってきました。
特に大阪に知り合いがいないので、だれか紹介してもらえると嬉しいです。
お待ちしてます。</p>
]]></content>
  </entry>
  
</feed>
