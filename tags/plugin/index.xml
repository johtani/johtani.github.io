<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>plugin on @johtaniの日記 3rd</title>
    <link>https://blog.johtani.info/tags/plugin/</link>
    <description>Recent content in plugin on @johtaniの日記 3rd</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja</language>
    <lastBuildDate>Fri, 20 Apr 2018 15:30:01 +0900</lastBuildDate><atom:link href="https://blog.johtani.info/tags/plugin/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Analyze UIとKibanaのプラグインの作成方法（第3回）</title>
      <link>https://blog.johtani.info/blog/2018/04/20/directory-layout-and-architecture/</link>
      <pubDate>Fri, 20 Apr 2018 15:30:01 +0900</pubDate>
      
      <guid>https://blog.johtani.info/blog/2018/04/20/directory-layout-and-architecture/</guid>
      <description>第2回から少し間が空いてしまいましたが、templateで作成したプラグインのディレクトリ構成とどういう流れでデータがやり取りされるかについ</description>
      <content:encoded><p><a href="http://blog.johtani.info/blog/2018/02/09/getting-started-template-kibana-plugin/">第2回</a>から少し間が空いてしまいましたが、templateで作成したプラグインのディレクトリ構成とどういう流れでデータがやり取りされるかについてみていきます。
（2018/02月時点で作成したディレクトリ構成にしたがって説明します）
ちなみに、JavaScriptの優れた開発者ではないので、誤解している点や、効率の悪い書き方などがあるかもしれません。見つけた場合は、連絡をいただければと思います。</p>
<!-- more -->
<p>では、まずは作成したディレクトリ構成についてみていきましょう。</p>
<h2 id="ディレクトリ構成">ディレクトリ構成</h2>
<p><code>simple-sample-kibana-plugin</code>がプラグインのプロジェクトのトップディレクトリになります。このディレクトリに次のような構成でサブディレクトリが存在します(なお、画像はIntelliJに取り込んだ後のディレクトリになっているので、<code>.iml</code>など、不要なファイル/ディレクトリが存在しています)。</p>

<link rel="stylesheet" href="/css/hugo-easy-gallery.css" />
<div class="box" style="max-width:400">
  <figure  itemprop="associatedMedia" itemscope itemtype="http://schema.org/ImageObject">
    <div class="img">
      <img itemprop="thumbnail" src="/images/entries/20180420/directories.jpg" />
    </div>
    <a href="/images/entries/20180420/directories.jpg" itemprop="contentUrl"></a>
  </figure>
</div>

<p>主要なディレクトリ、ファイルについて簡単に一覧で説明します(順不同)。</p>
<table>
<thead>
<tr>
<th>ファイル/ディレクトリ名</th>
<th>説明</th>
</tr>
</thead>
<tbody>
<tr>
<td>index.js</td>
<td>プラグインの本体。Kibanaはこのファイルのオブジェクトを読み込みプラグインを起動。設定などの読み込みもこちら。</td>
</tr>
<tr>
<td>package.json</td>
<td>npm/yarnのパッケージに関する情報を定義するファイル</td>
</tr>
<tr>
<td>README.md</td>
<td>README。プラグインの説明などを記載する。インストール方法なども記載すると便利</td>
</tr>
<tr>
<td>public</td>
<td>ブラウザ側に配布されるプログラムや画像一式</td>
</tr>
<tr>
<td>public/less/main.less</td>
<td>LESS用のファイル。アプリ固有のスタイルなどを記載</td>
</tr>
<tr>
<td>public/app.js</td>
<td>ブラウザ側で読み込まれるプラグインのモジュールなど。</td>
</tr>
<tr>
<td>public/template/index.html</td>
<td>HTMLのテンプレート。ブラウザ上での描画に利用</td>
</tr>
<tr>
<td>server/routes</td>
<td>Kibanaサーバー側で動作するプラグイン。hapi.jsを利用してREST APIを実装する</td>
</tr>
</tbody>
</table>
<p>重要なファイルについて少しだけ説明します。</p>
<h4 id="packagejson">package.json</h4>
<p>npmやyarnでビルドなどをするときに使用するパッケージ情報を記載するためのファイルです。
プラグインの名前、バージョン、説明などを記載します。
Kibanaのバージョンについてもこちらで管理します。この情報を
また、ライブラリなどの依存関係についてもこちらで記載しています。
以下、抜粋。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-json" data-lang="json">{
  <span style="color:#f92672">&#34;name&#34;</span>: <span style="color:#e6db74">&#34;simple-sample-kibana-plugin&#34;</span>,
  <span style="color:#f92672">&#34;version&#34;</span>: <span style="color:#e6db74">&#34;0.0.0&#34;</span>,
  <span style="color:#f92672">&#34;description&#34;</span>: <span style="color:#e6db74">&#34;Sample plugin for explaining how to make kibana app&#34;</span>,
  <span style="color:#f92672">&#34;main&#34;</span>: <span style="color:#e6db74">&#34;index.js&#34;</span>,
  <span style="color:#f92672">&#34;kibana&#34;</span>: {
    <span style="color:#f92672">&#34;version&#34;</span>: <span style="color:#e6db74">&#34;6.2.1&#34;</span>,
    <span style="color:#f92672">&#34;templateVersion&#34;</span>: <span style="color:#e6db74">&#34;7.2.4&#34;</span>
  },
  <span style="color:#f92672">&#34;scripts&#34;</span>: {
    <span style="color:#f92672">&#34;lint&#34;</span>: <span style="color:#e6db74">&#34;eslint **/*.js&#34;</span>,
<span style="color:#960050;background-color:#1e0010">...</span>
  },
  <span style="color:#f92672">&#34;devDependencies&#34;</span>: {
    <span style="color:#f92672">&#34;@elastic/eslint-config-kibana&#34;</span>: <span style="color:#e6db74">&#34;^0.14.0&#34;</span>,
    <span style="color:#f92672">&#34;@elastic/eslint-import-resolver-kibana&#34;</span>: <span style="color:#e6db74">&#34;^0.9.0&#34;</span>,
    <span style="color:#f92672">&#34;@elastic/plugin-helpers&#34;</span>: <span style="color:#e6db74">&#34;^7.1.3&#34;</span>,
<span style="color:#960050;background-color:#1e0010">...</span>
    <span style="color:#f92672">&#34;expect.js&#34;</span>: <span style="color:#e6db74">&#34;^0.3.1&#34;</span>
  }
}
</code></pre></div><p>ちなみに私は、<code>version</code>などをリリースするたびに変更しています。</p>
<h4 id="indexjs">index.js</h4>
<p>最初にKibanaに読み込まれるオブジェクトになります。
Kibanaのアプリの名前や、必要なモジュールなどを記載します。</p>
<p>また、<code>kibana.yml</code>から設定など読み込む処理なども書くことができます。</p>
<p>2行目の<code>exampleRoute</code>はサーバー側のAPIとして利用するhapi.js用のファイルのパスになります。</p>
<p><code>uiExports</code>はこのアプリの画面に関する設定などの記載になります。
<code>app</code>の部分が実際にアプリの情報で、
<code>main</code>があとで説明するこのプラグインのUIのためのJavaScriptファイル(public/app.js)になります。mainですので、最初に読み込まれる処理が記載されているものを指定します。<code>app.js</code>というファイル名を変更する場合は、こちらの<code>app</code>の部分を変更したファイルに合わせましょう。</p>
<p><code>config(Joi)</code>の関数が設定ファイルの読み込みなどの処理を記載する場所です。</p>
<p><code>init(server, options)</code>の関数が初期化処理を記載する場所になります。
このサンプルアプリでは、2行目の<code>import</code>で読み込んだhapi.js用のファイルの関数を呼び出しています。引数で渡している<code>server</code>がhapi.jsの<code>server</code>オブジェクトになります。
<code>route</code>メソッドを使用して作成しているプラグイン用のREST APIを追加しています。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">import</span> { <span style="color:#a6e22e">resolve</span> } <span style="color:#a6e22e">from</span> <span style="color:#e6db74">&#39;path&#39;</span>;
<span style="color:#66d9ef">import</span> <span style="color:#a6e22e">exampleRoute</span> <span style="color:#a6e22e">from</span> <span style="color:#e6db74">&#39;./server/routes/example&#39;</span>;

<span style="color:#66d9ef">export</span> <span style="color:#66d9ef">default</span> <span style="color:#66d9ef">function</span> (<span style="color:#a6e22e">kibana</span>) {
  <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">kibana</span>.<span style="color:#a6e22e">Plugin</span>({
    <span style="color:#a6e22e">require</span><span style="color:#f92672">:</span> [<span style="color:#e6db74">&#39;elasticsearch&#39;</span>],
    <span style="color:#a6e22e">name</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#39;simple-sample-kibana-plugin&#39;</span>,
    <span style="color:#a6e22e">uiExports</span><span style="color:#f92672">:</span> {

      <span style="color:#a6e22e">app</span><span style="color:#f92672">:</span> {
        <span style="color:#a6e22e">title</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#39;Simple Sample Kibana Plugin&#39;</span>,
        <span style="color:#a6e22e">description</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#39;Sample plugin for explaining how to make kibana app&#39;</span>,
        <span style="color:#a6e22e">main</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#39;plugins/simple-sample-kibana-plugin/app&#39;</span>
      },

...
    },

    <span style="color:#a6e22e">config</span>(<span style="color:#a6e22e">Joi</span>) {
      <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">Joi</span>.<span style="color:#a6e22e">object</span>({
        <span style="color:#a6e22e">enabled</span><span style="color:#f92672">:</span> <span style="color:#a6e22e">Joi</span>.<span style="color:#66d9ef">boolean</span>().<span style="color:#66d9ef">default</span>(<span style="color:#66d9ef">true</span>),
      }).<span style="color:#66d9ef">default</span>();
    },

    <span style="color:#a6e22e">init</span>(<span style="color:#a6e22e">server</span>, <span style="color:#a6e22e">options</span>) {
      <span style="color:#75715e">// Add server routes and initialize the plugin here
</span><span style="color:#75715e"></span>      <span style="color:#a6e22e">exampleRoute</span>(<span style="color:#a6e22e">server</span>);
    }
  });
};

</code></pre></div><h4 id="publicappjs">public/app.js</h4>
<p>画面用のモジュールです。
<code>uiRoutes</code>という機能を使用して、アプリの呼び出しURLを定義します。テンプレートで作成したばかりの場合は、<code>/</code>というURLが追加されるのみです。</p>
<p>実際に画面を表示する際に動くコントローラーの部分はその下の
<code>uiModules.controller</code>に指定してあるfunctionが画面描画の
処理を書く部分になります。
templateで作成したプラグインでは、&ldquo;title&quot;など表示に必要なデータを<code>$scope</code>というオブジェクトに詰め込んでいます。
これはAngularJS(1系)でのモデルオブジェクトになります。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">import</span> <span style="color:#a6e22e">moment</span> <span style="color:#a6e22e">from</span> <span style="color:#e6db74">&#39;moment&#39;</span>;
<span style="color:#66d9ef">import</span> { <span style="color:#a6e22e">uiModules</span> } <span style="color:#a6e22e">from</span> <span style="color:#e6db74">&#39;ui/modules&#39;</span>;
<span style="color:#66d9ef">import</span> <span style="color:#a6e22e">uiRoutes</span> <span style="color:#a6e22e">from</span> <span style="color:#e6db74">&#39;ui/routes&#39;</span>;

<span style="color:#66d9ef">import</span> <span style="color:#e6db74">&#39;ui/autoload/styles&#39;</span>;
<span style="color:#66d9ef">import</span> <span style="color:#e6db74">&#39;./less/main.less&#39;</span>;
<span style="color:#66d9ef">import</span> <span style="color:#a6e22e">template</span> <span style="color:#a6e22e">from</span> <span style="color:#e6db74">&#39;./templates/index.html&#39;</span>;

<span style="color:#a6e22e">uiRoutes</span>.<span style="color:#a6e22e">enable</span>();
<span style="color:#a6e22e">uiRoutes</span>
  .<span style="color:#a6e22e">when</span>(<span style="color:#e6db74">&#39;/&#39;</span>, {
    <span style="color:#a6e22e">template</span>,
    <span style="color:#a6e22e">resolve</span><span style="color:#f92672">:</span> {
...
    }
  });

<span style="color:#a6e22e">uiModules</span>
  .<span style="color:#a6e22e">get</span>(<span style="color:#e6db74">&#39;app/simple-sample-kibana-plugin&#39;</span>, [])
  .<span style="color:#a6e22e">controller</span>(<span style="color:#e6db74">&#39;simpleSampleKibanaPluginHelloWorld&#39;</span>, <span style="color:#66d9ef">function</span> (<span style="color:#a6e22e">$scope</span>, <span style="color:#a6e22e">$route</span>, <span style="color:#a6e22e">$interval</span>) {
    <span style="color:#a6e22e">$scope</span>.<span style="color:#a6e22e">title</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;Simple Sample Kibana Plugin&#39;</span>;
    <span style="color:#a6e22e">$scope</span>.<span style="color:#a6e22e">description</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;Sample plugin for explaining how to make kibana app&#39;</span>;
...
    <span style="color:#a6e22e">$scope</span>.<span style="color:#a6e22e">$watch</span>(<span style="color:#e6db74">&#39;$destroy&#39;</span>, <span style="color:#a6e22e">unsubscribe</span>);
  });

</code></pre></div><h4 id="serverroutesexamplejs">server/routes/example.js</h4>
<p><a href="https://hapijs.com">hapi.js</a>というNode.jsのためのサーバーフレームワークです。
このフレームワークをKibanaは使っており、Kibanaのサーバーとブラウザとのやり取りに使用するREST APIを記述するために使用しています。
例えば、Elasticsearchとのやり取りを実際に行うAPIなどをこのREST API内部で記述します。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">export</span> <span style="color:#66d9ef">default</span> <span style="color:#66d9ef">function</span> (<span style="color:#a6e22e">server</span>) {

  <span style="color:#a6e22e">server</span>.<span style="color:#a6e22e">route</span>({
    <span style="color:#a6e22e">path</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#39;/api/simple-sample-kibana-plugin/example&#39;</span>,
    <span style="color:#a6e22e">method</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#39;GET&#39;</span>,
    <span style="color:#a6e22e">handler</span>(<span style="color:#a6e22e">req</span>, <span style="color:#a6e22e">reply</span>) {
      <span style="color:#a6e22e">reply</span>({ <span style="color:#a6e22e">time</span><span style="color:#f92672">:</span> (<span style="color:#66d9ef">new</span> Date()).<span style="color:#a6e22e">toISOString</span>() });
    }
  });

}
</code></pre></div><p><code>path</code>の部分がブラウザ側からアクセスするURLになります。
実際にElasticsearchとやり取りする処理の書き方については、次回の記事で説明します。</p>
<h2 id="アーキテクチャ簡易版">アーキテクチャ（簡易版）</h2>
<p>ざっくりですが、ファイルやディレクトリについて説明しました。
簡単なデータのやり取りについての流れを説明します。</p>
<p>Kibana自体はNode.jsで実装されサーバーとして動作していますが、ブラウザでアクセスすることで画面を描画しています。
簡単なコンポーネントを並べるとデータのやり取りはこのような形です。</p>


<div class="box" style="max-width:600">
  <figure  itemprop="associatedMedia" itemscope itemtype="http://schema.org/ImageObject">
    <div class="img">
      <img itemprop="thumbnail" src="/images/entries/20180420/architecture.jpg" />
    </div>
    <a href="/images/entries/20180420/architecture.jpg" itemprop="contentUrl"></a>
  </figure>
</div>

<p>すごく簡易で大雑把な絵ですが。。。</p>
<p>実際のプラグインとしては大きく、2つの処理があります。</p>
<ul>
<li>ブラウザ上の処理
<ul>
<li>クリックなどのイベント処理</li>
<li>HTMLなどのレンダリング処理</li>
</ul>
</li>
<li>Kibanaサーバー上の処理(Elasticsearchなどとの通信が必要な場合)
<ul>
<li>外部との通信処理</li>
<li>ブラウザ上では重い処理</li>
</ul>
</li>
</ul>
<p>絵に記載しましたが、ブラウザ上の処理についてはAngularJSが主なフレームワークで、サーバー上の処理についてはhapi.jsがフレームワークとなっています。</p>
<h2 id="まとめ">まとめ</h2>
<p>ということで、今回はディレクトリ構造とファイルの説明、どういったフレームワークが使われ、データのやり取りがどのように行われているか説明しました。</p>
<p>次回からは、実際に私が作成した<a href="https://github.com/johtani/analyze-api-ui-plugin">Analyze UI</a>を元にElasticsearchとのデータのやり取りなどについて紹介していきます。</p>
</content:encoded>
    </item>
    
    <item>
      <title>Analyze UIとKibanaのプラグインの作成方法（第2回）</title>
      <link>https://blog.johtani.info/blog/2018/02/09/getting-started-template-kibana-plugin/</link>
      <pubDate>Fri, 09 Feb 2018 18:17:37 +0900</pubDate>
      
      <guid>https://blog.johtani.info/blog/2018/02/09/getting-started-template-kibana-plugin/</guid>
      <description>第1回では、Analyze UIというプラグインの紹介をしました、ごく簡単にですが。 第2回では、Kibanaのプラグインの作成方法を順を追って</description>
      <content:encoded><p>第1回では、<a href="https://github.com/johtani/analyze-api-ui-plugin">Analyze UIというプラグイン</a>の紹介をしました、ごく簡単にですが。</p>
<p>第2回では、Kibanaのプラグインの作成方法を順を追って見ていこうと思います。今回は、プラグインのプロジェクトの作り方を説明します。
どんなファイルがあるのかなどについては第3回で説明します（2018/02月現在の方法になります。残念ながら、Kibanaのプラグイン作成自体はまだExperimentalな話になっていますので、変更がある可能性があります）。</p>
<!-- more -->
<p>実はそれほど難しいというわけではありません。Kibanaのプラグインを作成するためのテンプレートが用意されています。<a href="https://github.com/elastic/template-kibana-plugin/">template-kiban-plugin</a>です。
テンプレートのリポジトリのREADMEに作業手順の記載があります。</p>
<ol>
<li>KibanaのリポジトリをClone、Checkout</li>
<li>Node.jsの環境を用意する</li>
<li>Kibanaを起動できるようにする</li>
<li>SAOのインストール</li>
<li>テンプレートによるプロジェクトファイルの生成</li>
</ol>
<p>順を追って説明します。
<code>PLUGIN_DEV_DIR</code>というディレクトリ配下で作業をしている想定になります。</p>
<h2 id="1-kibanaのリポジトリをclonecheckout">1. KibanaのリポジトリをClone、Checkout</h2>
<p>開発環境として、Kibanaが必要です。Kibanaのプラグインを作るので。
手順などは<a href="https://github.com/elastic/kibana/blob/6.2/CONTRIBUTING.md#contributing-code">KibanaのCONTRIBUTING.md</a>に記載があります。
ということで、まずはKibanaのリポジトリをCloneします。</p>
<pre><code>cd PLUGIN_DEV_DIR
git clone git@github.com:elastic/kibana.git
</code></pre><p>このままだと、masterブランチなので、開発したい対象のKibanaのバージョンのブランチもしくはタグをcloneします。今回は6.2.1向けということで、次のようになります。</p>
<pre><code>git checkout v6.2.1
</code></pre><p>これで、ソースが6.2.1向けになりました。</p>
<h2 id="2-nodejsの環境を用意する">2. Node.jsの環境を用意する</h2>
<p>Node.jsをインストールします。
Kibanaのリポジトリに<code>.node-version</code>というファイルがあります。
こちらにNode.jsのバージョンが記載されています。
Kibanaが使用しているNode.jsを利用できるようにします。ローカルでは<a href="https://github.com/creationix/nvm#installation">nvm</a>利用してインストールしました。後から、切り替えが可能だからです。
nvm自体のインストールについては<a href="https://github.com/creationix/nvm">nvmのサイト</a>をご覧ください。
nvmがインストールできたら、次のコマンドで、Kibanaが使用しているバージョンをインストールします。</p>
<pre><code>cd kibana
nvm install &quot;$(cat .node-version)&quot;
</code></pre><p>すでにnvmを利用している場合などは、Kibana起動時にKibanaのバージョンに合わせたNode.jsに切り替えるようにしてください。</p>
<h2 id="3-kibanaを起動できるようにする">3. Kibanaを起動できるようにする</h2>
<p>Kibanaでは<a href="https://yarnpkg.com/lang/en/">yarn</a>というjavascript向けのパッケージマネージャーを利用して起動やビルドなどを行います。まずはyarnをインストールします。<a href="https://github.com/elastic/kibana/pull/15485">最近npmからyarnに切り替えた</a>ようです。
私はMacだったので、<a href="https://yarnpkg.com/en/docs/install">brewでインストール</a>しました。
インストールできたら、次のコマンドを実行します。</p>
<pre><code>yarn
</code></pre><p>これにより、package.jsonから必要なライブラリなどをダウンロードして来てくれます。
問題なければ「✨  Done in 439.30s.」というような表示がされます（結構時間かかりますね）。
では、Kibanaを起動できるか確認してみましょう。
さらに、Elasticsearchも起動してみます。
Kibanaのpackage.jsonの中にはElasticsearchを起動するためのスクリプトも用意されています。実際には<a href="https://gruntjs.com">grunt</a>を利用してタスクを実行しているようです。Elasticsearchの起動にはJavaが必要になります。
今回は6.2.1なので、JDK 8以降がインストールされている必要があります。
こちらはインストールされているものとします。</p>
<pre><code>yarn elasticsearch
</code></pre><p>で起動できます。</p>
<pre><code>&gt;&gt; Started 1 Elasticsearch nodes.
</code></pre><p>という表示が出てればOKです。
次にKibanaです。別のTerminalを起動して、以下のコマンドで起動できます。</p>
<pre><code>yarn start
</code></pre><p>これだけです。</p>
<pre><code>server    log   [06:58:56.930] [info][listening] Server running at http://localhost:5603
</code></pre><p>この辺りが出てればKibanaのServerは起動済みです。また、Elasticsearchに接続できていれば、次のログが出ているはずです。</p>
<pre><code>server    log   [07:02:18.010] [info][status][plugin:elasticsearch@6.2.1] Status changed from red to green - Ready
</code></pre><p>Elasticsearch接続用のKibanaのプラグインの状態になります。
これで、Kibanaの環境が整ったことが確認できました。
もちろん、Elasticsearchに関しては、yarnで起動せずに、tar.gzなどでダウンロードして来たElasticsearchを起動しておき、アクセスするといったことも可能です。プラグインなどをElasticsearchにもいれてテストしたい場合などはそちらの方が便利かもしれません。</p>
<h2 id="4-saoのインストール">4. SAOのインストール</h2>
<p>では、一度、ElasticsearchとKibanaを停止しましょう。フォワグラウンドで起動しているので、それぞれのTerminalでCtrl+Cで停止できます。
Kibanaのプラグイン作成むけに、テンプレートが作られています。<a href="https://sao.js.org">sao.js</a>というGitHubのリポジトリやnpmのパッケージをテンプレートとして使うことができるツールを利用してプラグインのプロジェクト（リポジトリ）を作成します。
実際にテンプレートとなるリポジトリは<a href="https://github.com/elastic/template-kibana-plugin">template-kibana-plugin</a>になります。
まずはSaoのインストールです。</p>
<pre><code>npm install -g sao
</code></pre><p>プラグインのテンプレートのページには上記のようにnpmを利用したインストール方法になっていますが、次のようにyarnでも可能です。</p>
<pre><code>yarn global add sao
</code></pre><p>これで、saoがインストールできました。</p>
<h2 id="5-テンプレートによるプロジェクトファイルの生成">5. テンプレートによるプロジェクトファイルの生成</h2>
<p>あとは、テンプレートを元にプロジェクトを作成します。
<code>PLUGIN_DEV_DIR</code>ディレクトリ配下に、kibanaと同じ階層で作成するプラグイン用のディレクトリを作成します。</p>
<pre><code>mkdir simple-sample-kibana-plugin
</code></pre><p>以下のような構成になります。</p>
<pre><code>kibana                      simple-sample-kibana-plugin
</code></pre><p>次にテンプレートを適用していきます。</p>
<pre><code>cd simple-sample-kibana-plugin
sao kibana-plugin@7.2.4
</code></pre><p>2行目がsaoを利用してプロジェクトを作成しているコマンドになります。
すると、次のような質問が出て来ます。
これらに答えるとプロジェクトに必要なファイル（package.jsonやREADME.mdなど）に入力した情報を適用したものを作ってくれます。</p>
<pre><code>? Name of your plugin?
? Provide a short description
? What Kibana version are you targeting?
? Should an app component be generated?
? Should translation files be generated?
? Should an hack component be generated?
? Should a server API be generated?
</code></pre><p>実際に答えた内容はこちら。</p>
<pre><code>? Name of your plugin? simple-sample-kibana-plugin
? Provide a short description Sample plugin for explaining how to make kibana app
? What Kibana version are you targeting? 6.2.1
? Should an app component be generated? Yes
? Should translation files be generated? Yes
? Should an hack component be generated? Yes
? Should a server API be generated? Yes
</code></pre><p>プラグインの名前などは、ディレクトリ名と同じものを入力補完してくれているので、そのままEnterでもOKです。
Descriptionについてはわかりやすいものを入力しましょう。
バージョンは、先ほどのKibanaのリポジトリに合わせて、<code>6.2.1</code>にしてあります。
あとは、作るプラグインの種類に応じて、必要なコンポーネントを作るかどうかの質問にYes/Noで答えます。
今回はサンプルの説明ということもあるので、全てYesで答えました。
ちなみに、私が実際に作成した<a href="https://github.com/johtani/analyze-api-ui-plugin/">analyze-api-ui-plugin</a>では、<code>app</code>と<code>translation</code>と<code>server</code>の3つを作成しました。
ただし、<code>translation</code>については現在はテンプレートで作成したままのファイルが入っており、実際には利用してないです。</p>
<p>完了したら、プラグインのサンプル入りのプロジェクトが完成です。
もう一度、Elasticsearchを立ち上げて、プラグインのプロジェクトからKibanaを起動してアクセスしてみます。まずは、<code>PLUGIN_DEV_DIR/kibana</code>ディレクトリの下で、Elasticsearchを起動します。</p>
<pre><code>yarn elasticsearch
</code></pre><p>次に、<code>PLUGIN_DEV_DIR/simple-sample-kibana-plugin</code>ディレクトリの下で、以下のコマンドを実行し、プラグインが入った状態のKibanaを起動します。</p>
<pre><code>yarn start
</code></pre><p>問題なく起動すれば、ブラウザでアクセスすると次のような画面が表示されるはずです。</p>

<link rel="stylesheet" href="/css/hugo-easy-gallery.css" />
<div class="box" style="max-width:800">
  <figure  itemprop="associatedMedia" itemscope itemtype="http://schema.org/ImageObject">
    <div class="img">
      <img itemprop="thumbnail" src="/images/entries/20180214/sample_start.jpg" />
    </div>
    <a href="/images/entries/20180214/sample_start.jpg" itemprop="contentUrl"></a>
  </figure>
</div>

<p>左側にメニューが1つ増えています。
クリックすると、上記画像のような画面が表示されるはずです。</p>
<p>これで、カスタムプラグインの開発ができる環境ができました！
次回は、プロジェクトのディレクトリ構成や、どんなツールが内部で使用されてデータのやり取りが行われているかについて説明します。お楽しみに。</p>
</content:encoded>
    </item>
    
    <item>
      <title>Analyze UIとKibanaのプラグインの作成方法（第1回）</title>
      <link>https://blog.johtani.info/blog/2018/01/19/how-to-make-kibana-plugin-example-analysis-ui/</link>
      <pubDate>Fri, 19 Jan 2018 15:36:46 +0900</pubDate>
      
      <guid>https://blog.johtani.info/blog/2018/01/19/how-to-make-kibana-plugin-example-analysis-ui/</guid>
      <description>あけましておめでとうございます。今年はサボりがちだったブログをちょっとずつ復活させようかと。 ということで、第1弾として、昨年少し作っていたK</description>
      <content:encoded><p>あけましておめでとうございます。今年はサボりがちだったブログをちょっとずつ復活させようかと。
ということで、第1弾として、昨年少し作っていたKibanaのプラグインを何度かに分けて紹介したいと思います。</p>
<p>今回は<a href="https://github.com/johtani/analyze-api-ui-plugin">Analyze UIというプラグイン</a>の紹介です。</p>
<!-- more -->
<p>今回はインストール方法と簡単な機能紹介です。
細かな紹介は個別にやりたいと思います。</p>
<h3 id="analyze-ui-pluginとは">Analyze UI pluginとは？</h3>
<p>Elasticsearchの<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/indices-analyze.html"><code>_analyze</code>というAPI</a>(個人的に好きなAPIです)をご存知でしょうか？</p>
<p>Elasticsearchは全文検索エンジンで、データの検索には<a href="https://ja.wikipedia.org/wiki/%E8%BB%A2%E7%BD%AE%E3%82%A4%E3%83%B3%E3%83%87%E3%83%83%E3%82%AF%E3%82%B9">転置インデックス</a>というものを使用します。
Elasticsearchにデータを登録する際に、<code>text</code>型のデータの場合、この転置インデックスのキーとなる単語を決める処理のことを<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis.html">Analysis</a>と呼びます（Analysisの詳細については割愛します。後日説明するかも？）。
このAnalysisの処理が、入力されたデータの文字列に対してどのように行われて、結果としてどんな単語がキーとして用いられているかを確認できる機能が<code>_analyze</code> APIです。検索で単語がうまくヒットしないな？とか、なんで、こんなので検索結果に出てくるんだ？といった場合、このAPIを利用すると、どのような単語で転置インデックスが作られているかがわかるので、検索にヒットしない/する理由を見つけることができます。</p>
<p>Elasticsearchの便利な点はRESTfulなAPI＋JSONでやりとりができる点なのですが、<code>_analyze</code> APIの結果をJSONで受け取っても、見るのにちょっと苦労します。。。こんな感じ。</p>
<p>リクエスト：</p>
<pre><code>POST _analyze
{
  &quot;analyzer&quot;: &quot;kuromoji&quot;,
  &quot;text&quot;: &quot;今年はブログをいっぱい書きますよ！&quot;
}
</code></pre><p>レスポンス：</p>
<pre><code>{
  &quot;tokens&quot;: [
    {
      &quot;token&quot;: &quot;今年&quot;,
      &quot;start_offset&quot;: 0,
      &quot;end_offset&quot;: 2,
      &quot;type&quot;: &quot;word&quot;,
      &quot;position&quot;: 0
    },
    {
      &quot;token&quot;: &quot;ブログ&quot;,
      &quot;start_offset&quot;: 3,
      &quot;end_offset&quot;: 6,
      &quot;type&quot;: &quot;word&quot;,
      &quot;position&quot;: 2
    },
    {
      &quot;token&quot;: &quot;いっぱい&quot;,
      &quot;start_offset&quot;: 7,
      &quot;end_offset&quot;: 11,
      &quot;type&quot;: &quot;word&quot;,
      &quot;position&quot;: 4
    },
    {
      &quot;token&quot;: &quot;書く&quot;,
      &quot;start_offset&quot;: 11,
      &quot;end_offset&quot;: 13,
      &quot;type&quot;: &quot;word&quot;,
      &quot;position&quot;: 5
    }
  ]
}
</code></pre><p>このくらいの量であればまだなんとかなりますが、文章が長くなると辛いですよね。</p>
<p>ということで、GUIがあると便利だろうなぁと。で、作ってみましたというのが今日紹介するKibana用のAnalyze UIプラグインです。
こんな感じで、Kibanaのアプリの一部として動作しブラウザ上で、入力テキストの文字列がどのようにanalyzeされて、単語になるかがわかります。</p>

<link rel="stylesheet" href="/css/hugo-easy-gallery.css" />
<div class="box" style="max-width:800">
  <figure  itemprop="associatedMedia" itemscope itemtype="http://schema.org/ImageObject">
    <div class="img">
      <img itemprop="thumbnail" src="/images/entries/20180119/analyze_ui_sample_1.jpg" />
    </div>
    <a href="/images/entries/20180119/analyze_ui_sample_1.jpg" itemprop="contentUrl"></a>
  </figure>
</div>

<p>（先ほどのAPIのサンプルと同じものを画面で入力した結果になります）。</p>
<h3 id="インストール方法">インストール方法</h3>
<p>現時点の最新版Kibana（6.1.2）に対応しています。
Kibanaのディレクトリで<code>kibana-plugin</code>コマンドを利用してインストールします。</p>
<pre><code>./bin/kibana-plugin install https://github.com/johtani/analyze-api-ui-plugin/releases/download/6.1.2/analyze-api-ui-plugin-6.1.2.zip
</code></pre><p>これだけです。
で、Kibanaを起動していただくと、左のメニューに「Analyze UI」という項目が増えています。</p>


<div class="box" style="max-width:400">
  <figure  itemprop="associatedMedia" itemscope itemtype="http://schema.org/ImageObject">
    <div class="img">
      <img itemprop="thumbnail" src="/images/entries/20180119/kibana_menu.jpg" />
    </div>
    <a href="/images/entries/20180119/kibana_menu.jpg" itemprop="contentUrl"></a>
  </figure>
</div>

<p>クリックすると、Analyze UIが表示されます。</p>
<p>初期画面は入力された文字を特定のAnalyzerで処理した場合の結果を見るための画面です。綱目の説明は画像をご覧ください。</p>


<div class="box" style="max-width:800">
  <figure  itemprop="associatedMedia" itemscope itemtype="http://schema.org/ImageObject">
    <div class="img">
      <img itemprop="thumbnail" src="/images/entries/20180119/intro_analyze_ui_1.jpg" />
    </div>
    <a href="/images/entries/20180119/intro_analyze_ui_1.jpg" itemprop="contentUrl"></a>
  </figure>
</div>

<p>先ほどのJSONよりは見やすくなったかと思います。
そのほかにもいくつか画面や機能があるのですが、今日はこの辺りで。
「<code>_analyze</code> API便利なんだけど、JSONは。。。」とか「検索うまくできないなぁなんでだろう？」と思っている方は、ぜひ試して見ていただければと。
問題点などありましたら、GitHubのIssueを登録してください。</p>
</content:encoded>
    </item>
    
    <item>
      <title>Lucene Kuromoji for NEologdで指定した品詞の単語を抜き出すIngest Pluginを書いてみた #elasticsearchjp</title>
      <link>https://blog.johtani.info/blog/2016/07/22/making-ingest-processor-plugin-with-cookiecutter/</link>
      <pubDate>Fri, 22 Jul 2016 13:26:56 +0900</pubDate>
      
      <guid>https://blog.johtani.info/blog/2016/07/22/making-ingest-processor-plugin-with-cookiecutter/</guid>
      <description>久しぶりに、技術的なブログ書いてます。 Ingest Processorのプラグインを作ってみたくなったので、書いてみました。 ただ書いてみるんじゃ3番煎じ</description>
      <content:encoded><p>久しぶりに、技術的なブログ書いてます。</p>
<p>Ingest Processorのプラグインを作ってみたくなったので、書いてみました。
ただ書いてみるんじゃ3番煎じになりそうなので、<a href="https://cookiecutter.readthedocs.io/en/latest/readme.html">cookiecutter</a>を使ってみました。</p>
<!-- more -->
<p>と言っても、同僚のAlexが<a href="https://discuss.elastic.co/t/cookiecutter-template-for-writing-ingest-processors/52985">cookiecutter-elasticsearch-ingest-processor</a>と言うテンプレートを作ってくれているのを使っただけですが。（https://discuss.elastic.co に投稿された記事で、使い方がアニメgifで説明されててわかりやすいです）</p>
<p><a href="https://cookiecutter.readthedocs.io/en/latest/readme.html">cookiecutter</a>とは、コマンドラインで質問に答えると、テンプレートからプロジェクトが生成できるツールです。
Elasticでは、カスタムBeatを作る時に利用する例がいつかの日本語ブログや発表資料で話題になっていました。
これのIngest Processorのプラグインバージョンです。</p>
<p>今回は、NEologdも使ってみたかったので、Lucene Kuromoji for NEologdを利用して
指定した品詞の単語だけを抽出するProcessorを作ってみました。</p>
<p>GitHubのプロジェクト：https://github.com/johtani/elasticsearch-ingest-kuromoji-pos-extract</p>
<h3 id="cookiecutterの使い方">Cookiecutterの使い方</h3>
<p><a href="https://cookiecutter.readthedocs.io/en/latest/readme.html">Cookiecutterのインストールはサイト</a>をご覧ください。</p>
<pre><code>cookiecutter gh:spinscale/cookiecutter-elasticsearch-ingest-processor
</code></pre><p>あとは、出てくる以下の項目を指定するだけです。</p>
<ul>
<li><code>processor_type</code> : Ingest Processorのタイプ名です。<code>kuromoji_part_of_speech_extract</code>としました。（Alexのだと<code>_</code>を使うとちょっと問題があるので後述）</li>
<li><code>description</code> : readme.mdに利用されます。</li>
<li><code>developer_name</code> : 名前を記載。Javaのファイルのヘッダに利用</li>
<li><code>elasticsearch_version</code> : デフォルトで<code>5.0.0-alpha4</code>が指定されているので、特に指定せず</li>
</ul>
<p>以上の質問に答えたら、プロジェクトのディレクトリ構造が出来上がってます。
プロジェクトのビルドなどにはGradleを利用します。</p>
<h3 id="プロジェクトのintellij-idea用のファイルを生成">プロジェクトのIntelliJ IDEA用のファイルを生成</h3>
<p>build.gradleファイルでGradleのideaプラグインがapplyされているので、以下のコマンドを叩けばIntelliJ IDEAのプロジェクトファイル（？）が生成され、IntelliJで開けばすぐに開発ができる状態にできます。</p>
<pre><code>gradle idea
</code></pre><h3 id="コーディング">コーディング</h3>
<p>あとは、必要処理をコーディングします。
実際にコーディングするクラスは<code>org.elasticsearch.plugin.ingest.kuromoji_part_of_speech_extract</code>のパッケージにある以下の2つです。（パッケージ名にはprocessor_typeの名前が指定されている）</p>
<ul>
<li>IngestKuromojiPartOfSpeechExtractPlugin</li>
<li>KuromojiPartOfSpeechExtractProcessor</li>
</ul>
<h4 id="ingestkuromojipartofspeechextractplugin">IngestKuromojiPartOfSpeechExtractPlugin</h4>
<p>Pluginというクラスは、プラグインをNodeのModuleとして登録する処理を書くクラスとなります。
生成してすぐは、次のような形になっています。（※importやクラス定義の部分は省略しています。）</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Java" data-lang="Java"><span style="color:#f92672">...</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> Setting<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;</span> YOUR_SETTING <span style="color:#f92672">=</span>
            <span style="color:#66d9ef">new</span> Setting<span style="color:#f92672">&lt;&gt;(</span><span style="color:#e6db74">&#34;ingest.kuromoji_part_of_speech_extract.setting&#34;</span><span style="color:#f92672">,</span> <span style="color:#e6db74">&#34;foo&#34;</span><span style="color:#f92672">,</span> <span style="color:#f92672">(</span>value<span style="color:#f92672">)</span> <span style="color:#f92672">-&gt;</span> value<span style="color:#f92672">,</span> Setting<span style="color:#f92672">.</span><span style="color:#a6e22e">Property</span><span style="color:#f92672">.</span><span style="color:#a6e22e">NodeScope</span><span style="color:#f92672">);</span>

    <span style="color:#a6e22e">@Override</span>
    <span style="color:#66d9ef">public</span> List<span style="color:#f92672">&lt;</span>Setting<span style="color:#f92672">&lt;?&gt;&gt;</span> getSettings<span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> Arrays<span style="color:#f92672">.</span><span style="color:#a6e22e">asList</span><span style="color:#f92672">(</span>YOUR_SETTING<span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">onModule</span><span style="color:#f92672">(</span>NodeModule nodeModule<span style="color:#f92672">)</span> <span style="color:#66d9ef">throws</span> IOException <span style="color:#f92672">{</span>
        nodeModule<span style="color:#f92672">.</span><span style="color:#a6e22e">registerProcessor</span><span style="color:#f92672">(</span>KuromojiPartOfSpeechExtractProcessor<span style="color:#f92672">.</span><span style="color:#a6e22e">TYPE</span><span style="color:#f92672">,</span>
                <span style="color:#f92672">(</span>registry<span style="color:#f92672">)</span> <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">new</span> KuromojiPartOfSpeechExtractProcessor<span style="color:#f92672">.</span><span style="color:#a6e22e">Factory</span><span style="color:#f92672">());</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">...</span>
</code></pre></div><p><code>YOUR_SETTING</code>プロパティと<code>getSettings()</code>メソッドは<code>elasticsearch.yml</code>で指定したい設定を記述する場合の例になります。今回は特に必要ないので両方削除しました。
最終系は<a href="https://github.com/johtani/elasticsearch-ingest-kuromoji-pos-extract">GitHubのコード</a>をご覧ください。</p>
<h4 id="kuromojipartofspeechextractprocessor">KuromojiPartOfSpeechExtractProcessor</h4>
<p>Processorは実際にIngest Nodeで行う処理を書くところです。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Java" data-lang="Java">
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> String TYPE <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;kuromoji_part_of_speech_extract&#34;</span><span style="color:#f92672">;</span>

    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">final</span> String field<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">final</span> String targetField<span style="color:#f92672">;</span>

    <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">KuromojiPartOfSpeechExtractProcessor</span><span style="color:#f92672">(</span>String tag<span style="color:#f92672">,</span> String field<span style="color:#f92672">,</span> String targetField<span style="color:#f92672">)</span> <span style="color:#66d9ef">throws</span> IOException <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">super</span><span style="color:#f92672">(</span>tag<span style="color:#f92672">);</span>
        <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">field</span> <span style="color:#f92672">=</span> field<span style="color:#f92672">;</span>
        <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">targetField</span> <span style="color:#f92672">=</span> targetField<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>

    <span style="color:#a6e22e">@Override</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">execute</span><span style="color:#f92672">(</span>IngestDocument ingestDocument<span style="color:#f92672">)</span> <span style="color:#66d9ef">throws</span> Exception <span style="color:#f92672">{</span>
        String content <span style="color:#f92672">=</span> ingestDocument<span style="color:#f92672">.</span><span style="color:#a6e22e">getFieldValue</span><span style="color:#f92672">(</span>field<span style="color:#f92672">,</span> String<span style="color:#f92672">.</span><span style="color:#a6e22e">class</span><span style="color:#f92672">);</span>
        <span style="color:#75715e">// TODO implement me!
</span><span style="color:#75715e"></span>        ingestDocument<span style="color:#f92672">.</span><span style="color:#a6e22e">setFieldValue</span><span style="color:#f92672">(</span>targetField<span style="color:#f92672">,</span> content<span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>

    <span style="color:#a6e22e">@Override</span>
    <span style="color:#66d9ef">public</span> String <span style="color:#a6e22e">getType</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> TYPE<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Factory</span> <span style="color:#66d9ef">extends</span> AbstractProcessorFactory<span style="color:#f92672">&lt;</span>KuromojiPartOfSpeechExtractProcessor<span style="color:#f92672">&gt;</span> <span style="color:#f92672">{</span>

        <span style="color:#a6e22e">@Override</span>
        <span style="color:#66d9ef">public</span> KuromojiPartOfSpeechExtractProcessor <span style="color:#a6e22e">doCreate</span><span style="color:#f92672">(</span>String processorTag<span style="color:#f92672">,</span> Map<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">,</span> Object<span style="color:#f92672">&gt;</span> config<span style="color:#f92672">)</span> <span style="color:#66d9ef">throws</span> Exception <span style="color:#f92672">{</span>
            String field <span style="color:#f92672">=</span> readStringProperty<span style="color:#f92672">(</span>TYPE<span style="color:#f92672">,</span> processorTag<span style="color:#f92672">,</span> config<span style="color:#f92672">,</span> <span style="color:#e6db74">&#34;field&#34;</span><span style="color:#f92672">);</span>
            String targetField <span style="color:#f92672">=</span> readStringProperty<span style="color:#f92672">(</span>TYPE<span style="color:#f92672">,</span> processorTag<span style="color:#f92672">,</span> config<span style="color:#f92672">,</span> <span style="color:#e6db74">&#34;target_field&#34;</span><span style="color:#f92672">,</span> <span style="color:#e6db74">&#34;default_field_name&#34;</span><span style="color:#f92672">);</span>

            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">new</span> KuromojiPartOfSpeechExtractProcessor<span style="color:#f92672">(</span>processorTag<span style="color:#f92672">,</span> field<span style="color:#f92672">,</span> targetField<span style="color:#f92672">);</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>

</code></pre></div><p><code>TYPE</code>が<a href="https://www.elastic.co/guide/en/elasticsearch/reference/master/put-pipeline-api.html">Ingest APIのPipelineでProcessorを指定するときに使う名前</a>になります。ここは、cookiecutterの時にprocessor_typeに入力した文字列になっています。
<code>kuromoji_part_of_speech_extract</code>だと長いので、<code>kuromoji_pos_extract</code>に変えました。</p>
<p><code>execute()</code>メソッドに<code>// TODO implement me!</code>とあります。
この部分に実際の処理を記述していきます。</p>
<p>あとは、<code>Factory</code>クラスでIngest APIで指定された設定項目を読み込みます。
今回作成した<code>elasticsearch-ingest-kuromoji-pos-extract</code>では品詞を指定する必要があるので、<code>pos_tags</code>を指定できるように処理を追加しました。</p>
<p>私が実装したものの説明をするとちょっと長くなりそうなので、<a href="https://github.com/johtani/elasticsearch-ingest-kuromoji-pos-extract">GitHubのコード</a>をご覧ください。</p>
<h3 id="テストのコーディング">テストのコーディング</h3>
<p>テストのクラスもテンプレートで生成されています。</p>
<ul>
<li>KuromojiPartOfSpeechExtractProcessorTests</li>
<li>KuromojiPartOfSpeechExtractRestIT</li>
</ul>
<h4 id="kuromojipartofspeechextractprocessortests">KuromojiPartOfSpeechExtractProcessorTests</h4>
<p>Processorクラスのテストになります。生成直後は次のような感じです。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Java" data-lang="Java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">testThatProcessorWorks</span><span style="color:#f92672">()</span> <span style="color:#66d9ef">throws</span> Exception <span style="color:#f92672">{</span>
    Map<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">,</span> Object<span style="color:#f92672">&gt;</span> document <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> HashMap<span style="color:#f92672">&lt;&gt;();</span>
    document<span style="color:#f92672">.</span><span style="color:#a6e22e">put</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;source_field&#34;</span><span style="color:#f92672">,</span> <span style="color:#e6db74">&#34;fancy source field content&#34;</span><span style="color:#f92672">);</span>
    IngestDocument ingestDocument <span style="color:#f92672">=</span> RandomDocumentPicks<span style="color:#f92672">.</span><span style="color:#a6e22e">randomIngestDocument</span><span style="color:#f92672">(</span>random<span style="color:#f92672">(),</span> document<span style="color:#f92672">);</span>

    KuromojiPartOfSpeechExtractProcessor processor <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> KuromojiPartOfSpeechExtractProcessor<span style="color:#f92672">(</span>randomAsciiOfLength<span style="color:#f92672">(</span>10<span style="color:#f92672">),</span> <span style="color:#e6db74">&#34;source_field&#34;</span><span style="color:#f92672">,</span> <span style="color:#e6db74">&#34;target_field&#34;</span><span style="color:#f92672">);</span>
    processor<span style="color:#f92672">.</span><span style="color:#a6e22e">execute</span><span style="color:#f92672">(</span>ingestDocument<span style="color:#f92672">);</span>
    Map<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">,</span> Object<span style="color:#f92672">&gt;</span> data <span style="color:#f92672">=</span> ingestDocument<span style="color:#f92672">.</span><span style="color:#a6e22e">getSourceAndMetadata</span><span style="color:#f92672">();</span>

    assertThat<span style="color:#f92672">(</span>data<span style="color:#f92672">,</span> hasKey<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;target_field&#34;</span><span style="color:#f92672">));</span>
    assertThat<span style="color:#f92672">(</span>data<span style="color:#f92672">.</span><span style="color:#a6e22e">get</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;target_field&#34;</span><span style="color:#f92672">),</span> is<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;fancy source field content&#34;</span><span style="color:#f92672">));</span>
    <span style="color:#75715e">// TODO add fancy assertions here
</span><span style="color:#75715e"></span><span style="color:#f92672">}</span>
</code></pre></div><p>テストメソッドも実装されていますが、パラメータの追加の設定処理やアサーションが書かれてません。
実装に合わせて、アサーションや設定処理を追加しましょう。</p>
<h4 id="kuromojipartofspeechextractrestit">KuromojiPartOfSpeechExtractRestIT</h4>
<p>こちらはIntegration Testになります。
実際にElasticsearchに対して外部からAPIを叩くような感じです。
APIを叩くときに利用するJSONの設定やアサーションは<code>src/test/resources</code>にyamlファイルがあります。</p>
<ul>
<li>10_basic.yaml</li>
<li>20_kuromoji_part_of_speech_extract_processor.yaml</li>
</ul>
<p><code>10_basic.yaml</code>はプラグインがインストールされているかの確認のテストです。特に変更する必要はないです。</p>
<p><code>20_kuromoji_part_of_speech_extract_processor.yaml</code>は実際にコーディングしたProcessorが動くかどうかのテストです。</p>
<p>テストの内容については、<a href="https://github.com/johtani/elasticsearch-ingest-kuromoji-pos-extract">GitHubのコード</a>をご覧ください。</p>
<h3 id="テストの実行とzipの生成">テストの実行とZipの生成</h3>
<p>テストの実行とZipの生成は次のコマンドを実行すればOKです。</p>
<pre><code>gradle check
</code></pre><p>テストに問題があった場合は、コケますし、問題なければ<code>SUCCESS</code>と表示が出ます。
成功した場合は<code>build/distributions/</code>というディレクトリにzipファイルができています。
これをElasticsearchのpluginコマンドでインストールすれば動きます。</p>
<pre><code>bin/plugin install file:///path/to/elasticsearch-ingest-kuromoji-pos-extract/build/distribution/ingest-kuromoji_part_of_speech_extract-0.0.1-SNAPSHOT.zip
</code></pre><h3 id="kuromoji_pos_extractの利用方法">kuromoji_pos_extractの利用方法</h3>
<p>Ingest APIには便利な<a href="https://www.elastic.co/guide/en/elasticsearch/reference/master/simulate-pipeline-api.html">Simulate Pipeline API</a>があります。</p>
<p>ということで、<a href="https://github.com/neologd/mecab-ipadic-neologd/blob/master/README.ja.md">mecab-ipadic-NEologd</a>にあったサンプルの文章を使って、使い方の説明です。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-JSON" data-lang="JSON"><span style="color:#960050;background-color:#1e0010">POST</span> <span style="color:#960050;background-color:#1e0010">_ingest/pipeline/_simulate</span>
{
  <span style="color:#f92672">&#34;pipeline&#34;</span> : {
    <span style="color:#f92672">&#34;description&#34;</span> : <span style="color:#e6db74">&#34;kuromoji neologd extract test&#34;</span>,
    <span style="color:#f92672">&#34;processors&#34;</span> : [
      {
        <span style="color:#f92672">&#34;kuromoji_pos_extract&#34;</span> : {
        <span style="color:#f92672">&#34;field&#34;</span> : <span style="color:#e6db74">&#34;body&#34;</span>,
        <span style="color:#f92672">&#34;target_field&#34;</span> : <span style="color:#e6db74">&#34;noun_field&#34;</span>,
        <span style="color:#f92672">&#34;pos_tags&#34;</span> : [
          <span style="color:#e6db74">&#34;名詞-固有名詞-組織&#34;</span>,
          <span style="color:#e6db74">&#34;名詞-固有名詞-一般&#34;</span>,
          <span style="color:#e6db74">&#34;名詞-固有名詞-人名-一般&#34;</span>,
          <span style="color:#e6db74">&#34;名詞-固有名詞-地域-一般&#34;</span>,
          <span style="color:#e6db74">&#34;名詞-固有名詞-地域-国&#34;</span>
          ]
        }
      }
      ]
  },
  <span style="color:#f92672">&#34;docs&#34;</span> : [
    {
      <span style="color:#f92672">&#34;_index&#34;</span>: <span style="color:#e6db74">&#34;index&#34;</span>,
      <span style="color:#f92672">&#34;_type&#34;</span>: <span style="color:#e6db74">&#34;type&#34;</span>,
      <span style="color:#f92672">&#34;_id&#34;</span>: <span style="color:#e6db74">&#34;id&#34;</span>,
      <span style="color:#f92672">&#34;_source&#34;</span>: {
        <span style="color:#f92672">&#34;body&#34;</span> : <span style="color:#e6db74">&#34;10日放送の「中居正広のミになる図書館」（テレビ朝日系）で、SMAPの中居正広が、篠原信一の過去の勘違いを明かす一幕があった。&#34;</span>
      }
    }
    ]
}
</code></pre></div><p>結果はこちら。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-JSON" data-lang="JSON">{
  <span style="color:#f92672">&#34;docs&#34;</span>: [
    {
      <span style="color:#f92672">&#34;doc&#34;</span>: {
        <span style="color:#f92672">&#34;_index&#34;</span>: <span style="color:#e6db74">&#34;index&#34;</span>,
        <span style="color:#f92672">&#34;_id&#34;</span>: <span style="color:#e6db74">&#34;id&#34;</span>,
        <span style="color:#f92672">&#34;_type&#34;</span>: <span style="color:#e6db74">&#34;type&#34;</span>,
        <span style="color:#f92672">&#34;_source&#34;</span>: {
          <span style="color:#f92672">&#34;noun_field&#34;</span>: [
            <span style="color:#e6db74">&#34;10日&#34;</span>,
            <span style="color:#e6db74">&#34;中居正広のミになる図書館&#34;</span>,
            <span style="color:#e6db74">&#34;テレビ朝日&#34;</span>,
            <span style="color:#e6db74">&#34;SMAP&#34;</span>,
            <span style="color:#e6db74">&#34;中居正広&#34;</span>,
            <span style="color:#e6db74">&#34;篠原信一&#34;</span>
          ],
          <span style="color:#f92672">&#34;body&#34;</span>: <span style="color:#e6db74">&#34;10日放送の「中居正広のミになる図書館」（テレビ朝日系）で、SMAPの中居正広が、篠原信一の過去の勘違いを明かす一幕があった。&#34;</span>
        },
        <span style="color:#f92672">&#34;_ingest&#34;</span>: {
          <span style="color:#f92672">&#34;timestamp&#34;</span>: <span style="color:#e6db74">&#34;2016-07-22T06:18:49.007+0000&#34;</span>
        }
      }
    }
  ]
}
</code></pre></div><p><code>noun_field</code>に固有名詞の単語が抜き出せているのがわかるかと思います。</p>
<h3 id="alexのテンプレートで困った点">Alexのテンプレートで困った点</h3>
<p>テンプレートは便利だったのですが、<code>processor_type</code>に<code>_</code>を使用したタイプ名を指定すると次のような問題（？）が発生しました。</p>
<ul>
<li>クラス名が<code>Kuromoji_part_of_speech_extractProcessor</code>となってしまう</li>
</ul>
<p>深刻な問題ではないのですが、JavaだとCamel Caseが普通なのでちょっと気になって。
ということで、<a href="https://github.com/spinscale/cookiecutter-elasticsearch-ingest-processor/pull/1">プルリク</a>作って出してみました。まだ取り込まれてないかな。</p>
<p>取り込み前に使いたい方は以下のコマンドを実行してください。
<code>processor_class_name</code>という項目が増えています。
デフォルトだと<code>processor_type</code>の<code>_</code>の部分を取り除きつつCamel Caseにしたものが入ります。</p>
<pre><code>cookiecutter gh:johtani/cookiecutter-elasticsearch-ingest-processor
</code></pre><h3 id="まとめ">まとめ</h3>
<p>ということで、とりあえず作ってみましたというものになります。
特徴的な単語（固有名詞だけ）を抜き出して、別のフィールドにできるので、タグみたいなものをこれを使って前処理で作れるようになるかなぁと。</p>
<h2 id="参考ブログ元ネタ">参考ブログ（元ネタ？）</h2>
<p>インスパイア元となったブログです。</p>
<ul>
<li><a href="http://dev.classmethod.jp/server-side/elasticsearch/ingest-plugin-useragent/">User Agentを解析するIngest Pluginを書いてみた</a></li>
<li><a href="http://blog.cybozu.io/entry/2016/07/05/080000">Elasticsearch 5.0.0のIngest Node用プラグインを書いた話</a></li>
</ul>
</content:encoded>
    </item>
    
    <item>
      <title>Sonatypeのバージョン番号で困ったので</title>
      <link>https://blog.johtani.info/blog/2014/10/15/versioning-of-sonatype/</link>
      <pubDate>Wed, 15 Oct 2014 15:26:08 +0900</pubDate>
      
      <guid>https://blog.johtani.info/blog/2014/10/15/versioning-of-sonatype/</guid>
      <description>Elasticsearch 1.4.0.Beta1がリリースされました。 個人でelasticsearch-extended-analyzeというプラグインを開発してま</description>
      <content:encoded><p><a href="http://blog.johtani.info/blog/2014/10/02/elasticsearch-1-4-0-beta-released-ja/">Elasticsearch 1.4.0.Beta1がリリース</a>されました。</p>
<p>個人で<a href="https://github.com/johtani/elasticsearch-extended-analyze">elasticsearch-extended-analyze</a>というプラグインを開発してます。
こちらも1.4.0.Beta1に対応するべく作業をしてて、少し戸惑ったことがあったので、メモをば。</p>
<!-- more -->
<p>ここ最近はプラグインのバージョン番号をElasticsearchのバージョン番号と同じものを利用していました。
（プラグインの機能追加をサボってる？？）
その時に、<code>1.4.0.Beta1</code>という番号を指定したのですが、意味不明なエラーに悩まされてしまいまして。</p>
<p>プラグインのリリースでは、以下のコマンドを実行します。</p>
<pre><code>$ mvn release:prepare
$ mvn release:perform
</code></pre><p>最初のコマンド（prepare）で、パッケージングを実施し、Githubにリリースタグを打ったバージョンがpushされます。
次のコマンド（perform）で、パッケージングされたzipファイルがsonatypeのサイトに公開するためにアップロードされます。</p>
<p><code>1.4.0.Beta1</code>というバージョン文字列を利用した場合、prepareは問題なく実行できたのですが、
performで以下の様なエラーが返ってきました。</p>
<pre><code>Return code is: 401, ReasonPhrase: Unauthorized.
</code></pre><p>バージョン番号が<code>1.3.0</code>では特に問題はなかったのですが、、、
結局、バージョン番号を<code>1.4.0-beta1</code>に変更すると問題なくリリースが完了しました。</p>
<p>mike_neckさんと話をしていて、<a href="http://semver.org">Semantic Versioning</a>に関係しているのかなぁという話にはなったのですが、
詳しく調べていません。。。</p>
<p>そのうち調べようかなぁ。。。。</p>
</content:encoded>
    </item>
    
    <item>
      <title>プロキシ環境でのpluginコマンドの実行</title>
      <link>https://blog.johtani.info/blog/2014/08/01/plugin-using-under-proxy-env/</link>
      <pubDate>Fri, 01 Aug 2014 15:24:00 +0900</pubDate>
      
      <guid>https://blog.johtani.info/blog/2014/08/01/plugin-using-under-proxy-env/</guid>
      <description>Proxy環境で働いている方も結構いると思います。 Twitter上で、Elasticsearchのpluginコマンドでプラグインがインスト</description>
      <content:encoded><p>Proxy環境で働いている方も結構いると思います。
Twitter上で、Elasticsearchのpluginコマンドでプラグインがインストールできなくて困っている方がいたので、
調べてみたのでメモしておきます。</p>
<!-- more -->
<h2 id="プラグインコマンド">プラグインコマンド</h2>
<p>Elasticsearchでは、プラグインという形でいくつかの便利な機能が公開されています。
<a href="https://github.com/elasticsearch/elasticsearch-analysis-kuromoji">形態素解析ライブラリのKuromoji</a>を使うためのプラグインや、<a href="https://github.com/lmenezes/elasticsearch-kopf">クラスタの管理がGUIで可能なkopf</a>プラグインなどがあります。
公式、サードパーティいろいろです。</p>
<p>これらのプラグインをElasticsearchにインストールする場合、以下のコマンドを実行すれば
自動的にダウンロードして<code>plugins</code>ディレクトリにインストールしてくれます。</p>
<pre><code>./bin/plugin -i elasticsearch/elasticsearch-analysis-kuromoji/2.3.0
</code></pre><p>ここで、<code>elasticsearch/elasticsearch-analysis-kuromoji/2.3.0</code>がプラグインのパスになります（例では、<code>提供元/プラグイン名/プラグインバージョン</code>となっています。）。</p>
<p>この<code>plugin</code>コマンドがダウンロード元にアクセスに行くのですが、プロキシ環境だとプロキシの設定が必要になります。</p>
<h2 id="プロキシの指定maclinuxとwindowsでの違い">プロキシの指定（Mac/LinuxとWindowsでの違い）</h2>
<h3 id="maclinuxshコマンド">Mac/Linux(shコマンド)</h3>
<p><a href="http://blog.johtani.info/blog/2013/09/03/ja-wikipedia-with-kuromoji/">以前の記事</a>でプロキシのポート番号などの指定方法を
以下のように説明していました。
（※昔の記事のため、kuromojiプラグインのバージョンが古いです）</p>
<p>ElasticsearchのpluginコマンドはJavaで実装されています。（org.elasticsearch.common.http.client.HttpDownloadHelper）
プラグインのダウンロードには、java.net.URL.openConnection()から取得URLConnectionを使用しています。</p>
<p>ですので、pluginのインストールを行う際に、Proxy環境にある場合は以下のようにコマンドを実行します。</p>
<pre><code>./bin/plugin -DproxyPort=ポート番号 -DproxyHost=ホスト名 -i elasticsearch/elasticsearch-analysis-kuromoji/1.5.0
</code></pre><p>LinuxやMacの環境であれば、こちらのコマンドでプロキシの指定が可能です。
ただし、Windows環境ではうまくいきません。</p>
<p>Elasticsearchは、環境の違いにより、ダウンロードするファイルが異なります。
Windows環境の方は、zipファイルをダウンロードしてもらうようになっています。
elasticsearchコマンドおよびpluginコマンドがbat形式で提供されているのがzipファイルとなるからです。</p>
<h3 id="windowsbatコマンド">Windows(batコマンド)</h3>
<p>Windows環境では次のように指定します。</p>
<pre><code>set JAVA_OPTS=&quot;-DproxyHost=ホスト名 -DproxyPort=ポート番号&quot;
bin\plugin -i elasticsearch/elasticsearch-analysis-kuromoji/2.3.0
</code></pre><p>コマンドの実装方法が少し異なるために、このようになっています。</p>
<h2 id="まとめ">まとめ</h2>
<p>プロキシ環境で利用される場合は、プラグインコマンドは上記のように実行していただければと。</p>
<p>公式ガイドには、これらの情報を追記するPRを送る予定です。
また、WindowsのコマンドでもMac/Linuxと同様にできたほうがいい気がするので、Issueをあげようと思います。</p>
<p>不明点などあれば、コメントいただければと。</p>
</content:encoded>
    </item>
    
    <item>
      <title>elasticsearch-kopfの紹介（aliases画面）</title>
      <link>https://blog.johtani.info/blog/2014/05/04/intro-elasticsearch-kopf-alias-percolator/</link>
      <pubDate>Sun, 04 May 2014 01:01:00 +0900</pubDate>
      
      <guid>https://blog.johtani.info/blog/2014/05/04/intro-elasticsearch-kopf-alias-percolator/</guid>
      <description>今日はelasticsearch-kopfのAnalysis画面の紹介です。 （簡単なところから。。。その３） ちょっとあいだが開いてしまいまし</description>
      <content:encoded><p>今日はelasticsearch-kopfのAnalysis画面の紹介です。</p>
<p>（簡単なところから。。。その３）</p>
<!-- more -->
<p>ちょっとあいだが開いてしまいましたが、再開です。
メニューの<code>aliases</code>を選択すると、次のような画面が表示されます。</p>

<link rel="stylesheet" href="/css/hugo-easy-gallery.css" />
<div class="box" >
  <figure  itemprop="associatedMedia" itemscope itemtype="http://schema.org/ImageObject">
    <div class="img">
      <img itemprop="thumbnail" src="/images/entries/20140504/kopf-aliases.jpg" />
    </div>
    <a href="/images/entries/20140504/kopf-aliases.jpg" itemprop="contentUrl"></a>
      <figcaption align="center"><h4>Aliases画面</h4>
      </figcaption>
  </figure>
</div>

<p>Elasticsearchの<code>alias</code>を画面で確認できます。</p>
<p>エイリアスは、インデックスに別名をつけることができるElasticsearchの機能です。
１エイリアス＝１インデックスでも良いですが、１エイリアスに対して複数のエイリアスを付与することもできます。
この機能を利用することで、次のようなことが可能となります。</p>
<ul>
<li>インデックスの切り替えをアプリ側に意識させずに実施（アプリはエイリアス名に対して検索すればOKなので）</li>
<li>直近１週間のログを検索するためのエイリアスの作成（複数のインデックスを１つのエイリアスに割り当て可能）</li>
<li>特定のルーティングによる検索（特定のデータに対する検索だけに絞るためにfilterを指定する）</li>
</ul>
<p>エイリアスについて詳しく知りたい方は<a href="http://www.elasticsearch.org/guide/en/elasticsearch/reference/current/indices-aliases.html">公式ガイド</a>をご覧いただくのが良いかと。</p>
<p>画面は非常にわかりやすい作りになっているので、特に説明必要ないんですよね。。。</p>
</content:encoded>
    </item>
    
    <item>
      <title>elasticsearch-kopfの紹介（analysis画面）</title>
      <link>https://blog.johtani.info/blog/2014/04/09/intro-elasticsearch-kopf-analysis/</link>
      <pubDate>Wed, 09 Apr 2014 11:41:00 +0900</pubDate>
      
      <guid>https://blog.johtani.info/blog/2014/04/09/intro-elasticsearch-kopf-analysis/</guid>
      <description>今日はelasticsearch-kopfのAnalysis画面の紹介です。 （簡単なところから。。。その２） メニューのanalysisを選択</description>
      <content:encoded><p>今日はelasticsearch-kopfのAnalysis画面の紹介です。</p>
<p>（簡単なところから。。。その２）</p>
<!-- more -->
<p>メニューの<code>analysis</code>を選択すると、次のような画面が表示されます。</p>

<link rel="stylesheet" href="/css/hugo-easy-gallery.css" />
<div class="box" >
  <figure  itemprop="associatedMedia" itemscope itemtype="http://schema.org/ImageObject">
    <div class="img">
      <img itemprop="thumbnail" src="/images/entries/20140409/kopf-analysis.jpg" />
    </div>
    <a href="/images/entries/20140409/kopf-analysis.jpg" itemprop="contentUrl"></a>
      <figcaption align="center"><h4>Analysis画面</h4>
      </figcaption>
  </figure>
</div>

<p>Elasticsearchの<code>_analyze</code> APIを画面で確認できます。
画面で動作の確認ができるのは嬉しいですよね。</p>
<ol>
<li>入力文字列：入力となるドキュメントに含まれる文字列や検索キーワードを入力</li>
<li>フィールドの指定：対象とするインデックス名、タイプ名、フィールド名を選択</li>
<li>analyze：ボタンを押す</li>
<li>トークナイズされた結果：入力文字列がどのようなトークンに分割されるか
<ul>
<li>start、end：入力文字列中の文字列の位置</li>
<li>pos：トークンの位置</li>
</ul>
</li>
</ol>
<p>という形でElasticsearchが指定されたフィールドで入力文字をどのようにトークナイズしたかを確認することができます。</p>
<p>Elasticsearchは内部でこのトークナイズされた単語を元に転置インデックスを作成し、検索に利用します。
ですので、特定のデータが検索に上手くヒットしないときに、この画面でデータの文字列をトークナイズしてみるといった用途に使えます。</p>
<p>フィールドの設定がどのようにして入力文字列をトークンにしているかといった点については、今度のElasticsearch勉強会で話す予定です。</p>
<p>フィールドの設定を利用する以外に、アナライザを指定してどのようにトークナイズされるかを見ることもできます。
「ANALYZE BYANALYZER」をクリックすると利用できます。</p>


<div class="box" >
  <figure  itemprop="associatedMedia" itemscope itemtype="http://schema.org/ImageObject">
    <div class="img">
      <img itemprop="thumbnail" src="/images/entries/20140409/kopf-analysis-analyzer.jpg" />
    </div>
    <a href="/images/entries/20140409/kopf-analysis-analyzer.jpg" itemprop="contentUrl"></a>
      <figcaption align="center"><h4>ANALYZE BY ANALYZER</h4>
      </figcaption>
  </figure>
</div>

<p>トークナイズしたい文字列を入力し、インデックス名と、インデックスに設定されているアナライザ名を選択してanalyzeボタンを押すと
結果が表示されます。
（例では、kuromojiアナライザを利用して出力になっています。また、出力結果のposの表示位置がFIELD TYPEの時と違うのが少し気になりました。）</p>
<p>ただ、残念ながら、インデックスのマッピングで指定したアナライザしか利用できないみたいなので、
どのアナライザがどんな挙動かを調べたい場合は、以前紹介した<a href="http://blog.johtani.info/blog/2013/09/23/intro-elasticsearch-inquisitor/">elasticsearch-inquisitor</a>を
利用したほうが良さそうです。</p>
<p>ということで、今日はanalysis画面の説明でした。</p>
</content:encoded>
    </item>
    
    <item>
      <title>elasticsearch-kopfの紹介（rest画面）</title>
      <link>https://blog.johtani.info/blog/2014/04/07/intro-elasticsearch-kopf-rest/</link>
      <pubDate>Mon, 07 Apr 2014 11:24:00 +0900</pubDate>
      
      <guid>https://blog.johtani.info/blog/2014/04/07/intro-elasticsearch-kopf-rest/</guid>
      <description>今日はelasticsearch-kopfのREST画面の紹介です。 （簡単なところから。。。） メニューのrestを選択すると、次のような画面</description>
      <content:encoded><p>今日はelasticsearch-kopfのREST画面の紹介です。</p>
<p>（簡単なところから。。。）</p>
<!-- more -->
<p>メニューの<code>rest</code>を選択すると、次のような画面が表示されます。</p>
<p>Elasticsearch自体が、さまざまな操作をRESTでできる仕組みになっています。
検索にも利用しますが、それ以外の設定などにつてもリクエストを送ればOKです。</p>
<p>ですので、リクエストや設定を自分で組み立てて送ることができる画面が用意されているととても便利です。
（もちろん、curlコマンドでもいいのですが、画面があると便利ですよね）</p>

<link rel="stylesheet" href="/css/hugo-easy-gallery.css" />
<div class="box" >
  <figure  itemprop="associatedMedia" itemscope itemtype="http://schema.org/ImageObject">
    <div class="img">
      <img itemprop="thumbnail" src="/images/entries/20140407/kopf-rest.jpg" />
    </div>
    <a href="/images/entries/20140407/kopf-rest.jpg" itemprop="contentUrl"></a>
      <figcaption align="center"><h4>REST画面</h4>
      </figcaption>
  </figure>
</div>

<h2 id="history">History</h2>
<p>履歴表示画面です。
これまで、kopfのrest画面を利用して送信したリクエストが一覧で表示されます。</p>
<p><code>History</code>という文字をクリックすることで、表示/非表示の切り替えが可能です。（最初は非表示）
マウスオーバーすると、リクエストボディがポップアップで表示されます。</p>


<div class="box" >
  <figure  itemprop="associatedMedia" itemscope itemtype="http://schema.org/ImageObject">
    <div class="img">
      <img itemprop="thumbnail" src="/images/entries/20140407/kopf-history.jpg" />
    </div>
    <a href="/images/entries/20140407/kopf-history.jpg" itemprop="contentUrl"></a>
      <figcaption align="center"><h4>History</h4>
      </figcaption>
  </figure>
</div>

<p>履歴にあるURLはクリック可能で、クリックすると実行されます。
履歴は<code>localStorage</code>に保存されるみたいです。（ブラウザの仕様？あんまり詳しくないので。。。）
たぶん、30件が上限かと（ソースで確認しただけ）</p>
<h2 id="url">URL</h2>
<p>rest画面でリクエストを送信する先のURLを指定します。
メソッドは右側のSELECTで選択可能です。</p>
<p>リクエストパラメータも指定が可能です。</p>
<h2 id="リクエストボディ">リクエストボディ</h2>
<p>検索や設定のJSONを記述するところです。
一応、JSON的にエラーがある場合は行数の左側にバツ印が出てきておかしなところもわかるようになっています。</p>
<p>インデントなどは行ってくれますが、senseみたいな補完などはないので、少し辛いところです。</p>
<h2 id="レスポンス">レスポンス</h2>
<p>送信したリクエストに対するレスポンスが返ってきます。
インデントされた状態で表示されるので読みやすいかと。
また、入れ子になっているJSONについては、閉じたり開いたりすることも可能です。
（開始のカッコの右側に<code>-</code>が表示されていて、クリックすると閉じることができます。閉じると<code>+</code>に変わります）</p>
<p>簡単ですが、rest画面の説明でした。
KOPFを使っていて、ちょっとしたクエリを送ったりするのには便利だと思います。</p>
<p>複雑な検索クエリなどについては、やはりsenseを使うのが良いかと思いますが。。。</p>
</content:encoded>
    </item>
    
    <item>
      <title>elasticsearch-kopfの紹介（概要）</title>
      <link>https://blog.johtani.info/blog/2014/04/05/intro-elasticsearch-kopf-1/</link>
      <pubDate>Sat, 05 Apr 2014 23:18:00 +0900</pubDate>
      
      <guid>https://blog.johtani.info/blog/2014/04/05/intro-elasticsearch-kopf-1/</guid>
      <description>なんだか、ドタバタしてて久しぶりの更新です。 ベルリンの旅行記みたいなのも書きたいのですが、まずはこちらかと。 elasticsearch-ko</description>
      <content:encoded><p>なんだか、ドタバタしてて久しぶりの更新です。
ベルリンの旅行記みたいなのも書きたいのですが、まずはこちらかと。</p>
<p><a href="https://github.com/lmenezes/elasticsearch-kopf">elasticsearch-kopf</a>プラグインの紹介です。</p>
<p>今回は概要の説明だけになります。機能が結構多いので。</p>
<!-- more -->
<h2 id="elasticsearch-kopfとは">elasticsearch-kopfとは？</h2>
<p><code>_site</code>プラグインの一つで、クラスタ管理用のプラグインになります。
<code>head</code>プラグインや<code>HQ</code>プラグインと同様です。</p>

<link rel="stylesheet" href="/css/hugo-easy-gallery.css" />
<div class="box" >
  <figure  itemprop="associatedMedia" itemscope itemtype="http://schema.org/ImageObject">
    <div class="img">
      <img itemprop="thumbnail" src="/images/entries/20140405/kopf.jpg" />
    </div>
    <a href="/images/entries/20140405/kopf.jpg" itemprop="contentUrl"></a>
      <figcaption align="center"><h4>プラグインの画面</h4>
      </figcaption>
  </figure>
</div>

<p>このようにシンプルな画面で、スッキリとしています。
緑を基調にした画面構成はElasticsearchの緑色を意識してるんでしょうか？</p>
<p>上記の画像に簡単なコメントを入れてあります。</p>
<h3 id="メニュー">メニュー</h3>
<ul>
<li>KOPF：KOPF自体の設定（接続先とリフレッシュインターバルの変更）</li>
<li>cluster：クラスタ管理、情報（デフォルト表示画面）</li>
<li>rest：RESTリクエスト送信、結果表示画面</li>
<li>aliases：エイリアス管理</li>
<li>analysis：<code>analysis API</code></li>
<li>percolator：パーコレータ管理</li>
<li>warmup：ウォームアップクエリ管理</li>
</ul>
<p>上記のようなメニューです。各メニューについては、今後のブログで少しずつ紹介しようかと。
このメニューの色が、クラスタの状態も表しています。ステータスがYELLOWなら黄色、REDなら赤色に変わります。</p>
<h3 id="インデックス">インデックス</h3>
<p>インデックスは列として表示されます。先ほどの画像では、2つのインデックスが表示されている状態です。
インデックス毎に、シャードも表示されます。これは、各ノードがどのシャードを保持しているかという情報です。
色の濃いシャードがプライマリでしょう。
インデックス名やシャードの箱はクリックできるようになっていて、それぞれの情報がJSONで表示されます。
その他にもドキュメント数、サイズなども表示されます。
インデックスの各種操作（closeやdeleteなど）もここからメニューが表示されます。（これも次回詳しく）</p>
<h3 id="ノード">ノード</h3>
<p>ノードの情報が行として表示されます。ノードが増えると下に追加されていきます。
<code>node1</code>というのが、ノード名です。（ヒーローの名前とかが出てくるやつです。）</p>
<p>その他に、IPアドレス、ポート番号、負荷、ヒープサイズなども表示されています。
電源ボタンはノードのシャットダウンを行うためのボタンです。（確認用のダイアログが表示される）</p>
<h3 id="その他">その他</h3>
<p>その他に、クラスタの概要として、ノード数、インデックス数、シャード数、ドキュメント数なども表示されます。
インデックスの作成などは、アイコンから操作が可能です。
大規模なクラスタを管理している場合、検索ボックスを利用することで、インデックス名やノード名による絞込もできるようになっています。</p>
<h2 id="感想">感想</h2>
<p>シンプルな構成の画面で、個人的には<code>head</code>よりも好きな画面です。
<code>HQ</code>よりもシャードの分散具合がわかりやすいので、今後はこのプラグインを利用していこうと考えています。</p>
<p>まずは、簡単な紹介です。今後、各画面についてもう少し説明をブログに書いていこうかと考えています。
待てない方は、触ってみてもらうのが良いかと。
もちろん、続きを書いてもらってもいいですよ！！</p>
</content:encoded>
    </item>
    
    <item>
      <title>いつも入れているElasticsearchのプラグイン</title>
      <link>https://blog.johtani.info/blog/2014/03/11/es-plugin-installed-to-my-env/</link>
      <pubDate>Tue, 11 Mar 2014 14:23:00 +0900</pubDate>
      
      <guid>https://blog.johtani.info/blog/2014/03/11/es-plugin-installed-to-my-env/</guid>
      <description>elasticsearchに、このへん入れるときっと幸せになれるはず・たぶん。&amp;#10;elasticsearch/elasticsearc</description>
      <content:encoded><blockquote class="twitter-tweet" lang="ja"><p>elasticsearchに、このへん入れるときっと幸せになれるはず・たぶん。&#10;elasticsearch/elasticsearch-analysis-kuromoji/1.6.0&#10;oyrusso/elasticsearch-HQ&#10;mobz/elasticsearch-head</p>&mdash; toshi_miura (@toshi_miura) <a href="https://twitter.com/toshi_miura/statuses/441230280041304066">2014, 3月 5</a></blockquote>
<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>
<p>こんなツイートを見かけたので、普段入れてるプラグインを簡単に紹介してみようかと。</p>
<!-- more -->
<p>ローカルの環境に普段入れているプラグインの紹介です。
ちゃんとクラスタを管理しているというよりは、最新版の動作などを確認するための環境になります。なので、ちょっと視点が異なるかもしれませんが参考になればと。</p>
<h2 id="elasticsearch-analysis-kuromoji">elasticsearch-analysis-kuromoji</h2>
<p>URL : <a href="https://github.com/elasticsearch/elasticsearch-analysis-kuromoji">elasticsearch-analysis-kuromoji</a></p>
<p>Kuromojiという日本語形態素解析のTokenizerなどを使えるようにするためのプラグインです。
今度、発売される<a href="http://www.amazon.co.jp/dp/4048662023?tag=johtani-22&amp;camp=243&amp;creative=1615&amp;linkCode=as1&amp;creativeASIN=4048662023&amp;adid=072DC31D3GTPZCBQ6TYW&amp;&amp;ref-refURL=http%3A%2F%2Fblog.johtani.info%2Fblog%2F2014%2F03%2F03%2Frelease-elasticsearch-server-japanese-edition%2F">「ElasticSearch Server」日本語版</a>には付録として、利用方法を執筆しました。参考にしていただければと。
READMEにもサンプルは掲載されてるので、こちらを参考にするのもありですが。</p>
<h2 id="elasticsearch-extended-analyze">elasticsearch-extended-analyze</h2>
<p>URL : <a href="https://github.com/johtani/elasticsearch-extended-analyze">elasticsearch-extended-analyze</a></p>
<p>私が開発しているプラグインです。
Elasticsearchには<code>analyze</code>というAPIが用意されています。
文章を渡すと指定した<code>analyzer</code>などでどのような単語に区切られるかがわかるAPIです。</p>
<p>ただ、<code>analyzer</code>の内部では<code>char filter</code>、<code>tokenizer</code>、<code>token filter</code>という個別のパーツがそれぞれ入力された文字列に対して処理を実施します。
この過程が<code>analyze</code> APIではわかりません。
それをわかるようにしてみたのが<code>elasticsearch-extended-analyze</code>プラグインになります。</p>
<p>詳細については<a href="http://blog.johtani.info/blog/2013/10/25/developing-es-extended-analyze-plugin/">過去の記事</a>を見ていただければと。
画面があると便利だよなぁと思いつつ、作ってない。。。</p>
<h2 id="polyfractalelasticsearch-inquisitor">polyfractal/elasticsearch-inquisitor</h2>
<p>URL : <a href="https://github.com/polyfractal/elasticsearch-inquisitor">elasticsearch-inquisitor</a></p>
<p>クエリのデバッグとかに便利なプラグイン。</p>
<p>こちらも詳細は<a href="http://blog.johtani.info/blog/2013/09/23/intro-elasticsearch-inquisitor/">過去の記事</a>を見ていただければと。</p>
<h2 id="mobzelasticsearch-head">mobz/elasticsearch-head</h2>
<p>URL : <a href="http://mobz.github.io/elasticsearch-head/">elasticsearch-head</a></p>
<p>クラスタ管理に便利なプラグインです。クラスタに存在するノードに対してインデックスのデータ（シャード）がどこに配置されているかなどが一目瞭然になる便利なプラグインです。
プライマリシャードやレプリカなどもわかります。
インデックスの削除もできるし、クエリを投げることもできるし、全部入りな感じのプラグインです。</p>
<p>私個人は、シャードの配置を見るのに主に利用しています。クエリを投げたりインデックスを消したりするのには殆ど使っていません。</p>
<h2 id="royrussoelasticsearch-hq">royrusso/elasticsearch-HQ</h2>
<p>URL : <a href="https://github.com/royrusso/elasticsearch-HQ">elasticsearch-HQ</a></p>
<p>これも管理系のプラグインです。こっちのほうが個人的にスッキリしていて好きなプラグインです。
インデックスの管理やノードの停止などはこちらを主に使用しています。
あくまでもローカルの簡易クラスタを管理する目的というのもあります。</p>
<h2 id="polyfractalelasticsearch-segmentspy">polyfractal/elasticsearch-segmentspy</h2>
<p>URL : <a href="https://github.com/polyfractal/elasticsearch-segmentspy">elasticsearch-segmentspy</a></p>
<p>こちらはモニタリングでしょうか。
ElasticSearch Serverで紹介されていたのが主な理由で、入れてますがあんまり見てないかも。
インデックスのSegment単位の情報が見ることが可能です。
あと、ちょっと更新されてない感じがしますね。</p>
<h2 id="elasticsearchmarvel">elasticsearch/marvel</h2>
<p>Elasticsearch社から提供されている、モニタリングなどに使えるプラグインです。
開発環境では無償提供という感じです。
渡しの場合、モニタリング目的ではなく、senseと呼ばれるクエリの補完をしてくれるツールの目的のために使用しています。
モニタリング部分を停止する方法とかないかなぁ。</p>
<p>詳細については<a href="http://blog.johtani.info/blog/2014/01/29/simple-introduction-and-first-impression-es-marvel/">過去の記事</a>を参考にしていただければと。</p>
<h2 id="まとめ">まとめ？</h2>
<p>ということで、簡単にローカルに入っているプラグインの紹介でした。
他にもいっぱいあるので、おすすめがあれば、教えてもらえると助かります。</p>
</content:encoded>
    </item>
    
    <item>
      <title>elasticsearch-extended-analyzeを公開？</title>
      <link>https://blog.johtani.info/blog/2013/11/14/release-elasticsearch-extended-analyze-0-dot-5/</link>
      <pubDate>Thu, 14 Nov 2013 17:55:00 +0900</pubDate>
      
      <guid>https://blog.johtani.info/blog/2013/11/14/release-elasticsearch-extended-analyze-0-dot-5/</guid>
      <description>どーも。以前の記事で開発中としていたプラグインですが、とりあえず、pluginコマンドでインストール出来る形にしてみました。 インストールなど</description>
      <content:encoded><p>どーも。以前の記事で開発中としていたプラグインですが、とりあえず、pluginコマンドでインストール出来る形にしてみました。</p>
<p>インストールなどについては、<a href="https://github.com/johtani/elasticsearch-extended-analyze">READMEに記載した</a>のでそちらを参照してもらうことにして、試行錯誤した話をメモとして残しておきます。</p>
<!-- more -->
<p>プラグインの開発はしいてたのですが、やっぱりpluginコマンドでインストール出来ないと使ってもらえないよなということで、勉強会も終わったのでちょっと調べてました。</p>
<h2 id="プラグインコマンド">プラグインコマンド</h2>
<p>コマンドが用意されてますが、実態はJavaで実装されてて、通常はこんなかんじでプラグインをインストールします。</p>
<pre><code>./bin/plugin -i elasticsearch/elasticsearch-analysis-kuromoji/1.6.0
</code></pre><p>この「<code>elasticsearch/elasticsearch-analysis-kuromoji/1.6.0</code>」という文字列ですが、「<code>ユーザ名/リポジトリ名/バージョン</code>」という意味になります。</p>
<p>で、ダウンロードするURLは以下のものの中から選ばれます。</p>
<ul>
<li>elasticsearch.orgのダウンロード用サイト</li>
<li>search.maven.org</li>
<li>oss.sonatype.org</li>
<li>Githubのarchive</li>
</ul>
<p>これらのサイトに先ほどのユーザ名、リポジトリ名、バージョンを利用したURLを組み立てて、ダウンロードしてくれるという仕組みになっています。</p>
<p>elasticsearch.orgについては、本家の人しかアップロードできないと思うので、なし。<br>
maven、sonatypeについては、Mavenのリポジトリにリリースする必要があるんじゃないかなと。
で、昔<strike>調べて</strike>ググって途中で挫折したんですが、挫折してます。手順が結構手間で。。。
（参考記事：<a href="http://samuraism.jp/diary/2012/05/03/1336047480000.html">【最新版】Maven Central Repository へのライブラリ登録方法 #maven</a>）</p>
<p>ということで、Githubにアップしたらなんとかなるんじゃん？ということで色々と調査して試してみました。（結果はイマイチなんですが。。。）</p>
<h2 id="その１mvn-releaseprepare">その１：mvn release:prepare</h2>
<p>せっかくGithubだし、せっかくMavenなんだしなんか、pom.xmlに便利な設定したらコマンド一発でリリースできるんじゃない？という甘い気持ちで<strike>調査した</strike>ググったらそれっぽい記事が見つかりました。
「<a href="http://www.kanasansoft.com/weblab/2009/11/integration_between_maven_and_github.html">MavenとGitHubの連携</a>」って記事です。<br>
で、pom.xmlの設定にも他のプラグインを真似してコピペしたものに<code>&lt;scm&gt;</code>ってタグがあったなぁと。このコマンドでついでにGithubにアップロードできるんじゃないの？ということで、試してみました。</p>
<pre><code>mvn release:prepare
</code></pre><p>このコマンドを叩くと、記事にあるとおりにいくつか質問をされます。
タグについては、<code>プロジェクト名-バージョン番号</code>という文字列がデフォルトだと指定されているので、<code>v0.5</code>と変更して実施してみると、Githubのreleaseにv0.5ってのができてるじゃないですか。<br>
※<code>plugin</code>コマンドはGithubを見に行く時に次のファイルをダウンロードしに行きます。</p>
<pre><code>https://github.com/ユーザ名/リポジトリ名/archive/vバージョン名.zip
</code></pre><p>やった！と思い、早速pluginコマンドを実行してみましたが、エラーが出ました。。。</p>
<pre><code>Trying https://github.com/johtani/elasticsearch-extended-analyze/archive/v0.5.zip...
Downloading ...DONE
Installed johtani/elasticsearch-extended-analyze/0.5 into /Users/johtani/projects/tmp/ess_env/second_node/elasticsearch-0.90.7/plugins/extended-analyze
Usage:
    -u, --url     [plugin location]   : Set exact URL to download the plugin from
...省略...

Message:
   Error while installing plugin, reason: IllegalArgumentException: Plugin installation assumed to be site plugin, but contains source code, aborting installation.
</code></pre><p>あらら、なんで？と。<br>
で、実際にgithubにアップされてたzipファイルをダウンロードしてみたら、githubのリポジトリにあるディレクトリ構成がそのまま入ってるじゃないですか。。。
そうですか、そうですよね。prepareだし、タグ打ってzipにかためてくれるだけなんですねと。。。</p>
<p>おそらく、siteプラグイン<em>だけ</em>の場合はこの方法でpluginコマンド叩けばOKなんでしょうが、私がダウンロードしてもらいたいのは.jarファイルが入ったzipファイルなんです。</p>
<p>ということで、断念しました。（タグ消したりをgitコマンドで叩いて綺麗にし直すとか虚しい作業をしてました）</p>
<h2 id="その２githubcomのwebでリリース">その２：github.comのWebでリリース</h2>
<p>おとなしく、Sonatypeのサイトにアップロードする方向でがんばればいいんですが、とりあえず使えるようにするのが先だと思い、
github.comのページでアップロードしてしまおうと。</p>
<p>「release」というタブをクリックすると、画面からアップロードできるようになります。<br>
zipファイルを作ってアップロードしました。（zipファイル自体は<code>mvn package</code>コマンドを実行したら<code>target/release</code>というディレクトリに作成されてる）</p>
<p>これで行けるだろということで、またpluginコマンドを実行すると</p>
<pre><code>Trying https://github.com/johtani/elasticsearch-extended-analyze/archive/v0.5.zip...
Downloading ...DONE
Installed johtani/elasticsearch-extended-analyze/0.5 into /Users/johtani/projects/tmp/ess_env/second_node/elasticsearch-0.90.7/plugins/extended-analyze
Usage:
    -u, --url     [plugin location]   : Set exact URL to download the plugin from
...省略...

Message:
   Error while installing plugin, reason: IllegalArgumentException: Plugin installation assumed to be site plugin, but contains source code, aborting installation.
</code></pre><p>あれ？同じエラー？なんで？jar入りのzipファイルアップロードしたのに？？？</p>
<p>と。で、<code>https://github.com/johtani/elasticsearch-extended-analyze/releases</code>にreleaseのページができてたので見てみると、あら。
アップロードしたファイルについては次のようなURLになってるじゃないですか。</p>
<pre><code>https://github.com/johtani/elasticsearch-extended-analyze/releases/download/v0.5/v0.5.zip
</code></pre><p>で、よく見ると「Source code(zip)」というボタンもあるぞ？このリンクは？</p>
<pre><code>https://github.com/johtani/elasticsearch-extended-analyze/archive/v0.5.zip
</code></pre><p>。。。あぁ。そうですか。そういうことですか。理解してない私が悪いんですねと。</p>
<h2 id="結論">結論？</h2>
<p>ということで、とりあえず、releaseにjar入りファイルはアップロードできた（手動で）ので
<code>-u</code>オプションで直接URL指定すればインストールできるだろ！と諦めました。
いい勉強になりました。。。</p>
<p>README見ていただくとインストール方法が分かりますが、長いです。。。</p>
<p>時間をとって本腰入れてSonatypeにMavenコマンドでアップロードできるようにしようかな。。。</p>
</content:encoded>
    </item>
    
    <item>
      <title>elasticsearch-extended-analyzeの改良</title>
      <link>https://blog.johtani.info/blog/2013/11/04/improve-output-extended-analyze/</link>
      <pubDate>Mon, 04 Nov 2013 22:12:00 +0900</pubDate>
      
      <guid>https://blog.johtani.info/blog/2013/11/04/improve-output-extended-analyze/</guid>
      <description>開発中ですと書きました、elasticsearch-extended-analyzeですが、改良しました。 改良と変更は以下のとおりです。 ソー</description>
      <content:encoded><p><a href="/blog/2013/10/25/developing-es-extended-analyze-plugin/">開発中です</a>と書きました、<a href="https://github.com/johtani/elasticsearch-extended-analyze">elasticsearch-extended-analyze</a>ですが、改良しました。</p>
<!-- more -->
<p>改良と変更は以下のとおりです。</p>
<ul>
<li>ソースのパッケージを<code>org.elasticsearch</code>から<code>info.johtani</code>に。MLで気になったので質問したら、変えたほうがいいよとのこと。ダウンロード化については、もう少々お待ちを。</li>
<li>出力形式を変更。可能な限りCharFilter、Tokenizer、TokenFilterそれぞれが出力する内容を返すようにしました。
<ul>
<li>ただし、既存のAnalyzer（JapaneseAnalyzerクラスとか）に関しては、現時点では出力しません。CharFilterなどを取得するI/Fが見えないためです。（改良できるかの調査は未着手）</li>
</ul>
</li>
</ul>
<p>現時点でできてないのは以下の項目</p>
<ul>
<li>pluginコマンドでインストール</li>
<li>出力したいAttributeの指定</li>
<li>TokenizeChainで変更されたTokenの追跡（現状はどのTokenがStopFilterで消されたかなどが不明）</li>
<li>画面の用意（簡単に確認できる画面）</li>
</ul>
<p>ということで、README.mdに出力サンプルは貼り付けてるので、興味のある方は試してみてください。
不明点などあれば、コメントかIssueかツイートでも。</p>
</content:encoded>
    </item>
    
    <item>
      <title>elasticsearch-extended-analyzeプラグインを開発中</title>
      <link>https://blog.johtani.info/blog/2013/10/25/developing-es-extended-analyze-plugin/</link>
      <pubDate>Fri, 25 Oct 2013 19:06:00 +0900</pubDate>
      
      <guid>https://blog.johtani.info/blog/2013/10/25/developing-es-extended-analyze-plugin/</guid>
      <description>お久しぶりです。 気づいたらまた、結構ブログを書いてなかったです。。。 今回は、今開発しているElasticsearchのプラグインに関するお話</description>
      <content:encoded><p>お久しぶりです。
気づいたらまた、結構ブログを書いてなかったです。。。</p>
<p>今回は、今開発しているElasticsearchのプラグインに関するお話です。</p>
<p>いやぁ、名前決めるの難しいですね。これで英語的に合ってるか不安ですが、<a href="https://github.com/johtani/elasticsearch-extended-analyze">elasticsearch-extended-analyze</a>というプラグインを作っています。</p>
<!-- more -->
<h2 id="どんなもの">どんなもの？</h2>
<p>Solrの管理画面のanalysisに相当する機能が欲しくて作り始めました。</p>
<p>Elasticsearchには<a href="http://www.elasticsearch.org/guide/en/elasticsearch/reference/current/indices-analyze.html">analyze API</a>というAPI（名前あってるのかなぁ?）が存在します。<br>
これは、文字列を投げると、指定したアナライザやトークナイザでどのようなトークンに分割されるかを調べることができるAPIです。</p>
<p>例えば、<a href="https://github.com/elasticsearch/elasticsearch-analysis-kuromoji">elasticsearch-analysis-kuromoji</a>をインストールしたElasticsearchに対して、以下のcurlコマンドを実行します。</p>
<pre><code>curl -XPOST 'localhost:9200/_analyze?tokenizer=kuromoji_tokenizer&amp;filters=kuromoji_baseform&amp;pretty' -d '寿司が美味しい'
</code></pre><p>すると、トークナイズされた結果が次のようなJSONで返ってきます。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-json" data-lang="json">{
  <span style="color:#f92672">&#34;tokens&#34;</span> : [ {
    <span style="color:#f92672">&#34;token&#34;</span> : <span style="color:#e6db74">&#34;寿司&#34;</span>,
    <span style="color:#f92672">&#34;start_offset&#34;</span> : <span style="color:#ae81ff">0</span>,
    <span style="color:#f92672">&#34;end_offset&#34;</span> : <span style="color:#ae81ff">2</span>,
    <span style="color:#f92672">&#34;type&#34;</span> : <span style="color:#e6db74">&#34;word&#34;</span>,
    <span style="color:#f92672">&#34;position&#34;</span> : <span style="color:#ae81ff">1</span>
  }, {
    <span style="color:#f92672">&#34;token&#34;</span> : <span style="color:#e6db74">&#34;が&#34;</span>,
    <span style="color:#f92672">&#34;start_offset&#34;</span> : <span style="color:#ae81ff">2</span>,
    <span style="color:#f92672">&#34;end_offset&#34;</span> : <span style="color:#ae81ff">3</span>,
    <span style="color:#f92672">&#34;type&#34;</span> : <span style="color:#e6db74">&#34;word&#34;</span>,
    <span style="color:#f92672">&#34;position&#34;</span> : <span style="color:#ae81ff">2</span>
  }, {
    <span style="color:#f92672">&#34;token&#34;</span> : <span style="color:#e6db74">&#34;美味しい&#34;</span>,
    <span style="color:#f92672">&#34;start_offset&#34;</span> : <span style="color:#ae81ff">3</span>,
    <span style="color:#f92672">&#34;end_offset&#34;</span> : <span style="color:#ae81ff">7</span>,
    <span style="color:#f92672">&#34;type&#34;</span> : <span style="color:#e6db74">&#34;word&#34;</span>,
    <span style="color:#f92672">&#34;position&#34;</span> : <span style="color:#ae81ff">3</span>
  } ]
}
</code></pre></div><p>トークナイズの結果がわかるのは嬉しいのですが、どんな品詞なのかといったKuromoji固有のTokenの属性情報がなくなってしまいます。</p>
<p>Solrでは、こんな画面が用意されていて、品詞情報とかが出力されます。あとは、各TokenFilterでどのトークンがなくなっているかなどもわかるようになっています。</p>

<link rel="stylesheet" href="/css/hugo-easy-gallery.css" />
<div class="box" >
  <figure  itemprop="associatedMedia" itemscope itemtype="http://schema.org/ImageObject">
    <div class="img">
      <img itemprop="thumbnail" src="/images/entries/20131025/solr_admin_analysis.jpg" />
    </div>
    <a href="/images/entries/20131025/solr_admin_analysis.jpg" itemprop="contentUrl"></a>
  </figure>
</div>

<p>これって結構役立つと思うんですよ。
ということで、Pluginも作ってみたかったので、いい機会だから作ってみようかと。</p>
<h2 id="出力サンプル">出力サンプル</h2>
<p>まずは、その他のAttribute（品詞とか）を表示するところを実装してみました。</p>
<pre><code>curl -XPOST 'localhost:9200/_extended_analyze?tokenizer=kuromoji_tokenizer&amp;filters=kuromoji_baseform&amp;pretty' -d '寿司が美味しい'
</code></pre><p>先ほどとほぼ一緒のcurlコマンドを実行します。違う点は**「_analyze」**が**「_extended_analyze」**となっている点です。<br>
で、実行結果はこんな感じです。（長いですがそのまま載せてます。続きの文章がしたにあります。）</p>
<pre><code>{
  &quot;tokens&quot; : [ {
    &quot;token&quot; : &quot;寿司&quot;,
    &quot;start_offset&quot; : 0,
    &quot;end_offset&quot; : 2,
    &quot;type&quot; : &quot;word&quot;,
    &quot;position&quot; : 1,
    &quot;extended_attributes&quot; : [ {
      &quot;org.apache.lucene.analysis.tokenattributes.TermToBytesRefAttribute#bytes&quot; : &quot;[e5 af bf e5 8f b8]&quot;
    }, {
      &quot;org.apache.lucene.analysis.tokenattributes.PositionLengthAttribute#positionLength&quot; : 1
    }, {
      &quot;org.apache.lucene.analysis.ja.tokenattributes.BaseFormAttribute#baseForm&quot; : null
    }, {
      &quot;org.apache.lucene.analysis.ja.tokenattributes.PartOfSpeechAttribute#partOfSpeech&quot; : &quot;名詞-一般&quot;
    }, {
      &quot;org.apache.lucene.analysis.ja.tokenattributes.PartOfSpeechAttribute#partOfSpeech (en)&quot; : &quot;noun-common&quot;
    }, {
      &quot;org.apache.lucene.analysis.ja.tokenattributes.ReadingAttribute#reading&quot; : &quot;スシ&quot;
    }, {
      &quot;org.apache.lucene.analysis.ja.tokenattributes.ReadingAttribute#reading (en)&quot; : &quot;sushi&quot;
    }, {
      &quot;org.apache.lucene.analysis.ja.tokenattributes.ReadingAttribute#pronunciation&quot; : &quot;スシ&quot;
    }, {
      &quot;org.apache.lucene.analysis.ja.tokenattributes.ReadingAttribute#pronunciation (en)&quot; : &quot;sushi&quot;
    }, {
      &quot;org.apache.lucene.analysis.ja.tokenattributes.InflectionAttribute#inflectionType&quot; : null
    }, {
      &quot;org.apache.lucene.analysis.ja.tokenattributes.InflectionAttribute#inflectionType (en)&quot; : null
    }, {
      &quot;org.apache.lucene.analysis.ja.tokenattributes.InflectionAttribute#inflectionForm&quot; : null
    }, {
      &quot;org.apache.lucene.analysis.ja.tokenattributes.InflectionAttribute#inflectionForm (en)&quot; : null
    }, {
      &quot;org.apache.lucene.analysis.tokenattributes.KeywordAttribute#keyword&quot; : false
    } ]
  }, {
    &quot;token&quot; : &quot;が&quot;,
    &quot;start_offset&quot; : 2,
    &quot;end_offset&quot; : 3,
    &quot;type&quot; : &quot;word&quot;,
    &quot;position&quot; : 2,
    &quot;extended_attributes&quot; : [ {
      &quot;org.apache.lucene.analysis.tokenattributes.TermToBytesRefAttribute#bytes&quot; : &quot;[e3 81 8c]&quot;
    }, {
      &quot;org.apache.lucene.analysis.tokenattributes.PositionLengthAttribute#positionLength&quot; : 1
    }, {
      &quot;org.apache.lucene.analysis.ja.tokenattributes.BaseFormAttribute#baseForm&quot; : null
    }, {
      &quot;org.apache.lucene.analysis.ja.tokenattributes.PartOfSpeechAttribute#partOfSpeech&quot; : &quot;助詞-格助詞-一般&quot;
    }, {
      &quot;org.apache.lucene.analysis.ja.tokenattributes.PartOfSpeechAttribute#partOfSpeech (en)&quot; : &quot;particle-case-misc&quot;
    }, {
      &quot;org.apache.lucene.analysis.ja.tokenattributes.ReadingAttribute#reading&quot; : &quot;ガ&quot;
    }, {
      &quot;org.apache.lucene.analysis.ja.tokenattributes.ReadingAttribute#reading (en)&quot; : &quot;ga&quot;
    }, {
      &quot;org.apache.lucene.analysis.ja.tokenattributes.ReadingAttribute#pronunciation&quot; : &quot;ガ&quot;
    }, {
      &quot;org.apache.lucene.analysis.ja.tokenattributes.ReadingAttribute#pronunciation (en)&quot; : &quot;ga&quot;
    }, {
      &quot;org.apache.lucene.analysis.ja.tokenattributes.InflectionAttribute#inflectionType&quot; : null
    }, {
      &quot;org.apache.lucene.analysis.ja.tokenattributes.InflectionAttribute#inflectionType (en)&quot; : null
    }, {
      &quot;org.apache.lucene.analysis.ja.tokenattributes.InflectionAttribute#inflectionForm&quot; : null
    }, {
      &quot;org.apache.lucene.analysis.ja.tokenattributes.InflectionAttribute#inflectionForm (en)&quot; : null
    }, {
      &quot;org.apache.lucene.analysis.tokenattributes.KeywordAttribute#keyword&quot; : false
    } ]
  }, {
    &quot;token&quot; : &quot;美味しい&quot;,
    &quot;start_offset&quot; : 3,
    &quot;end_offset&quot; : 7,
    &quot;type&quot; : &quot;word&quot;,
    &quot;position&quot; : 3,
    &quot;extended_attributes&quot; : [ {
      &quot;org.apache.lucene.analysis.tokenattributes.TermToBytesRefAttribute#bytes&quot; : &quot;[e7 be 8e e5 91 b3 e3 81 97 e3 81 84]&quot;
    }, {
      &quot;org.apache.lucene.analysis.tokenattributes.PositionLengthAttribute#positionLength&quot; : 1
    }, {
      &quot;org.apache.lucene.analysis.ja.tokenattributes.BaseFormAttribute#baseForm&quot; : null
    }, {
      &quot;org.apache.lucene.analysis.ja.tokenattributes.PartOfSpeechAttribute#partOfSpeech&quot; : &quot;形容詞-自立&quot;
    }, {
      &quot;org.apache.lucene.analysis.ja.tokenattributes.PartOfSpeechAttribute#partOfSpeech (en)&quot; : &quot;adjective-main&quot;
    }, {
      &quot;org.apache.lucene.analysis.ja.tokenattributes.ReadingAttribute#reading&quot; : &quot;オイシイ&quot;
    }, {
      &quot;org.apache.lucene.analysis.ja.tokenattributes.ReadingAttribute#reading (en)&quot; : &quot;oishii&quot;
    }, {
      &quot;org.apache.lucene.analysis.ja.tokenattributes.ReadingAttribute#pronunciation&quot; : &quot;オイシイ&quot;
    }, {
      &quot;org.apache.lucene.analysis.ja.tokenattributes.ReadingAttribute#pronunciation (en)&quot; : &quot;oishii&quot;
    }, {
      &quot;org.apache.lucene.analysis.ja.tokenattributes.InflectionAttribute#inflectionType&quot; : &quot;形容詞・イ段&quot;
    }, {
      &quot;org.apache.lucene.analysis.ja.tokenattributes.InflectionAttribute#inflectionType (en)&quot; : &quot;adj-group-i&quot;
    }, {
      &quot;org.apache.lucene.analysis.ja.tokenattributes.InflectionAttribute#inflectionForm&quot; : &quot;基本形&quot;
    }, {
      &quot;org.apache.lucene.analysis.ja.tokenattributes.InflectionAttribute#inflectionForm (en)&quot; : &quot;base&quot;
    }, {
      &quot;org.apache.lucene.analysis.tokenattributes.KeywordAttribute#keyword&quot; : false
    } ]
  } ]
}
</code></pre><p>先ほどの結果に**「extended_attributes」**という配列のオブジェクトが追加された形になっています。
ちょっと長くなってしまいましたが。。。</p>
<p>Solrの処理を真似して作ったので大したことはやってないんですが、少しは便利になるかもなぁと。</p>
<p>現時点では、最終的な結果しか取得できないですが、今後は次のような機能を作っていこうかと思っています。
できるかどうかは、やってみてって感じですが。</p>
<ul>
<li>pluginコマンドでインストール
<ul>
<li>pom.xmlはありますが、まだMavenとかに登録はされていません。ですので、<code>mvn package</code>してからjarファイルをpluginsフォルダに配置しないといけません。pluginコマンドでインストールできるともっと使ってもらえるはず？</li>
</ul>
</li>
<li>出力したいAttributeの指定
<ul>
<li>リクエストパラメータで、出力したいAttribute名を指定するとか。</li>
</ul>
</li>
<li>出力形式の変更
<ul>
<li>今は、Solrの真似をしていますが、せっかくJSONだったりするので、もう少し検討しようかと（同じAttributeの異なる値も1オブジェクトとして出力されてる）</li>
</ul>
</li>
<li>TokenizeChainの出力
<ul>
<li>Solr同様、CharFilter、Tokenizer、TokenFilterが動作して、最終的なTokenがインデックスに登録されます。ですので、各処理の直後のTokenがどうなっているかもわかったほうが嬉しいと思うので、それらも取得できるようにしたいなぁと</li>
</ul>
</li>
<li>画面の用意
<ul>
<li>せっかくプラグインなんだし、画面で見れると嬉しいかなと。これは当分先になっちゃうと思いますが、Webページで確認できるような画面を作ると確認しやすくなるかなぁと。上記対応が終わってから取替かかると思いますが。</li>
</ul>
</li>
</ul>
<p>とりあえず、思いつくのはこんなかんじです。</p>
<p>Elasticsearchの_analyze APIを真似しただけのコードだし、テストも実装もまだまだですが、とりあえず公開してみました。</p>
<p>要望などあれば、コメント、Issue、ツイート（もちろん、テストコードなども！）なんでも受け付けてますので、お気軽に。</p>
</content:encoded>
    </item>
    
    <item>
      <title>elasticsearch-inquisitorプラグインの紹介</title>
      <link>https://blog.johtani.info/blog/2013/09/23/intro-elasticsearch-inquisitor/</link>
      <pubDate>Mon, 23 Sep 2013 12:27:00 +0900</pubDate>
      
      <guid>https://blog.johtani.info/blog/2013/09/23/intro-elasticsearch-inquisitor/</guid>
      <description>今日は、ElasticSearchのMLで見つけたelasticsearch-inquisitorプラグインの紹介です。 ElasticSea</description>
      <content:encoded><p>今日は、ElasticSearchのMLで見つけた<a href="https://github.com/polyfractal/elasticsearch-inquisitor">elasticsearch-inquisitor</a>プラグインの紹介です。</p>
<p>ElasticSearchはREST API形式で簡単にコマンドラインからいろいろな処理を実行できて便利ですが、
GUIがあったほうが楽なこともまた事実です。
今回紹介する、inquisitorプラグインもSiteプラグイン（Webブラウザでアクセスできるプラグイン）の1つです。
（ただし、ローカルにインストールしてローカルのElasticSearchにしか接続できませんが。。。）</p>
<!-- more -->
<h2 id="インストール">インストール</h2>
<p>プラグインですので、以下のコマンドでインストールが出来ます。インストール後はElasticSearchの再起動が必要です。</p>
<pre><code>bin/plugin -install polyfractal/elasticsearch-inquisitor
</code></pre><p>ElasticSearch再起動後に、以下のURLにアクセスすればOKです。
※ローカルでのみ動作可能なプラグインです。（内部で呼び出しているJSにlocalhostと記載があるため）</p>
<pre><code>http://localhost:9200/_plugin/inquisitor/#/
</code></pre><h2 id="何ができるの">何ができるの？</h2>
<p>自分の書いたQueryが正しく動作するかや、Analyzerによって文章がどのように、Term（Token）に分割されるかといった挙動をWebブラウザ上で確認することができます。用意されている画面は「Queries」「Analyzers」「Tokenizers」の3種類です。</p>
<h3 id="queries">Queries</h3>
<p>クエリの確認、実行が可能な画面です。</p>

<link rel="stylesheet" href="/css/hugo-easy-gallery.css" />
<div class="box" >
  <figure  itemprop="associatedMedia" itemscope itemtype="http://schema.org/ImageObject">
    <div class="img">
      <img itemprop="thumbnail" src="/images/entries/20130923/queries_sample.jpg" />
    </div>
    <a href="/images/entries/20130923/queries_sample.jpg" itemprop="contentUrl"></a>
  </figure>
</div>

<p>「Index」「Type」はプルダウンになっており、現在ElasticSearchに存在しているものが選択可能です。
その下のテキストエリアがクエリを入力する画面です。</p>
<p>クエリを入力していると、入力しているクエリがValidかどうかをクエリのコンソール部分（右側上部）に表示してくれます。</p>


<div class="box" >
  <figure  itemprop="associatedMedia" itemscope itemtype="http://schema.org/ImageObject">
    <div class="img">
      <img itemprop="thumbnail" src="/images/entries/20130923/query_error.jpg" />
    </div>
    <a href="/images/entries/20130923/query_error.jpg" itemprop="contentUrl"></a>
  </figure>
</div>

<p>少し残念なことに、Tabを押すと、フォームのフォーカスが切り替わってしまうので、クエリを入力するのがちょっと面倒です。。。（私は通常の検索には、<a href="https://chrome.google.com/webstore/detail/sense/doinijnbnggojdlcjifpdckfokbbfpbo">ChromeプラグインのSense</a>というものを利用してます。）</p>
<p>クエリに問題がない場合は、「Query」ボタンを押すことで実際の検索が実行されます。
この時、画面真ん中のブルーのテーブル（内部で実行されるクエリ）の部分に、QueryがElasticSearch内部で解釈されたあとの、Luceneで実行されるレベルのクエリに変換されたクエリが表示されます。</p>
<p>これが便利です。JSONで記述したり、色々なタイプのクエリがElasticSearchでは実行できますが、望んだ形に単語が区切られているかなどを確認することができるため、非常に便利です。</p>
<p>ElasticSearchのQuery DSLでは<a href="http://www.elasticsearch.org/guide/reference/api/search/explain/">explain</a>をtrueにすることで、ヒットしたドキュメントのスコア計算に用いられた単語などがわかるのですが、そもそもヒットしないクエリの場合は、explainでは単語の区切られ方などがわかりません。</p>
<p>その場合に、このプラグインで確認すると、想定と違う単語の区切られ方やクエリの造られ方がわかるかと思います。</p>
<h3 id="analyzers">Analyzers</h3>
<p>Analyzerによる文章のアナライズ結果の確認が出来る画面です。
ElasticSearchやSolrにあまり詳しくない場合、どんなAnalyzerが文章をどのように単語に区切って、転置インデックスのキーワードとして利用しているかがわからないと思います。</p>
<p>このAnalyzerが文章をどのように単語に区切っているかを確認することができるのがAnalyzers画面です。
こんなかんじの画面になります。</p>


<div class="box" >
  <figure  itemprop="associatedMedia" itemscope itemtype="http://schema.org/ImageObject">
    <div class="img">
      <img itemprop="thumbnail" src="/images/entries/20130923/analyzers_sample.jpg" />
    </div>
    <a href="/images/entries/20130923/analyzers_sample.jpg" itemprop="contentUrl"></a>
  </figure>
</div>

<p>一番上のテキストエリアが文章を入力する場所です。
文章を入力していくと、その下のテーブルの「Analyzed Text」の部分が変化していくのが分かります。
このグレーの単語が転置インデックスのキーワードとなります。</p>
<p>予め用意されているAnalyzer以外に、用意されているTokenzier＋Filterの組み合わせも簡単ですが確認可能です。（Tokenizer、Filtersとあるテーブル）
ただし、ここまでのどちらも細かな設定は画面上ではできません（Filterの細かな引数の指定など）</p>
<p>一番下の部分が、ElasticSearchに存在しているインデックスごとに定義されたAnalyzerやフィールドを元にした解析結果を表示することができる領域です。</p>
<p>自分でマッピングを記述してフィールド定義したものの動作確認や、インデックスを適当に作ったけど、うまくヒットしない場合など、ここで、単語の区切れ方を確認することで、検索になぜヒットしないのかといった問題のヒントを得ることができると思います。</p>
<p>Analyzerによっては、インデックス対象の文字として扱わない文字があったりしますので。
先ほどのQueries画面のLuceneに投げられる直前のクエリと、Analyzersでの単語の区切られ方を確認することで、検索がうまくヒットしていないことが判明すると思います。</p>
<h3 id="tokenizers">Tokenizers</h3>
<p>最後はTokenizers画面です。Analyzersとほぼ同様ですが、ちがいは、デフォルトで用意されているTokenizerの挙動の確認ができるというだけになります。</p>


<div class="box" >
  <figure  itemprop="associatedMedia" itemscope itemtype="http://schema.org/ImageObject">
    <div class="img">
      <img itemprop="thumbnail" src="/images/entries/20130923/tokenizers_sample.jpg" />
    </div>
    <a href="/images/entries/20130923/tokenizers_sample.jpg" itemprop="contentUrl"></a>
  </figure>
</div>

<p>簡単な確認ならここで可能かと。</p>
<h2 id="注意点は">注意点は？</h2>
<p>まだ開発途中のようで、つぎの部分が課題かと。</p>
<ul>
<li>ローカルでのみ実行可能</li>
<li>Queries画面の結果の「Explain Result」リンクが未実装</li>
<li>Queries画面のクエリ入力が使いにくい（タブが打てないので）</li>
<li>カスタム登録のAnalyzersはインデックスを用意しないと確認できない。（Kuromojiのプラグインを登録しただけでは確認できなかった）</li>
<li>細かな設定のフィールドも用意しないと、Analyzers画面では利用できない</li>
</ul>
<h2 id="まとめ">まとめ</h2>
<p>ということで、Inquisitor（読みがわからない）プラグインの簡単な説明でした。
検索にうまくヒットしないという理由は大体の場合、
クエリに入力した文字列が単語に区切られたものと、登録したデータが単語に区切られたものが異なるために検索にヒットしないというものです。</p>
<p>そのクエリ、データの単語の区切られ方を確認するのに役に立つプラグインじゃないでしょうか。</p>
<p>ちなみに、このプラグイン自体はHTML＋JSで作成されており、実際にはElasticSearchが持っているREST APIをキックしているだけになります。
ですので、Web画面なんか要らないという方は、このプラグインが実際に送信しているリクエストを参考にするとcurlコマンドでどういったリクエストを投げればいいかというのがわかると思います。</p>
<p>私は軟弱者なので画面があったほうがいいですが。</p>
</content:encoded>
    </item>
    
  </channel>
</rss>
