<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Rust on @johtaniの日記 3rd</title>
    <link>https://blog.johtani.info/tags/rust/</link>
    <description>Recent content in Rust on @johtaniの日記 3rd</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja</language>
    <lastBuildDate>Mon, 05 Oct 2020 11:36:18 +0900</lastBuildDate><atom:link href="https://blog.johtani.info/tags/rust/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>LinderaのFSTをDoubleArrayTrieに変更した話</title>
      <link>https://blog.johtani.info/blog/2020/10/05/switch-fst-2-da/</link>
      <pubDate>Mon, 05 Oct 2020 11:36:18 +0900</pubDate>
      
      <guid>https://blog.johtani.info/blog/2020/10/05/switch-fst-2-da/</guid>
      <description>2020/10/06 11:00くらいにマージされました。 @minoru_osuka さんが開発を引き継いだLinderaというKuromojiのRustクローンがあります(リポジトリ)</description>
      <content:encoded><blockquote>
<p>2020/10/06 11:00くらいにマージされました。</p>
</blockquote>
<p><a href="https://twitter.com/minoru_osuka">@minoru_osuka</a> さんが開発を引き継いだ<a href="https://qiita.com/mosuka/items/0fdaaf91f5530d427dc7">LinderaというKuromojiのRustクローン</a>があります(<a href="https://github.com/lindera-morphology/lindera">リポジトリ</a>)
。
最近趣味でRustを勉強しているので、こちらを少し手伝っています。</p>
<p>Rustの勉強仲間である<a href="https://twitter.com/takuya_b">@takuya_b</a>さんや<a href="https://twitter.com/ikawaha">@ikawaha</a>さんと話をしているときに、FST部分をDouble Array Trieに置き換えると速度が向上するのでは?という話が出まして、@takuya_bさんがDouble Array Trieを作るらしいという話になったので、下準備などをしつつ、作ってもらったライブラリ<a href="https://github.com/takuyaa/yada">yada</a>を組み込んでみたという話です。</p>
<h2 id="ベンチマークの追加">ベンチマークの追加</h2>
<p>下準備として、今のLindera(FST実装)がどのくらいの性能なのか?というのを計っておく必要があります。
幸いにも、Linderaのオリジナルの開発者の方が、<a href="https://github.com/bheisler/criterion.rs">criterion.rs</a>というライブラリを使った<a href="https://github.com/lindera-morphology/lindera/blob/581728bf790a331402ef7a200fd443c4f9244abd/lindera/benches/bench.rs">ベンチマークプログラム</a>を作成してくれていました。</p>
<p>ただ、1種類だけだと少し心もとないなというのと、長い文章やパターンを増やしたほうが良さそうだなということで、
ベンチマーク自体をいくつか追加しました(<a href="https://github.com/lindera-morphology/lindera/pull/74">追加したときのPR</a>)。</p>
<p>種類としては、5種類のベンチマークです。</p>
<ol>
<li>システム辞書のみのTokenizerのコンストラクタ呼び出し</li>
<li>カスタム辞書ありのTokenizerのコンストラクタ呼び出し</li>
<li>システム辞書のみのTokenizerの<code>tokenize</code>処理の呼び出し</li>
<li>カスタム辞書ありのTokenizerの<code>tokenize</code>処理の呼び出し</li>
<li>青空文庫の坊っちゃんのテキストをシステム辞書のみのTokenizerで<code>tokenize</code></li>
</ol>
<p>1,2はコンストラクタ部分だけの処理をベンチマークテストする目的で作成しました。
LinderaはTokenizerがtokenize処理するのに利用するデータをいくつか内部で保持しています。
これらはファイルにシリアライズされており、Tokenizerのオブジェクト生成時に読み込みやデシリアライズ処理が発生します。
この部分だけも速度を計測したい目的でコンストラクタだけを切り出しました。</p>
<p>3,4はTokenizerのメインの処理です。コンストラクタはベンチマークの対象外にしました。
純粋にtokenizeの処理だけを切り出して計測するためです。
カスタム辞書がある場合、ない場合は念の為切り出した形になっています。</p>
<p>5は長い文章(文章が多いのでバリエーションも増える)を扱いたいために別にしました。</p>
<p>これで、一応下準備が完了です。
ちなみに、Criterionは賢くて、前のベンチマークの結果と最新の結果を比較してくれる機能があります。
どんな感じで出てくるかはベンチマーク結果をご覧ください。</p>
<h2 id="yadaの組み込み">yadaの組み込み</h2>
<p>ベンチマークの準備をしていたところyadaがリリースされたので、Linderaへの組み込みを検討し始めました。</p>
<blockquote class="twitter-tweet"><p lang="ja" dir="ltr">というわけで、またダブル配列を書いてしまったので crate として公開しました。フィードバックお待ちしております！ <a href="https://t.co/As7h0tfmjf">https://t.co/As7h0tfmjf</a></p>&mdash; takuya-a (@takuya_b) <a href="https://twitter.com/takuya_b/status/1307671030731694081?ref_src=twsrc%5Etfw">September 20, 2020</a></blockquote>
<script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>

<h3 id="中身の理解">中身の理解</h3>
<p>lindera-fstを利用して、prefix searchしている処理があるので、そこで利用しているFSTをyadaに置き換えれば良さそうだと判断して、
処理を読んでいきます。</p>
<ul>
<li>Tokenizerは、<a href="https://github.com/lindera-morphology/lindera/blob/027ab8c7d5fdd6d1bc2dc7e8779adb1ddcf7f770/lindera-core/src/core/prefix_dict.rs">PrefixDict</a>という構造体でlindera-fstを利用している
<ul>
<li><a href="https://github.com/lindera-morphology/lindera/blob/027ab8c7d5fdd6d1bc2dc7e8779adb1ddcf7f770/lindera-core/src/core/prefix_dict.rs#L27-L64">prefixメソッド</a>が入力文字列を元に、FSTを前方一致検索して、ヒットした単語の情報をIteratorとして取り出せる(単語の情報は「入力文字列の先頭からの文字数」と「ヒットした単語のWordEntry構造体」)</li>
<li>PrefixDictのfstは辞書(例：ipadic)ごとに<code>lindera-&lt;辞書名&gt;-builder</code>で生成される</li>
</ul>
</li>
<li>システム辞書としては、デフォルトでは<code>lindera-ipadic-builder</code>でfstを構築している
<ul>
<li><a href="https://github.com/lindera-morphology/lindera/blob/027ab8c7d5fdd6d1bc2dc7e8779adb1ddcf7f770/lindera-ipadic-builder/src/lib.rs#L237-L249">構築処理はこの辺</a></li>
</ul>
</li>
</ul>
<p>という感じです。
また、辞書周りのファイルがそれぞれどんな役割なのか、どんなデータの持ち方をしているのか?といった点を、変更点の調査のついでに書き出してみました。<a href="https://github.com/lindera-morphology/lindera/blob/master/lindera-dictionary/FILES.md">lindera-dictionary/FILES.md</a>。TODOになっている部分も追記が終わっています(<a href="https://github.com/lindera-morphology/lindera/pull/77">PR</a>)</p>
<h3 id="変更点">変更点</h3>
<p>実際に変更したプログラムの詳細についてはの<a href="https://github.com/lindera-morphology/lindera/pull/76">PR</a>を見ていただくとして、簡単には以下の点になります。</p>
<ol>
<li>Rustのバージョンを1.46.0に(おもにREADME.md)
<ul>
<li>yadaが利用している機能に1.46.0で導入された機能があるため</li>
</ul>
</li>
<li>lindera-fstをyadaに変更(lindera-core/Cargo.toml, lindera-ipadic-builder/Cargo.toml)
<ul>
<li>合わせて、<code>dict.fst</code>というファイル名を<code>dict.da</code>に変更</li>
</ul>
</li>
<li><code>dict.da</code>に関して構築部分と検索部分を変更
<ul>
<li>FSTではFSTから返ってくる値(入力文字列に出てきた単語に関連する値)は<code>u64</code>だったが、yadaのDoubleArrayが<code>u32</code>しか扱えないため、<code>u32</code>に変更。テストの記述はしていないが、扱うデータ的に<code>u32</code>で問題なさそうだったので。</li>
<li>検索部分：PrefixDict構造体の<code>prefix</code>メソッドで<code>DoubleArray</code>の<code>prefix_common_search</code>を使用
<ul>
<li>DoubleArray自体が<code>prefix_common_search</code>のメソッドを持っていたので、処理が簡単に置き換え可能だった。FSTは<code>prefix</code>メソッド内で独自で前方一致検索を実装していた。</li>
</ul>
</li>
<li>構築部分：<code>lindera-ipadic-builder/src/lib.rs</code>の<code>build_dict</code>と<code>build_user_dict</code>の<code>dict.da</code>構築処理
<ul>
<li>ipadicのCSVファイルを読み込んで、見出し語をキーに、辞書にある単語情報のベクタを値とするBTreeMapを生成し、このBTreeMapに基づいてFSTを構築していた部分をDoubleArray構築処理に置き換えた。</li>
<li>シフト演算などで、実際の値(<code>dict.vals</code>)へのポインタを作っていたのだが、ここの処理を読み解くために<code>FILES.md</code>を書き出した。</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>という感じです。そもそもデータ構造がどうなっているのか?から読み解いて、変更部分を洗い出して変更していった形になります。
取り込み作業中にいくつか<code>yada</code>に要望(<a href="https://github.com/takuyaa/yada/issues?q=is%3Aissue+is%3Aclosed">このへん</a>)を上げて、変更を取り込んでもらい、最終的にyadaのバージョン<code>0.3.2</code>で問題なく動きそうだという形になりました。<a href="https://twitter.com/takuya_b">@takuya_b</a>さん、対応ありがとうございました。</p>
<h4 id="エッジケースバグの発見">エッジケースバグの発見</h4>
<p>作っててよかった、テストケースでした(実際にはベンチマークテストですが)。
取り込み作業中に、Lindera本体の<code>cargo test</code>はすべてOKになるが、ベンチマークを取ろうとしたときに、坊っちゃんの文字列を入力にしたベンチマークが失敗するという事象が発生しました(<a href="https://github.com/lindera-morphology/lindera/pull/76#issuecomment-699735905">PRのコメント参照</a>)。
切り分けのために、入力の文章のどこでおかしくなるのか?DoubleArrayの<code>build</code>メソッドに渡している値がおかしくないか?などをすこしずつ調べていくと次のバグが判明したという感じです。</p>
<p>特定のデータ(ipadicの見出し語一覧)をDoubleArrayに入れて、特定の文字列(<code>「は相」</code>)を<code>common_prefix_search</code>にいれたら、
返ってくる情報(0から何バイト目の文字が一覧に存在した)が、不正な値が返ってくるというバグでした。
@takuya_bさんに見てもらいつつ(DoubleArrayの中身わからん。。。)、修正してもらいました。素早い対応ありがとうございます。</p>
<blockquote class="twitter-tweet"><p lang="ja" dir="ltr">yada 0.3.1 をリリースしています。特定の条件で不正な遷移を許すダブル配列が構築されてしまうバグを修正しています。このエッジケースは <a href="https://twitter.com/johtani?ref_src=twsrc%5Etfw">@johtani</a> さんが見つけてくださいました。ありがとうございました！ <a href="https://t.co/CiftZi5GDn">https://t.co/CiftZi5GDn</a></p>&mdash; takuya-a (@takuya_b) <a href="https://twitter.com/takuya_b/status/1311153143971864576?ref_src=twsrc%5Etfw">September 30, 2020</a></blockquote>
<script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>

<p>やはり、いろんな文字列入れてテストしてみるの重要ですね。
ということで、ベンチマークだけでなく、テストケースとしても坊っちゃんのファイルを読み込んでトークナイズするようにPRでテストケースを追加しています。</p>
<h2 id="ベンチマーク結果">ベンチマーク結果</h2>
<p>yadaを利用した変更が終わったので、再度<code>cargo bench</code>を実行して計測です。
計測としては、<code>master</code>ブランチでまず<code>cargo bench</code>を実行し、yadaの実装をしたブランチに切り替えてから<code>cargo bench</code>を実行します。
すると、Criterion? <code>cargo bench</code>が、最終的な結果に前回との差分でどのくらい性能が改善、改悪したかも合わせて出力してくれます。
実行環境と結果は以下のとおりです。</p>
<ul>
<li>MacBook Pro 16インチ
<ul>
<li>CPU：Core i7 6コア 2.6GHz</li>
<li>メモリ：32GB</li>
</ul>
</li>
</ul>

<link rel="stylesheet" href="/css/hugo-easy-gallery.css" />
<div class="box" style="max-width:600">
  <figure  itemprop="associatedMedia" itemscope itemtype="http://schema.org/ImageObject">
    <div class="img">
      <img itemprop="thumbnail" src="/images/entries/20201005/bench.png" />
    </div>
    <a href="/images/entries/20201005/bench.png" itemprop="contentUrl"></a>
  </figure>
</div>

<p>コンストラクタのベンチマークについては10%ほど性能が悪くなっています。
これは、FSTよりもDoubleArrayTrieのほうがデータが大きくなってしまうためだと思われます。
実際にファイルのサイズは次のようになりました。yada(DoubleArrayTrie)のほうが2倍以上大きいことがわかります。
また、このファイル以外にもLinderaが利用しているデータはありますが、それらは今回変更の対象にはなっていません。
なので、単純にこのファイルの読み込みの処理に時間がかかっているのだと想像できます。</p>
<ul>
<li><em><strong>2147765</strong></em> / FST / dict.fst</li>
<li><em><strong>5425152</strong></em> / yada / dict.da</li>
</ul>
<p><code>tokenize</code>のベンチマークについては、11%〜28%の改善が見られました。
文章から、内部に保持している辞書に存在する単語を見つけ出す処理に利用されるのがFST、DoubleArrayTrieです。
今回の変更では、この処理に利用しているデータ構造だけを変更しました。
実際には</p>
<ul>
<li>DoubleArrayTrieを用いた単語の検索処理</li>
<li>見つかった単語の持つ値(<code>data.vals</code>のオフセット情報)を元にシフト演算</li>
</ul>
<p>といった処理が実行されます。シフト演算は<code>u64</code>だったものが<code>u32</code>に変更されたくらいなので、大した処理量ではないかと。
大部分はDoubleArrayTrieを利用したルックアップ処理が速度向上に寄与していると思います。</p>
<h2 id="まとめ">まとめ</h2>
<p>最近Linderaに加えた変更、作ったPRについて少しブログにまとめてみました。
ちなみに、まだPRの段階でレビュー&amp;リリース待ちという感じです。</p>
<p>実際には作ってもらったライブラリを組み込んでみたというだけなのですが、速度が向上した結果が見れたのは面白いです。
また、基本的なデータ構造とかアルゴリズムの勉強にもなりました(2次元配列を1次元配列に押し込むとか)。このへんも今後も勉強していきたいです。</p>
<p>組み込む際に色々と協力していただいた@takuya_bさん、@ikawahaさん、巻き込んでくれた@minoru_osukaさんに改めて感謝いたします。</p>
<p>Rustや形態素解析のプログラムの勉強を兼ねて、今後もなにか改善できる部分がないかなどを見ていこうと思っています。
Rustで形態素解析をしたいという人がどのくらいいるかはわかりませんが、おかしなところや疑問点などあればコメントください。</p>
</content:encoded>
    </item>
    
    <item>
      <title>meteredクレートの紹介</title>
      <link>https://blog.johtani.info/blog/2020/09/07/intro-metered-rs/</link>
      <pubDate>Mon, 07 Sep 2020 23:11:40 +0900</pubDate>
      
      <guid>https://blog.johtani.info/blog/2020/09/07/intro-metered-rs/</guid>
      <description>Rustで便利なクレートを見つけたので、紹介がてら、自分のメモのためにブログに残しておきます。 そもそもの問題 Rustで処理を書いていて、なん</description>
      <content:encoded><p>Rustで便利なクレートを見つけたので、紹介がてら、自分のメモのためにブログに残しておきます。</p>
<h2 id="そもそもの問題">そもそもの問題</h2>
<p>Rustで処理を書いていて、なんかちょっと遅いな?どこの処理で時間がかかってるんだろう?
ということがありませんか?ありますよね?</p>
<p>というのを調べるために、最初に思いつくのは自分で計測する方法です。
流石にそれはなぁ、と思ったのでググって出てきた方法を最初は使っていました。</p>
<ul>
<li><a href="https://qiita.com/pseudo_foxkeh/items/5d5226e3ffa27631e80d">Rustで実行時間計測</a></li>
</ul>
<p>3年前の記事ですが、とりあえず計測する分には問題なかったのでこちらの方が書いていたマクロを拝借していました。
が、ちょっと面倒なのが戻り値がある処理などのときに、このマクロを挟むのが結構めんどくさいなと。
また、処理の時間を測りたいのは基本的にはメソッドや関数単位であることが多いです。</p>
<p>で、さらにググっていて見つけたのが、<a href="https://crates.io/crates/metered">metered</a>でした。</p>
<h2 id="どんなもの">どんなもの?</h2>
<p>計測したい部分に<code>#[metric]</code>のようなアノテーションを追加することで計測対象としてくれます。
あとは、計測したものを保存するレジストリという場所を指定するだけです。
処理が終わったタイミングなどで、そのレジストリの内容を出力することで、次の情報を計測することができます。</p>
<ul>
<li>HitCount : 実行された回数</li>
<li>ErrorCount : エラーを返した数(<code>Result</code>を戻り値にしているメソッドが対象)</li>
<li>InFlight : 処理中の回数かな?</li>
<li>ResponseTime : レスポンスタイム(処理に何秒かかったか)</li>
<li>Throughput : スループット(1秒あたり何回呼ばれたか)</li>
</ul>
<p>とりあえず試してみたのは、ResponseTimeとThroughputです。他のメトリクスはまた後日(機会があれば)。
また、<code>metered::metric::Metric</code>トレイトというものが用意されているようで、これを実装した独自のメトリクスも扱うことができるようです。</p>
<h2 id="使い方">使い方</h2>
<p>使い方としては次のようになります。</p>
<ul>
<li>計測対象となるメソッドがある構造体に、メトリクスを保持するためのレジストリを用意</li>
<li>計測対象にしたい構造体のメソッドに<code>#[measure]</code>を追加(このとき、計測したいものも指定する。)</li>
</ul>
<p>あとは、実行したあとに構造体をダンプするとメトリクスが出力されます。</p>
<h3 id="レジストリの用意">レジストリの用意</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#75715e">#[derive(Default, Debug, Serialize)]</span>
<span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">NekoParser</span> {
    metric_reg: <span style="color:#a6e22e">NekoParserMetricRegistry</span>,
}
</code></pre></div><p><code>NekoParserMetricRegistry</code>という型はこのあとの<code>impl</code>のアノテーションで指定する名前になります。
実際にはこの型の構造体を自分で定義する必要はありません。
構造体の<code>derive</code>で<code>Default</code>を指定します。構造体のインスタンス化のときに<code>default()</code>メソッドを呼び出して初期化したいためです(おそらくレジストリの初期化をやってくれるのだと思う(<strong>要確認</strong>))。
レジストリの用意はこれだけです。</p>
<h3 id="レジストリの指定と計測対象の指定">レジストリの指定と計測対象の指定</h3>
<p>計測対象側です。少し長いですが、<code>NekoParser</code>のメソッドすべてを掲載しました。
まずは、1行目でレジストリの名前の指定(<code>registry = NekoParserMetricRegistry</code>)、レジストリのフィールド名(<code>registry_expr = self.metric_reg</code>)、レジストリの可視性(<code>visibility = pub(self)</code>)を定義します。
2行目では、<code>impl</code>ブロック全体で計測したいメトリクスを指定しています。今回は、スループットとレスポンスタイムを計測したかったので
<code>#measure([ResponseTime, Throughput])]</code>と2種類を指定しています。
メトリクスが2種類のため配列で指定していますが、1種類だけの場合は<code>[]</code>の記号は必要ありません。</p>
<p>あとは、計測したい各メソッドに<code>#[measure]</code>をつけるだけです。
なお、メソッドごとに<code>#[measure(ErrorCount)]</code>といったかたちで個別にメトリクスを指定することも可能です。
今回はお試しということもあり、すべて<code>#[measure]</code>だけになっています。
アノテーションを付けただけで、メソッド自体を変更はしていません。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#75715e">#[metered(registry = NekoParserMetricRegistry, registry_expr = self.metric_reg, visibility = pub(self))]</span>
<span style="color:#75715e">#[measure([ResponseTime, Throughput]</span>)]
<span style="color:#66d9ef">impl</span> NekoParser {
    <span style="color:#75715e">#[measure]</span>
    <span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">load_and_parse_neko</span>(<span style="color:#f92672">&amp;</span>self) {
        <span style="color:#66d9ef">let</span> file_path <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;./data/chap04/neko.txt&#34;</span>;
        <span style="color:#66d9ef">let</span> file <span style="color:#f92672">=</span> File::open(file_path).unwrap();
        <span style="color:#66d9ef">let</span> buf <span style="color:#f92672">=</span> BufReader::new(file);
        <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> out <span style="color:#f92672">=</span> File::create(<span style="color:#e6db74">&#34;./data/chap04/neko.txt.lindera.json&#34;</span>).unwrap();
        buf.lines().filter_map(<span style="color:#f92672">|</span>item<span style="color:#f92672">|</span> item.ok()).for_each(<span style="color:#f92672">|</span>line<span style="color:#f92672">|</span> {
            <span style="color:#66d9ef">let</span> tokens <span style="color:#f92672">=</span> self.tokenize(line.as_str());
            self.output_tokens(<span style="color:#f92672">&amp;</span>tokens, <span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> out);
        });
    }

    <span style="color:#75715e">#[measure]</span>
    <span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">output_tokens</span>(<span style="color:#f92672">&amp;</span>self, tokens: <span style="color:#66d9ef">&amp;</span>Vec<span style="color:#f92672">&lt;</span>Token<span style="color:#f92672">&gt;</span>, buf: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">mut</span> File) {
        writeln<span style="color:#f92672">!</span>(buf, <span style="color:#e6db74">&#34;{}&#34;</span>, serde_json::to_string(tokens).unwrap())
            .expect(<span style="color:#e6db74">&#34;Error during output json&#34;</span>);
    }

    <span style="color:#75715e">#[measure]</span>
    <span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">tokenize</span>(<span style="color:#f92672">&amp;</span>self, line: <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">str</span>) -&gt; Vec<span style="color:#f92672">&lt;</span>Token<span style="color:#f92672">&gt;</span> {
        <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> tokenizer <span style="color:#f92672">=</span> lindera::tokenizer::Tokenizer::new(<span style="color:#e6db74">&#34;normal&#34;</span>, <span style="color:#e6db74">&#34;&#34;</span>);
        <span style="color:#66d9ef">let</span> lindera_tokens <span style="color:#f92672">=</span> tokenizer.tokenize(line);
        <span style="color:#66d9ef">let</span> tokens <span style="color:#f92672">=</span> lindera_tokens
            .iter()
            .map(<span style="color:#f92672">|</span>lindera_token<span style="color:#f92672">|</span> {
                <span style="color:#66d9ef">let</span> surface <span style="color:#f92672">=</span> lindera_token.text.to_string();
                <span style="color:#66d9ef">let</span> pos <span style="color:#f92672">=</span> lindera_token.detail[<span style="color:#ae81ff">0</span>].to_string();
                <span style="color:#66d9ef">let</span> pos1 <span style="color:#f92672">=</span> <span style="color:#66d9ef">if</span> pos <span style="color:#f92672">!=</span> <span style="color:#e6db74">&#34;UNK&#34;</span> {
                    lindera_token.detail[<span style="color:#ae81ff">1</span>].to_string()
                } <span style="color:#66d9ef">else</span> {
                    String::new()
                };
                <span style="color:#66d9ef">let</span> base <span style="color:#f92672">=</span> <span style="color:#66d9ef">if</span> pos <span style="color:#f92672">!=</span> <span style="color:#e6db74">&#34;UNK&#34;</span> {
                    lindera_token.detail[<span style="color:#ae81ff">6</span>].to_string()
                } <span style="color:#66d9ef">else</span> {
                    String::new()
                };
                Token {
                    surface,
                    base,
                    pos,
                    pos1,
                }
            })
            .collect();
        <span style="color:#66d9ef">return</span> tokens;
    }
}
</code></pre></div><h3 id="計測結果の出力">計測結果の出力</h3>
<p>最後は計測結果の出力です。
今回はテストメソッドで実行して結果を出力する処理を書きました。</p>
<p><code>let parser = NekoParser::default();</code>で構造体をインスタンス化します。
あとは、処理をそのまま実行します。</p>
<p>最後に出力結果をJSON形式の文字列にしてから出力しました。
<code>let serialized ... println!(&quot;{}&quot;, serialized);</code>という形です。
簡単ですね!</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#75715e">#[cfg(test)]</span>
<span style="color:#66d9ef">mod</span> tests {
    <span style="color:#66d9ef">use</span> <span style="color:#66d9ef">crate</span>::chapter04::answer::NekoParser;
    <span style="color:#66d9ef">use</span> std::path::Path;
    <span style="color:#75715e">#[test]</span>
    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">success_output_tokenlists</span>() {
        <span style="color:#66d9ef">let</span> parser <span style="color:#f92672">=</span> NekoParser::default();
        parser.load_and_parse_neko();
        <span style="color:#66d9ef">let</span> serialized <span style="color:#f92672">=</span> serde_json::to_string(<span style="color:#f92672">&amp;</span>parser).unwrap();
        println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;{}&#34;</span>, serialized);
        assert<span style="color:#f92672">!</span>(Path::new(<span style="color:#e6db74">&#34;./data/chap04/neko.txt.lindera.json&#34;</span>).exists());
    }
}
</code></pre></div><h3 id="出力結果">出力結果</h3>
<p>ここまで紹介したものの実行結果は次のような形でした。
レスポンスタイム、スループットともに、最小、最大、99パーセンタイルなどを出力してくれます。
出力はメソッド名ごとにくくられているのでとても便利です。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-json" data-lang="json">{
    <span style="color:#f92672">&#34;metric_reg&#34;</span>: {
        <span style="color:#f92672">&#34;load_and_parse_neko&#34;</span>: {
            <span style="color:#f92672">&#34;response_time&#34;</span>: {
                <span style="color:#f92672">&#34;samples&#34;</span>: <span style="color:#ae81ff">1</span>,
                <span style="color:#f92672">&#34;min&#34;</span>: <span style="color:#ae81ff">176128</span>,
                <span style="color:#f92672">&#34;max&#34;</span>: <span style="color:#ae81ff">177151</span>,
                <span style="color:#f92672">&#34;mean&#34;</span>: <span style="color:#ae81ff">176640.0</span>,
                <span style="color:#f92672">&#34;stdev&#34;</span>: <span style="color:#ae81ff">0.0</span>,
                <span style="color:#f92672">&#34;90%ile&#34;</span>: <span style="color:#ae81ff">177151</span>,
                <span style="color:#f92672">&#34;95%ile&#34;</span>: <span style="color:#ae81ff">177151</span>,
                <span style="color:#f92672">&#34;99%ile&#34;</span>: <span style="color:#ae81ff">177151</span>,
                <span style="color:#f92672">&#34;99.9%ile&#34;</span>: <span style="color:#ae81ff">177151</span>,
                <span style="color:#f92672">&#34;99.99%ile&#34;</span>: <span style="color:#ae81ff">177151</span>
            },
            <span style="color:#f92672">&#34;throughput&#34;</span>: {
                <span style="color:#f92672">&#34;samples&#34;</span>: <span style="color:#ae81ff">0</span>,
                <span style="color:#f92672">&#34;min&#34;</span>: <span style="color:#ae81ff">0</span>,
                <span style="color:#f92672">&#34;max&#34;</span>: <span style="color:#ae81ff">0</span>,
                <span style="color:#f92672">&#34;mean&#34;</span>: <span style="color:#ae81ff">0.0</span>,
                <span style="color:#f92672">&#34;stdev&#34;</span>: <span style="color:#ae81ff">0.0</span>,
                <span style="color:#f92672">&#34;90%ile&#34;</span>: <span style="color:#ae81ff">0</span>,
                <span style="color:#f92672">&#34;95%ile&#34;</span>: <span style="color:#ae81ff">0</span>,
                <span style="color:#f92672">&#34;99%ile&#34;</span>: <span style="color:#ae81ff">0</span>,
                <span style="color:#f92672">&#34;99.9%ile&#34;</span>: <span style="color:#ae81ff">0</span>,
                <span style="color:#f92672">&#34;99.99%ile&#34;</span>: <span style="color:#ae81ff">0</span>
            }
        },
        <span style="color:#f92672">&#34;output_tokens&#34;</span>: {
            <span style="color:#f92672">&#34;response_time&#34;</span>: {
                <span style="color:#f92672">&#34;samples&#34;</span>: <span style="color:#ae81ff">9964</span>,
                <span style="color:#f92672">&#34;min&#34;</span>: <span style="color:#ae81ff">0</span>,
                <span style="color:#f92672">&#34;max&#34;</span>: <span style="color:#ae81ff">143</span>,
                <span style="color:#f92672">&#34;mean&#34;</span>: <span style="color:#ae81ff">0.03592934564431955</span>,
                <span style="color:#f92672">&#34;stdev&#34;</span>: <span style="color:#ae81ff">1.5152489085107463</span>,
                <span style="color:#f92672">&#34;90%ile&#34;</span>: <span style="color:#ae81ff">0</span>,
                <span style="color:#f92672">&#34;95%ile&#34;</span>: <span style="color:#ae81ff">0</span>,
                <span style="color:#f92672">&#34;99%ile&#34;</span>: <span style="color:#ae81ff">0</span>,
                <span style="color:#f92672">&#34;99.9%ile&#34;</span>: <span style="color:#ae81ff">6</span>,
                <span style="color:#f92672">&#34;99.99%ile&#34;</span>: <span style="color:#ae81ff">143</span>
            },
            <span style="color:#f92672">&#34;throughput&#34;</span>: {
                <span style="color:#f92672">&#34;samples&#34;</span>: <span style="color:#ae81ff">174</span>,
                <span style="color:#f92672">&#34;min&#34;</span>: <span style="color:#ae81ff">39</span>,
                <span style="color:#f92672">&#34;max&#34;</span>: <span style="color:#ae81ff">71</span>,
                <span style="color:#f92672">&#34;mean&#34;</span>: <span style="color:#ae81ff">57.103448275862064</span>,
                <span style="color:#f92672">&#34;stdev&#34;</span>: <span style="color:#ae81ff">3.8417981983375835</span>,
                <span style="color:#f92672">&#34;90%ile&#34;</span>: <span style="color:#ae81ff">60</span>,
                <span style="color:#f92672">&#34;95%ile&#34;</span>: <span style="color:#ae81ff">61</span>,
                <span style="color:#f92672">&#34;99%ile&#34;</span>: <span style="color:#ae81ff">64</span>,
                <span style="color:#f92672">&#34;99.9%ile&#34;</span>: <span style="color:#ae81ff">71</span>,
                <span style="color:#f92672">&#34;99.99%ile&#34;</span>: <span style="color:#ae81ff">71</span>
            }
        },
        <span style="color:#f92672">&#34;tokenize&#34;</span>: {
            <span style="color:#f92672">&#34;response_time&#34;</span>: {
                <span style="color:#f92672">&#34;samples&#34;</span>: <span style="color:#ae81ff">9964</span>,
                <span style="color:#f92672">&#34;min&#34;</span>: <span style="color:#ae81ff">12</span>,
                <span style="color:#f92672">&#34;max&#34;</span>: <span style="color:#ae81ff">79</span>,
                <span style="color:#f92672">&#34;mean&#34;</span>: <span style="color:#ae81ff">16.897230028101177</span>,
                <span style="color:#f92672">&#34;stdev&#34;</span>: <span style="color:#ae81ff">2.331145559054724</span>,
                <span style="color:#f92672">&#34;90%ile&#34;</span>: <span style="color:#ae81ff">19</span>,
                <span style="color:#f92672">&#34;95%ile&#34;</span>: <span style="color:#ae81ff">20</span>,
                <span style="color:#f92672">&#34;99%ile&#34;</span>: <span style="color:#ae81ff">24</span>,
                <span style="color:#f92672">&#34;99.9%ile&#34;</span>: <span style="color:#ae81ff">46</span>,
                <span style="color:#f92672">&#34;99.99%ile&#34;</span>: <span style="color:#ae81ff">79</span>
            },
            <span style="color:#f92672">&#34;throughput&#34;</span>: {
                <span style="color:#f92672">&#34;samples&#34;</span>: <span style="color:#ae81ff">174</span>,
                <span style="color:#f92672">&#34;min&#34;</span>: <span style="color:#ae81ff">39</span>,
                <span style="color:#f92672">&#34;max&#34;</span>: <span style="color:#ae81ff">71</span>,
                <span style="color:#f92672">&#34;mean&#34;</span>: <span style="color:#ae81ff">57.103448275862064</span>,
                <span style="color:#f92672">&#34;stdev&#34;</span>: <span style="color:#ae81ff">3.819293076427424</span>,
                <span style="color:#f92672">&#34;90%ile&#34;</span>: <span style="color:#ae81ff">60</span>,
                <span style="color:#f92672">&#34;95%ile&#34;</span>: <span style="color:#ae81ff">61</span>,
                <span style="color:#f92672">&#34;99%ile&#34;</span>: <span style="color:#ae81ff">64</span>,
                <span style="color:#f92672">&#34;99.9%ile&#34;</span>: <span style="color:#ae81ff">71</span>,
                <span style="color:#f92672">&#34;99.99%ile&#34;</span>: <span style="color:#ae81ff">71</span>
            }
        }
    }
}
</code></pre></div><p>出力内容で気になったのは<code>output_tokens</code>と<code>tokenize</code>の<code>throughput</code>が全く同じ結果が出ていることです。
なにかバグを踏んでいる気がします。。。(時間を見つけてソースコード読んでみるか。)</p>
<h3 id="気をつけること">気をつけること</h3>
<p><code>metered</code>の導入時にわかりにくいコンパイルエラーが出たので備忘録として残しておきます。
(下からコンパイルエラーを読んでしまうくせがあったのが問題なのですが。。。)
エラーメッセージは次のとおりです。</p>
<pre><code>error[E0412]: cannot find type `ResponseTime` in this scope
  --&gt; src/chapter04/answer.rs:13:12
   |
13 | #[measure([ResponseTime, Throughput])]
   |            ^^^^^^^^^^^^ not found in this scope
   |
help: consider importing one of these items
   |
1  | use metered::ResponseTime;
   |
1  | use metered::common::ResponseTime;
   |

error[E0283]: type annotations needed
  --&gt; src/chapter04/answer.rs:12:1
   |
12 | #[metered(registry = NekoParserMetricRegistry, /* default = self.metrics */ registry_expr = self.metric_reg)]
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot infer type
   |
   = note: cannot satisfy `_: std::default::Default`
   = note: required by `std::default::Default::default`
   = note: this error originates in a derive macro (in Nightly builds, run with -Z macro-backtrace for more info)

</code></pre><p>最初のメッセージにはわかりやすく出ていますが、<code>ResponseTime</code>を<code>use</code>せずに利用しようとした場合に以下のようなエラーが出ていました。
ターミナル画面が狭かったので<code>E0283</code>のエラーが目に入り、何を言ってるんだろう?という状態になってしまいました。
スクロールアップしたら、答えが載っているのに。。。</p>
<h3 id="コード全体">コード全体</h3>
<p>元ネタは<a href="https://blog.johtani.info/blog/2020/09/07/reboot-nlp100-ch04/">NLP100本ノックの第4章</a>です。
<a href="https://github.com/johtani/nlp100-rust/blob/master/src/chapter04/answer.rs">コードの全体</a>はGitHubのソースをご覧ください。</p>
<h2 id="まとめ">まとめ</h2>
<p><code>metered</code>を簡単ですが紹介してみました。
導入自体も簡単で、想像していたような使い方ができたので満足しています。
ほかにもプロファイラなどはあるのかもしれませんが、まずはこれを使っていこうかと思っています。</p>
<p>バグらしきものがありそうだったりするので、そのへんは今後調査してみようかと。
まだ、ちょっと試してみただけなので、metered自体のオーバーヘッドや、独自のメトリクスの実装方法、メソッドではなく関数に対して利用する場合にはどうするのか?などいくつか疑問点があるので、今後試してみてまたブログに残しておこうと思います。</p>
</content:encoded>
    </item>
    
    <item>
      <title>第4章終了(言語処理100本ノック2020)</title>
      <link>https://blog.johtani.info/blog/2020/09/07/reboot-nlp100-ch04/</link>
      <pubDate>Mon, 07 Sep 2020 11:17:07 +0900</pubDate>
      
      <guid>https://blog.johtani.info/blog/2020/09/07/reboot-nlp100-ch04/</guid>
      <description>Rustで言語処理100本ノックの第4章です。 前回はこちら。 今回は早めに続きをやりました。 「形態素解析」ですしね。 第4章の概要 吾輩は猫である</description>
      <content:encoded><p>Rustで言語処理100本ノックの第4章です。</p>
<p>前回は<a href="/blog/2020/09/04/reboot-nlp100-ch03">こちら</a>。</p>
<p>今回は早めに続きをやりました。
「形態素解析」ですしね。</p>
<h2 id="第4章の概要">第4章の概要</h2>
<p>吾輩は猫であるの文章が用意されていて、MaCabで形態素解析した結果をファイルに保存したところからが開始となります。</p>
<p>が、せっかくRustでやっているのでKuromojiのRust版である<a href="https://github.com/lindera-morphology/lindera">Lindera</a>を利用して形態素解析した結果を保存する部分から作成しました。
3章に引き続き、大きな流れのところの説明だけにしておきます。</p>
<h3 id="形態素解析">形態素解析</h3>
<p>もとの<code>neko.txt</code>が文章が1行ごとになっているので、そのまま1行ずつ読みならが、形態素解析していきます。読み込みの部分は3章とあまり変わらないので割愛します。
以下は、形態素解析の処理と形態素解析結果用の構造体です。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#75715e">#[derive(Clone, Debug, Serialize, Deserialize)]</span>
<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Token</span> {
    surface: String,
    base: String,
    pos: String,
    pos1: String,
}
</code></pre></div><p>まずは構造体です。今回の問題では、必要な情報は4種類だったのでそれを構造体にしました。</p>
<ul>
<li>表層形（surface）</li>
<li>基本形（base）</li>
<li>品詞（pos）</li>
<li>品詞細分類1（pos1）</li>
</ul>
<p><code>derive</code>でSerialize、Deserializeを付与しているのは、形態素解析の結果をJSON文字列として保存し、あとのそれぞれの課題で読み出すためにserde_jsonを利用するためです。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">tokenize</span>(line: <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">str</span>) -&gt; Vec<span style="color:#f92672">&lt;</span>Token<span style="color:#f92672">&gt;</span> {
    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> tokenizer <span style="color:#f92672">=</span> lindera::tokenizer::Tokenizer::new(<span style="color:#e6db74">&#34;normal&#34;</span>, <span style="color:#e6db74">&#34;&#34;</span>);
    <span style="color:#66d9ef">let</span> lindera_tokens <span style="color:#f92672">=</span> tokenizer.tokenize(line);
    <span style="color:#66d9ef">let</span> tokens <span style="color:#f92672">=</span> lindera_tokens
        .iter()
        .map(<span style="color:#f92672">|</span>lindera_token<span style="color:#f92672">|</span> {
            <span style="color:#66d9ef">let</span> surface <span style="color:#f92672">=</span> lindera_token.text.to_string();
            <span style="color:#66d9ef">let</span> pos <span style="color:#f92672">=</span> lindera_token.detail[<span style="color:#ae81ff">0</span>].to_string();
            <span style="color:#66d9ef">let</span> pos1 <span style="color:#f92672">=</span> <span style="color:#66d9ef">if</span> pos <span style="color:#f92672">!=</span> <span style="color:#e6db74">&#34;UNK&#34;</span> {
                lindera_token.detail[<span style="color:#ae81ff">1</span>].to_string()
            } <span style="color:#66d9ef">else</span> {
                String::new()
            };
            <span style="color:#66d9ef">let</span> base <span style="color:#f92672">=</span> <span style="color:#66d9ef">if</span> pos <span style="color:#f92672">!=</span> <span style="color:#e6db74">&#34;UNK&#34;</span> {
                lindera_token.detail[<span style="color:#ae81ff">6</span>].to_string()
            } <span style="color:#66d9ef">else</span> {
                String::new()
            };
            Token {
                surface,
                base,
                pos,
                pos1,
            }
        })
        .collect();
    <span style="color:#66d9ef">return</span> tokens;
}
</code></pre></div><p>次が形態素解析の処理です。
入力に1行分の文章を受け取り、出力として、さきほどの構造体をベクタに入れたもの<code>Vec&lt;Token&gt;</code>を返します。
内部ではLinderaの<code>Tokenizer</code>を<code>normal</code>モードでインスタンス化してその<code>tokenizer()</code>メソッドを叩いているだけです。
インスタンス化のときの第2引数は辞書のディレクトリですが、今回はデフォルト辞書(IPADIC)を利用しています。
戻り値はLinderaが用意したToken構造体なので、これを今回作成した<code>Token</code>構造体に詰め替えているだけです。</p>
<p>注意点としてLinderaはMeCabとは異なり、未知語(辞書に出てこない単語)の処理が実装されていないので、品詞が<code>&quot;UNK&quot;</code>の場合にはその他の情報が取得できないので、空文字を構造体に設定するようにしました。</p>
<h3 id="結果の保存">結果の保存</h3>
<p>形態素解析の結果はJSONで保存しました。
もとのファイルが1文が1行になっていたので、
1行を読み込み、形態素解析し、それをVecで取り出して、1行1配列JSONの形で保存するようにしてあります。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">output_tokens</span>(tokens: <span style="color:#66d9ef">&amp;</span>Vec<span style="color:#f92672">&lt;</span>Token<span style="color:#f92672">&gt;</span>, buf: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">mut</span> File) {
    writeln<span style="color:#f92672">!</span>(buf, <span style="color:#e6db74">&#34;{}&#34;</span>, serde_json::to_string(tokens).unwrap()).expect(<span style="color:#e6db74">&#34;Error during output json&#34;</span>);
}
</code></pre></div><p><code>serde_json::to_string</code>に<code>Vec&lt;Token&gt;</code>を渡しているだけですが、構造体に<code>derive</code>をつけているのでよしなにやってくれます(便利ー)。</p>
<h3 id="jsonの読み込み処理">JSONの読み込み処理</h3>
<p>1行1JSONの読み込み処理です。
今回も3章のように読み込みながら、各文章ごとの形態素解析結果に対して処理を実施するために、処理を実行するための<code>trait</code>を<code>Command</code>として用意し、それぞれの問題で形態素解析結果に対して処理を書くような実装にしました。また、設問37で「猫」と共起している単語を処理するという課題があるので、文章に「猫」が入っているものだけを処理できるようにするための<code>Filter</code>も用意し、これをJSONの読み込み処理のイテレータの<code>filter</code>にわたすようにしています。
特にフィルタリングが必要ない場合ように、<code>NonFilter</code>を予め実装済みです。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">trait</span> Command {
    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">execute</span>(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> self, tokens: <span style="color:#66d9ef">&amp;</span>Vec<span style="color:#f92672">&lt;</span>Token<span style="color:#f92672">&gt;</span>);
}

<span style="color:#66d9ef">trait</span> Filter {
    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">is_target</span>(<span style="color:#f92672">&amp;</span>self, line: <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">str</span>) -&gt; <span style="color:#66d9ef">bool</span>;
}

<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">NonFilter</span> {}

<span style="color:#66d9ef">impl</span> Filter <span style="color:#66d9ef">for</span> NonFilter {
    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">is_target</span>(<span style="color:#f92672">&amp;</span>self, line: <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">str</span>) -&gt; <span style="color:#66d9ef">bool</span> {
        <span style="color:#66d9ef">true</span>
    }
}

<span style="color:#75715e">// ch04-30. 形態素解析結果の読み込み
</span><span style="color:#75715e"></span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">load_json</span><span style="color:#f92672">&lt;</span>T: <span style="color:#a6e22e">Command</span><span style="color:#f92672">&gt;</span>(cmd: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">mut</span> T) {
    load_json_with_filter(cmd, <span style="color:#f92672">&amp;</span>NonFilter {});
}

<span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">load_json_with_filter</span><span style="color:#f92672">&lt;</span>T: <span style="color:#a6e22e">Command</span>, U: <span style="color:#a6e22e">Filter</span><span style="color:#f92672">&gt;</span>(cmd: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">mut</span> T, filter: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">U</span>) {
    <span style="color:#66d9ef">let</span> file <span style="color:#f92672">=</span> File::open(<span style="color:#e6db74">&#34;./data/chap04/neko.txt.lindera.json&#34;</span>).unwrap();
    <span style="color:#66d9ef">let</span> buf <span style="color:#f92672">=</span> BufReader::new(file);
    buf.lines()
        .filter_map(<span style="color:#f92672">|</span>item<span style="color:#f92672">|</span> item.ok())
        .filter(<span style="color:#f92672">|</span>line<span style="color:#f92672">|</span> filter.is_target(line))
        .for_each(<span style="color:#f92672">|</span>line<span style="color:#f92672">|</span> {
            <span style="color:#66d9ef">let</span> tokens <span style="color:#f92672">=</span> parse_line_json(line.as_str());
            cmd.execute(<span style="color:#f92672">&amp;</span>tokens);
        });
}
</code></pre></div><p><code>output_tokens</code>では<code>serde_json::to_string</code>を呼び出してましたが、読み込みでは、<code>serde_json::from_str</code>を使うと構造体にしてくれます。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">parse_line_json</span>(line: <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">str</span>) -&gt; Vec<span style="color:#f92672">&lt;</span>Token<span style="color:#f92672">&gt;</span> {
    <span style="color:#66d9ef">return</span> serde_json::from_str(line).unwrap();
}
</code></pre></div><p>あとは、設問ごとに<code>Command</code>トレイトを実装していく形です。
たとえば、32.の動詞の原形を出力する場合は次のようになります。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">ExtractVerbBase</span> {
    out: <span style="color:#a6e22e">File</span>,
}
<span style="color:#66d9ef">impl</span> Command <span style="color:#66d9ef">for</span> ExtractVerbBase {
    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">execute</span>(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> self, tokens: <span style="color:#66d9ef">&amp;</span>Vec<span style="color:#f92672">&lt;</span>Token<span style="color:#f92672">&gt;</span>) {
        tokens
            .iter()
            .filter(<span style="color:#f92672">|</span>token<span style="color:#f92672">|</span> token.pos <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;動詞&#34;</span>)
            .for_each(<span style="color:#f92672">|</span>token<span style="color:#f92672">|</span> {
                writeln<span style="color:#f92672">!</span>(self.out, <span style="color:#e6db74">&#34;{}&#34;</span>, token.base).expect(<span style="color:#e6db74">&#34;Error during writeln&#34;</span>);
                println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;{}&#34;</span>, token.base);
            })
    }
}
</code></pre></div><p>標準出力とは別にファイルにも出力できるように<code>ExtractVerbBase</code>に<code>out</code>でファイルを保持しています。</p>
<h3 id="34-名詞の連接">34. 名詞の連接</h3>
<p>「名詞の連接（連続して出現する名詞）を最長一致で抽出せよ．」という課題だったのですが、最初は読み間違えて、名詞の連接の最も長いものだけを出力するようにしてました。。。
やっぱり、出力結果とかのサンプルは用意しといてほしいなぁ。。。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">impl</span> Command <span style="color:#66d9ef">for</span> ExtractMaxConjunctionNoun {
    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">execute</span>(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> self, tokens: <span style="color:#66d9ef">&amp;</span>Vec<span style="color:#f92672">&lt;</span>Token<span style="color:#f92672">&gt;</span>) {
        <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> nouns <span style="color:#f92672">=</span> vec<span style="color:#f92672">!</span>[];
        <span style="color:#75715e">// TODO 参照保持でどうにかしたいけどなぁ。
</span><span style="color:#75715e"></span>        tokens.iter().map(<span style="color:#f92672">|</span>token<span style="color:#f92672">|</span> token.clone()).for_each(<span style="color:#f92672">|</span>token<span style="color:#f92672">|</span> {
            <span style="color:#66d9ef">if</span> token.pos <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;名詞&#34;</span> {
                nouns.push(token);
            } <span style="color:#66d9ef">else</span> {
                <span style="color:#66d9ef">if</span> nouns.len() <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">1</span> {
                    self.buffer.push(nouns.clone());
                }
                nouns <span style="color:#f92672">=</span> vec<span style="color:#f92672">!</span>[]
            }
        });
    }
}
</code></pre></div><p>名詞の場合に、nounsにバッファリングしつつ、違う品詞が来たら出力するという処理になっています。
<code>clone</code>を呼び出していますが、これを参照を引き回す感じにできるといいのかもなぁ(結構めんどくさい)。</p>
<h3 id="36-頻度上位10語">36. 頻度上位10語</h3>
<p>頻度を数えるのにはBTreeMapを利用しています。
数えながら、Top10を保持する方法がいい気がしたのですが、いい入れ物を見つけられなかったので、数え上げたあとにBTreeMapのIteratorを回しながら、キーバリューのVecをまず生成します。
その生成したVecに値でソートし、その後Iteratorから最初の10件を取得して表示する方法にしました。</p>
<p>ソートして取り出すという処理がついでにかかっています。。。
<a href="https://doc.rust-lang.org/std/collections/struct.BinaryHeap.html">BinaryHeap</a>がなにか使えそうな気もしたのですが、いい方法が思いつきませんでした。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust">    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">print_top10</span>(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> self) {
        <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> key_values: Vec<span style="color:#f92672">&lt;</span>(<span style="color:#f92672">&amp;</span>String, <span style="color:#f92672">&amp;</span><span style="color:#66d9ef">u32</span>)<span style="color:#f92672">&gt;</span> <span style="color:#f92672">=</span>
            self.terms_count.iter().collect::<span style="color:#f92672">&lt;</span>Vec<span style="color:#f92672">&lt;</span>(<span style="color:#f92672">&amp;</span>String, <span style="color:#f92672">&amp;</span><span style="color:#66d9ef">u32</span>)<span style="color:#f92672">&gt;&gt;</span>();
        key_values.sort_by(<span style="color:#f92672">|</span>x, y<span style="color:#f92672">|</span> y.<span style="color:#ae81ff">1.</span>cmp(<span style="color:#f92672">&amp;</span>x.<span style="color:#ae81ff">1</span>));
        key_values.iter().take(<span style="color:#ae81ff">10</span>).for_each(<span style="color:#f92672">|</span>(key, value)<span style="color:#f92672">|</span> {
            writeln<span style="color:#f92672">!</span>(<span style="color:#f92672">&amp;</span>self.out, <span style="color:#e6db74">&#34;{}, {}&#34;</span>, key, value).expect(<span style="color:#e6db74">&#34;Error during writeln&#34;</span>);
            println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;{}, {}&#34;</span>, key, value);
        });
    }
</code></pre></div><h2 id="まとめ">まとめ</h2>
<p>形態素解析結果をちゃんと眺めてはいないですが、処理としてはこんなところかなと。
グラフはめんどくさいのでスキップしてしまいました。。。
Kibana/Esに食わせて見てみるのもありかなぁ?</p>
<p>次は係り受け解析です。Rustで使えるライブラリとかあるかなぁ?</p>
</content:encoded>
    </item>
    
    <item>
      <title>第3章終了(言語処理100本ノック2020)</title>
      <link>https://blog.johtani.info/blog/2020/09/04/reboot-nlp100-ch03/</link>
      <pubDate>Fri, 04 Sep 2020 23:46:25 +0900</pubDate>
      
      <guid>https://blog.johtani.info/blog/2020/09/04/reboot-nlp100-ch03/</guid>
      <description>Rustで言語処理100本ノックの第3章です。 前回はこちら。 少し間が空きましたが、再開しました。 間が空いた理由は。。。「正規表現」ですかね。</description>
      <content:encoded><p>Rustで言語処理100本ノックの第3章です。</p>
<p>前回は<a href="/blog/2020/05/12/reboot-nlp100-ch02-12to19">こちら</a>。</p>
<p>少し間が空きましたが、再開しました。
間が空いた理由は。。。「正規表現」ですかね。。。
苦手なんです、正規表現。
なので、28はちょっとギブアップしてしまいました。</p>
<h2 id="第3章の概要">第3章の概要</h2>
<p>個別に説明はせずに大きな流れのところだけ。
それぞれの問題の解については<a href="https://github.com/johtani/nlp100-rust/blob/master/src/chapter03/answer.rs">リポジトリ</a>を御覧ください(興味ある人いるのかなぁ?)</p>
<p>第3章はNDJSON(new line delimited JSON)という、
1行に1JSONという形式のデータを格納したファイルがgzipで圧縮された状態で提供されます。
まずは、このJSONファイルからJSONを読み込むのが主な処理になります。</p>
<p>読み込んだデータに「イギリス」のWikipediaの記事が入っているので、そこから正規表現で必要なデータを抽出します。</p>
<p>最後の問題が少し特殊で、抜き出した情報の「国旗」のファイル名を元に、MediaWikiのREST APIを叩いて、結果を取得し、その一部の情報を抜き出すというものです。</p>
<h3 id="jsonの読み込み処理">JSONの読み込み処理</h3>
<p>gzipファイルを読み込んでから、1行ずつ抜き出してVecに入れる処理が次のようになります。
今回のgzipファイルは大した量が入っていないので、全部先に抜き出す処理としてまとめました。
もっと巨大なファイルの場合は個別のJSONに対する処理を
<code>buf.lines().map()</code>のmapのなかで実行する形にすると思います。
gzipのファイルを開くのに<code>flate2</code>というクレート(ライブラリ)を利用しました。便利なのは、<code>BufReader</code>に<code>lines()</code>というメソッドがあるところですかね。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#75715e">// https://docs.rs/flate2/1.0.14/flate2/read/struct.GzDecoder.html
</span><span style="color:#75715e"></span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">extract_ndjson_from_gzip</span>(input_file_name: <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">str</span>) -&gt; Vec<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;</span> {
    <span style="color:#66d9ef">let</span> f <span style="color:#f92672">=</span> File::open(input_file_name).expect(<span style="color:#e6db74">&#34;file not found?&#34;</span>);
    <span style="color:#66d9ef">let</span> gz <span style="color:#f92672">=</span> GzDecoder::new(f);
    <span style="color:#66d9ef">let</span> buf <span style="color:#f92672">=</span> BufReader::new(gz);
    <span style="color:#66d9ef">let</span> lines: Vec<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;</span> <span style="color:#f92672">=</span> buf.lines().map(<span style="color:#f92672">|</span>l<span style="color:#f92672">|</span> l.unwrap()).collect();
    <span style="color:#66d9ef">return</span> lines;
}
</code></pre></div><p>こちらは、上記のメソッドで抜き出したVecを元に、記事の情報を抜き出す処理をしています。
JSONをパースして構造体<code>Article</code>にデシリアライズするために、<code>serde</code>というライブラリを使用しています。
<code>serde</code>自体は様々なデータ形式(JSON、YAMLなど)をパースするためのフレームワークです。今回はJSONなので、<code>serde_json</code>の実装を利用しています。
また、JSON文字列から構造体にデシリアライズするのを簡単にできるように構造体に<code>#[derive(Deserialize)]</code>をつけています。
あとは、<code>let article: Article = serde_json::from_str(json.as_str())</code>という処理を実行すればserde_jsonがJSONをパースして構造体に変換してくれます。形式がわかっているJSONの扱いはこれが楽ですね。変数に型を明記してあるので、型の推論もしてくれてるようです。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#75715e">#[derive(Deserialize)]</span>
<span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Article</span> {
    title: String,
    text: String,
}

<span style="color:#75715e">// ch03-20. JSONデータの読み込み
</span><span style="color:#75715e">// https://serde.rs/
</span><span style="color:#75715e"></span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">load_json</span>(input_file_name: <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">str</span>, target_title: <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">str</span>) -&gt; Vec<span style="color:#f92672">&lt;</span>Article<span style="color:#f92672">&gt;</span> {
    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> results <span style="color:#f92672">=</span> vec<span style="color:#f92672">!</span>[];
    <span style="color:#66d9ef">let</span> ndjson <span style="color:#f92672">=</span> extract_ndjson_from_gzip(input_file_name);
    <span style="color:#66d9ef">for</span> json <span style="color:#66d9ef">in</span> ndjson {
        <span style="color:#66d9ef">let</span> article: <span style="color:#a6e22e">Article</span> <span style="color:#f92672">=</span> serde_json::from_str(json.as_str()).expect(<span style="color:#e6db74">&#34;json parse error&#34;</span>);
        <span style="color:#66d9ef">if</span> article.title <span style="color:#f92672">==</span> target_title {
            results.push(article);
        }
    }
    <span style="color:#66d9ef">return</span> results;
}
</code></pre></div><p>後続の処理ではパースした<code>Article</code>から記事情報を取得して色々と処理をしています。</p>
<h3 id="正規表現">正規表現</h3>
<p>正規表現用のクレート<code>regex</code>がRustに用意されています。<code>Regex::new(正規表現)</code>で、正規表現をコンパイルし、あとは、この構造体のメソッドを利用して文字列を処理していきます。
問題では、マッチするかどうか、マッチした一部の文字列を抜き出す、不要なタグを削除するといった処理を正規表現で行いました(Rust書くよりも正規表現の書き方とかを調べるのに大半の時間をもっていかれてます。。。)。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust">
<span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">extract_category_lines</span>(article: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">Article</span>) -&gt; Vec<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;</span> {
    <span style="color:#66d9ef">let</span> re <span style="color:#f92672">=</span> Regex::new(<span style="color:#e6db74">r&#34;\[\[Category:(.*)\]\]&#34;).expect(&#34;syntax error in regex&#34;</span>);
    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> lines <span style="color:#f92672">=</span> vec<span style="color:#f92672">!</span>[];
    article.lines_from_text().iter().for_each(<span style="color:#f92672">|</span>line<span style="color:#f92672">|</span> {
        <span style="color:#66d9ef">if</span> re.is_match(line) {
            lines.push(line.to_string());
        }
    });
    <span style="color:#66d9ef">return</span> lines;
}
</code></pre></div><h3 id="mediawiki-apiリクエスト処理">MediaWiki APIリクエスト処理</h3>
<p>最後の問題で国旗のファイル名を元に<a href="https://www.mediawiki.org/wiki/API:Imageinfo">MediaWiki API</a>を叩いて、URLの文字列を取得しましょうという問題がありました。
ファイル名をREST APIの引数に渡してHTTP経由でリクエストを送信し、返ってくるJSONレスポンスからURLを抜き出すという処理です。</p>
<p>HTTPのリクエストの送受信に<code>reqwest</code>というクレートを利用しました。
ちょっと長いけど、APIコールしている箇所はこんな形です。</p>
<p>この関数には<code>async</code>とついています。非同期処理の関数です。内部で2回ほど(リクエスト送信の結果待ちとレスポンスのパース待ち)<code>.await</code>があります。</p>
<p><code>client</code>に<code>.get(URL)</code>や<code>query(&amp;[])</code>といったメソッドが用意されているので、URLやクエリパラメータを用意して<code>send()</code>でリクエスト送信します。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust">
async <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">call_api</span>(file_name: <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">str</span>) -&gt; Result<span style="color:#f92672">&lt;</span>String, String<span style="color:#f92672">&gt;</span> {
    <span style="color:#66d9ef">let</span> client <span style="color:#f92672">=</span> reqwest::Client::new();
    <span style="color:#66d9ef">let</span> file_name2 <span style="color:#f92672">=</span> format<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;File:{}&#34;</span>, file_name);
    <span style="color:#75715e">//let mut file_name2 = file_name.to_string().replace(&#34; &#34;, &#34;_&#34;);
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">let</span> query <span style="color:#f92672">=</span> [
        (<span style="color:#e6db74">&#34;action&#34;</span>, <span style="color:#e6db74">&#34;query&#34;</span>),
        (<span style="color:#e6db74">&#34;format&#34;</span>, <span style="color:#e6db74">&#34;json&#34;</span>),
        (<span style="color:#e6db74">&#34;prop&#34;</span>, <span style="color:#e6db74">&#34;imageinfo&#34;</span>),
        (<span style="color:#e6db74">&#34;iiprop&#34;</span>, <span style="color:#e6db74">&#34;url&#34;</span>),
        (<span style="color:#e6db74">&#34;titles&#34;</span>, file_name2.as_str()),
    ];
    <span style="color:#66d9ef">let</span> result <span style="color:#f92672">=</span> client
        .get(<span style="color:#e6db74">&#34;https://en.wikipedia.org/w/api.php&#34;</span>)
        .query(<span style="color:#f92672">&amp;</span>query)
        .send()
        .await;

    <span style="color:#66d9ef">match</span> result {
        Ok(response) <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">match</span> response.status() {
            StatusCode::OK <span style="color:#f92672">=&gt;</span> {
                <span style="color:#66d9ef">let</span> body <span style="color:#f92672">=</span> response.json::<span style="color:#f92672">&lt;</span>MediaWikiResponse<span style="color:#f92672">&gt;</span>().await;
                <span style="color:#66d9ef">match</span> body {
                    Ok(obj) <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">match</span> obj.get_url() {
                        Some(url) <span style="color:#f92672">=&gt;</span> Ok(url),
                        None <span style="color:#f92672">=&gt;</span> Err(String::from(<span style="color:#e6db74">&#34;Cannot get url...&#34;</span>)),
                    },
                    Err(error) <span style="color:#f92672">=&gt;</span> Err(error.to_string()),
                }
            }
            _ <span style="color:#f92672">=&gt;</span> Err(String::from(format<span style="color:#f92672">!</span>(
                <span style="color:#e6db74">&#34;Status code is {}.&#34;</span>,
                response.status()
            ))),
        },
        Err(error) <span style="color:#f92672">=&gt;</span> {
            <span style="color:#66d9ef">let</span> error_msg <span style="color:#f92672">=</span> format<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;Error occurred... {:?}&#34;</span>, error);
            println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;{}&#34;</span>, error_msg.as_str());
            Err(error_msg)
        }
    }
}
</code></pre></div><p>あとは、呼び出し元で非同期の処理を実行するために、<code>tokio</code>というクレートを利用しています。
<code>block_on()</code>で<code>call_api()</code>の実行をして、結果が返ってくるのを待ち受けています。結果が返ってきて、問題なければ、<code>call_api</code>の戻り値<code>Result&lt;String, String&gt;</code>の左側のStringの値が取り出され、<code>get_image_url</code>の戻り値となります。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust">
<span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">get_image_url</span>(file_name: <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">str</span>) -&gt; String {
    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> _rt <span style="color:#f92672">=</span> tokio::runtime::Runtime::new().expect(<span style="color:#e6db74">&#34;Fail initializing runtime&#34;</span>);
    <span style="color:#66d9ef">let</span> task <span style="color:#f92672">=</span> call_api(file_name);
    _rt.block_on(task).expect(<span style="color:#e6db74">&#34;Something wrong...&#34;</span>)
}
</code></pre></div><p>一応、非同期に関して説明してみましたが、合っているのかどうか。。。
クレートの関係などはまだちょっと自身がないです。。。
あとは、エラーの処理の仕方とかももうちょっと勉強したいかな。</p>
<h2 id="まとめ">まとめ</h2>
<p>一応、3章を終わらせました。だいぶ強引かつ1つスキップしましたが。。。
次は<a href="https://nlp100.github.io/ja/ch04.html">第4章の形態素解析</a>です。</p>
</content:encoded>
    </item>
    
    <item>
      <title>Rust the book - 第15章</title>
      <link>https://blog.johtani.info/blog/2020/07/09/hap15-rust-the-book/</link>
      <pubDate>Thu, 09 Jul 2020 18:59:38 +0900</pubDate>
      
      <guid>https://blog.johtani.info/blog/2020/07/09/hap15-rust-the-book/</guid>
      <description>前回の記事はこちら。自分用のメモなので、読みにくいかもです。 Rust the Bookを読み始めた Rust the book - 第4章 Rust the book - 第5章 Rust the book - 第6章 Rust the book - 第8章</description>
      <content:encoded><p>前回の記事はこちら。自分用のメモなので、読みにくいかもです。</p>
<ul>
<li><a href="/blog/2020/03/23/start-reading-rust-the-book/">Rust the Bookを読み始めた</a></li>
<li><a href="/blog/2020/03/26/chap4-rust-the-book/">Rust the book - 第4章</a></li>
<li><a href="/blog/2020/04/02/chap5-rust-the-book/">Rust the book - 第5章</a></li>
<li><a href="/blog/2020/04/07/chap6-rust-the-book/">Rust the book - 第6章</a></li>
<li><a href="/blog/2020/04/16/chap8-rust-the-book/">Rust the book - 第8章</a></li>
<li><a href="/blog/2020/05/14/chap9-rust-the-book/">Rust the book - 第9章</a></li>
<li><a href="/blog/2020/05/28/chap10-rust-the-book/">Rust the book - 第10章</a></li>
<li><a href="/blog/2020/06/04/chap13-rust-the-book/">Rust the book - 第13章</a></li>
</ul>
<p>14章は飛ばして、15章です(Cargoはまた別途調べればいいかな?と思って)。</p>
<h2 id="第15章-スマートポインタ">第15章 スマートポインタ</h2>
<p>たぶん、これを理解すれば、参照とベクタや構造体とかの組み合わせがもう少し効率よく使えるようになるのかなぁ?</p>
<ul>
<li>ポインタの強い版?
<ul>
<li>参照カウント方式のスマートポインタ型 - Luceneとかで実装されてた気がするなぁ
<ul>
<li>複数の所有者!?</li>
</ul>
</li>
</ul>
</li>
<li>DerefとDropトレイトを実装している構造体</li>
</ul>
<h3 id="ヒープのデータを指すboxtを使用する">ヒープのデータを指すBox<T>を使用する</h3>
<p>これはコンパイルエラー。<code>let y</code>のタイミングで借用してるので、書き換えでエラーになる。</p>
<pre><code>fn main() {
    let mut x = 5;
    let y = &amp;x;

    assert_eq!(5, x);
    assert_eq!(5, *y);
    x = 6;
    assert_eq!(6, x);
    assert_eq!(6, *y);
}
</code></pre><p>こっちはOK。</p>
<pre><code>fn main() {
    let mut x = 5; // in stack
    let y = Box::new(x); // in heap

    assert_eq!(5, x);
    assert_eq!(5, *y);
    x = 6;
    assert_eq!(6, x);
    assert_eq!(6, *y);
}
</code></pre><p>余談:コンパイラが変なワーニングを出してくれた。</p>
<pre><code>use std::ops::Deref;

impl&lt;T, Z&gt; Deref for MyBox&lt;T, Z&gt; {
    type Target = T;

    fn deref(&amp;self) -&gt; &amp;T {
        &amp;self.0
    }
}

struct MyBox&lt;T, Z&gt;(T, Z);

impl&lt;T, Z&gt; MyBox&lt;T, Z&gt; {
    fn new(x: T, y: Z) -&gt; MyBox&lt;T, Z&gt; {
        MyBox(x, y)
    }
}

fn main() {
    let x = 5;
    let z = &quot;10&quot;;
    let y = MyBox::new(x, z);

    assert_eq!(5, x);
    assert_eq!(5, *y);
}

</code></pre><h3 id="derefトレイトでスマートポインタを普通の参照のように扱う">Derefトレイトでスマートポインタを普通の参照のように扱う</h3>
<ul>
<li><code>参照外し型強制</code> : 日本語ムズカシイネ</li>
<li>Derefを自分で実装しないといけない場面がちょっと想像できてない。たぶん、Boxとかの説明に必要なので出てきたって感じなんだろうけど。</li>
</ul>
<h3 id="dropトレイトで片付け時にコードを走らせる">Dropトレイトで片付け時にコードを走らせる</h3>
<ul>
<li>こっちは、リソース開放とかでいい感じにできそうだってのはわかった。</li>
<li>Dropはどんなときに実装するんだろう?Tantivyだとオブジェクトプールとかで使ってた。</li>
</ul>
<h3 id="rctは参照カウント方式のスマートポインタ">Rc<T>は、参照カウント方式のスマートポインタ</h3>
<ul>
<li>これ、ここで作ったConsのリストを追っかけるためのサンプルも書いてほしい。</li>
</ul>
<pre><code>#[derive(Debug)]
enum List {
    Cons(i32, Rc&lt;List&gt;),
    Nil,
}

fn print_typename&lt;T&gt;(_: T) {
    println!(&quot;{}&quot;, std::any::type_name::&lt;T&gt;());
}

use List::{Cons, Nil};
use std::rc::Rc;
use std::borrow::Borrow;

fn main() {
    let z = Cons(5, Rc::new(Cons(10, Rc::new(Nil))));
    let a = Rc::new(z);
    let _b = Cons(3, Rc::clone(&amp;a));
    let _c = Cons(4, Rc::clone(&amp;a));
    match &amp;(*a) {
        Cons(v1, v2) =&gt; {
            print_typename(v2);
            println!(&quot;{}, {:?}&quot;, v1, v2);
        },
        Nil =&gt; println!(&quot;Nil!!&quot;)
    };
}
</code></pre><h3 id="refcelltと内部可変性パターン">RefCell<T>と内部可変性パターン</h3>
<ul>
<li></li>
</ul>
<h3 id="循環参照はメモリをリークすることもある">循環参照は、メモリをリークすることもある</h3>
</content:encoded>
    </item>
    
    <item>
      <title>Rust the book - 第13章</title>
      <link>https://blog.johtani.info/blog/2020/06/04/chap13-rust-the-book/</link>
      <pubDate>Thu, 04 Jun 2020 17:37:29 +0900</pubDate>
      
      <guid>https://blog.johtani.info/blog/2020/06/04/chap13-rust-the-book/</guid>
      <description>前回の記事はこちら。自分用のメモなので、読みにくいかもです。 Rust the Bookを読み始めた Rust the book - 第4章 Rust the book - 第5章 Rust the book - 第6章 Rust the book - 第8章</description>
      <content:encoded><p>前回の記事はこちら。自分用のメモなので、読みにくいかもです。</p>
<ul>
<li><a href="/blog/2020/03/23/start-reading-rust-the-book/">Rust the Bookを読み始めた</a></li>
<li><a href="/blog/2020/03/26/chap4-rust-the-book/">Rust the book - 第4章</a></li>
<li><a href="/blog/2020/04/02/chap5-rust-the-book/">Rust the book - 第5章</a></li>
<li><a href="/blog/2020/04/07/chap6-rust-the-book/">Rust the book - 第6章</a></li>
<li><a href="/blog/2020/04/16/chap8-rust-the-book/">Rust the book - 第8章</a></li>
<li><a href="/blog/2020/05/14/chap9-rust-the-book/">Rust the book - 第9章</a></li>
<li><a href="/blog/2020/05/28/chap10-rust-the-book/">Rust the book - 第10章</a></li>
</ul>
<p>11章、12章はちょっと飛ばして、13章です。</p>
<h2 id="第13章">第13章</h2>
<p>イテレータ、クロージャです。
12章の話もちょっと出てくるのか。</p>
<h3 id="クロージャ">クロージャ</h3>
<p>基本的に、「変数には値が束縛されている」という固定観念がずっと頭にこびりついたままなので、クロージャに慣れないんだろうなぁ。そろそろこの固定概念をどうにかしないと。</p>
<ul>
<li>匿名関数で、変数に保存したり引数に渡せる</li>
<li>ちょっと面白い話(ワークアウト)で実際に考えられる手法の説明がいくつか行われる</li>
</ul>
<ol>
<li>関数でリファクタリング
<ul>
<li>これが自分がよくやるパターンかなぁ。クロージャになれてないので。。。</li>
</ul>
</li>
<li>クロージャーを変数に束縛
<ul>
<li>呼び出しは関数みたいな感じ(ここで少し混乱)</li>
<li>これだと、結局呼び出されたタイミングが複数回あるよね? -&gt; あはりそうだった</li>
</ul>
</li>
</ol>
<p>ここで、閑話休題で、クロージャの型推論とか注釈の話。
クロージャは狭い文脈だし、外に公開しているものでもないので、戻り値なども定義してなくてもいいよねとのこと。書くことも可能?なので、書いてわかりやすくするのもありなんだろうな。</p>
<p>推論についてはこれまで通りで、2回異なる型の変数で呼び出すと、2回目で怒られていた。</p>
<ol start="3">
<li>遅延評価(クロージャを保持する構造体!?)
<ul>
<li><code>Fn</code>トレイト</li>
<li>トレイトとMatchの組み合わせだからこのへんで説明する形になるのか。</li>
<li>これを真似すれば、いくつか処理を簡素化できるかもしれないなぁ、たしかに。</li>
<li>なければ実行するみたいな処理を書きたいことがよくあるし。Javaだとnullで定義しといて、nullだったらみたいなのがあるから。</li>
</ul>
</li>
</ol>
<ul>
<li>
<p><code>Cacher</code>はサンプルだからこの名前でいいけど、自分だと、どんな名前にするかなぁ?</p>
</li>
<li>
<p>振る舞いは難しくなるのか。<code>Cacher実装の限界</code>を読むと。</p>
</li>
<li>
<p>関数にするとスコープが変わるのでアクセスできなくなると。。。コンパイラが教えてくれるのは便利だな。</p>
</li>
<li>
<p>環境から値をキャプチャする3つの方法</p>
<ul>
<li>多分この話が一番クロージャに意味がある話なんだと思う。</li>
</ul>
</li>
</ul>
<h3 id="イテレータ">イテレータ</h3>
<p>回しましょう。</p>
<ul>
<li>便利。ただ、こういう書き方に自分が慣れてないので、そっちを補正しないとなぁ。</li>
<li>どれがイテレータ?っていうのを判別するのがちょっとむずかしい(慣れの問題かなぁ)</li>
<li>イテレータアダプタ便利。どんなのがあるのか?とかがやっとわかってきた。</li>
<li>パフォーマンスに関しては、うーん、どうなんだろう?という感想だった。</li>
</ul>
</content:encoded>
    </item>
    
    <item>
      <title>Rust the book - 第10章</title>
      <link>https://blog.johtani.info/blog/2020/05/28/chap10-rust-the-book/</link>
      <pubDate>Thu, 28 May 2020 18:06:55 +0900</pubDate>
      
      <guid>https://blog.johtani.info/blog/2020/05/28/chap10-rust-the-book/</guid>
      <description>前回の記事はこちら。自分用のメモなので、読みにくいかもです。 Rust the Bookを読み始めた Rust the book - 第4章 Rust the book - 第5章 Rust the book - 第6章 Rust the book - 第8章</description>
      <content:encoded><p>前回の記事はこちら。自分用のメモなので、読みにくいかもです。</p>
<ul>
<li><a href="/blog/2020/03/23/start-reading-rust-the-book/">Rust the Bookを読み始めた</a></li>
<li><a href="/blog/2020/03/26/chap4-rust-the-book/">Rust the book - 第4章</a></li>
<li><a href="/blog/2020/04/02/chap5-rust-the-book/">Rust the book - 第5章</a></li>
<li><a href="/blog/2020/04/07/chap6-rust-the-book/">Rust the book - 第6章</a></li>
<li><a href="/blog/2020/04/16/chap8-rust-the-book/">Rust the book - 第8章</a></li>
<li><a href="/blog/2020/05/14/chap9-rust-the-book/">Rust the book - 第9章</a></li>
</ul>
<h2 id="第10章">第10章</h2>
<p>ジェネリック、トレイト、ライフタイムです。
手強そう。</p>
<p>いきなり関数の切り出し方みたいな話が始まって面食らいました。</p>
<h3 id="ジェネリックなデータ型">ジェネリックなデータ型</h3>
<p>ジェネリックはJavaにもあるので、それほど理解に苦しむことはなかったです。
また、OptionやResultですでに経験済みでしたし。</p>
<p>ただ、<code>impl&lt;T&gt; Point&lt;T&gt;{</code>、このメソッド定義は少し最初は戸惑いました。
言われてみれば、なるほどなんですけど。</p>
<p>コンパイル時にコンパイラが単相化を行うことにより、必要最低限なコードを生成してくるというのは理にかなっているなぁと。</p>
<h3 id="トレイト-共通の振る舞いを定義する">トレイト: 共通の振る舞いを定義する</h3>
<p>出だしにもありますが、「インターフェイス」という機能に類似していると考えると割とすんなりと理解が進みました。
ただ、Javaだと、インターフェースはクラスとセットなため、トレイとの実装に関する記述方法は少し戸惑いが。</p>
<p>デフォルト実装との組み合わせはAbstractに似た処理になるなと考えながら読みすすめました。</p>
<p>「トレイト境界」という日本語には少し違和感を覚えましたが、線引をして、制限をかけるという理解でいいのかな?</p>
<p>実際には<code>#[derive()]</code>などで、トレイトを自分で実装する必要がないなどの、便利機能も用意されており、このあたりのコードの追い方がまだ少し慣れていないかもなぁと。便利なんですけど。。。</p>
<p>少しだけ気になったので、動作確認したのは次の実装です。</p>
<p>トレイトで宣言されている関数と構造体が独自に実装する関数の名前がかぶるとどうなるのかという実験です。
構造体独自のメソッドが優先される感じになりそう。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Tweet</span> {
    <span style="color:#66d9ef">pub</span> username: String,
    <span style="color:#66d9ef">pub</span> content: String,
    <span style="color:#66d9ef">pub</span> reply: <span style="color:#66d9ef">bool</span>,
    <span style="color:#66d9ef">pub</span> retweet: <span style="color:#66d9ef">bool</span>,
}
<span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">trait</span> Summary {
    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">summarize_author</span>(<span style="color:#f92672">&amp;</span>self) -&gt; String;
    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">summarize</span>(<span style="color:#f92672">&amp;</span>self) -&gt; String {
        <span style="color:#75715e">// {}さんからもっと読む
</span><span style="color:#75715e"></span>        format<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;(Read more from {}...)&#34;</span>, self.summarize_author())
    }
}
<span style="color:#66d9ef">impl</span> Tweet {
    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">summarize_author</span>(<span style="color:#f92672">&amp;</span>self) -&gt; String {
        format<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;hoge {}&#34;</span>, self.username)
    }
    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">to_string</span>(<span style="color:#f92672">&amp;</span>self) -&gt; String {
        format<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;fuga&#34;</span>)
    }
}
<span style="color:#66d9ef">impl</span> Summary <span style="color:#66d9ef">for</span> Tweet {
    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">summarize_author</span>(<span style="color:#f92672">&amp;</span>self) -&gt; String {
        format<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;@{}&#34;</span>, self.username)
    }
}
<span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">summary</span><span style="color:#f92672">&lt;</span>T: <span style="color:#a6e22e">Summary</span><span style="color:#f92672">&gt;</span>(hoge: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">T</span>) {
    println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;{}&#34;</span>, hoge.summarize_author());
}
<span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">let</span> tweet <span style="color:#f92672">=</span> Tweet {
        username: String::from(<span style="color:#e6db74">&#34;horse_ebooks&#34;</span>),
        content: String::from(<span style="color:#e6db74">&#34;of course, as you probably already know, people&#34;</span>),
        reply: <span style="color:#a6e22e">false</span>,
        retweet: <span style="color:#a6e22e">false</span>,
    };
    println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;{}&#34;</span>, tweet.summarize_author());
    summary(<span style="color:#f92672">&amp;</span>tweet);
    println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;{}&#34;</span>, Summary::summarize_author(<span style="color:#f92672">&amp;</span>tweet));
}
</code></pre></div><h3 id="ライフタイムで参照を有効化する">ライフタイムで参照を有効化する</h3>
<p>言われてみればそうですが、プログラマが色々考えないとまぁ、行けないんですねという感想。</p>
<p>ただ、借用チェッカーが賢くやってくれるおかげで、全てにライフタイム注釈をつけなくて良くなっているというのがわかりました。
逆に言うと、なんとなくRustを書き始めてしまったので、それを知らずに書いたせいで、コンパイラに怒られてても「?」となっていたのかと。。。</p>
<p>疑問点がいくつかあって、</p>
<ul>
<li>通常はどんなライフタイム注釈をみんな書いてるんだろう?<code>'a</code>とかざっくりしすぎてる?</li>
<li>1つのメソッド、関数にライフタイム注釈が大量に出てくるような書き方をした場合は設計がおかしいのでは?って考えたほうがいいのかも?</li>
<li>ジェネリックな型とライフタイム引数の順序を入れ替えてみても動くだろ?とおもって入れ替えてみたら怒られた。</li>
</ul>
<p>あとは、構造体+ジェネリックが絡んできたら少しこんがらがってきそうっという感じです。
まぁ、これから先は実際に書いてみないことにはわからないんだろうなと。</p>
<h2 id="まとめ">まとめ</h2>
<p>読みました。
実際にはプログラムを書きながら慣れていく感じだろうなぁと。
まだまだ、あれ?ジェネリックってどう書くんだっけ?とか、ライフタイム注釈どうやって付けて、使うときはどうすんだ?みたいになりながら、
出てくるサンプルを少し変えてみてはどうやって動くんだろうこの場合?みたいなことをやってました。
次は、11章、12章を少しだけ自習しつつ、13章に入る予定です(知り合いと一緒に読みすすめてる)。</p>
</content:encoded>
    </item>
    
    <item>
      <title>Rust the book - 第9章</title>
      <link>https://blog.johtani.info/blog/2020/05/14/chap9-rust-the-book/</link>
      <pubDate>Thu, 14 May 2020 18:43:26 +0900</pubDate>
      
      <guid>https://blog.johtani.info/blog/2020/05/14/chap9-rust-the-book/</guid>
      <description>前回の記事はこちら。自分用のメモなので、読みにくいかもです。 Rust the Bookを読み始めた Rust the book - 第4章 Rust the book - 第5章 Rust the book - 第6章 Rust the book - 第8章</description>
      <content:encoded><p>前回の記事はこちら。自分用のメモなので、読みにくいかもです。</p>
<ul>
<li><a href="/blog/2020/03/23/start-reading-rust-the-book/">Rust the Bookを読み始めた</a></li>
<li><a href="/blog/2020/03/26/chap4-rust-the-book/">Rust the book - 第4章</a></li>
<li><a href="/blog/2020/04/02/chap5-rust-the-book/">Rust the book - 第5章</a></li>
<li><a href="/blog/2020/04/07/chap6-rust-the-book/">Rust the book - 第6章</a></li>
<li><a href="/blog/2020/04/16/chap8-rust-the-book/">Rust the book - 第8章</a></li>
</ul>
<h2 id="第9章">第9章</h2>
<p>エラー処理です。
NLP100とか、いくつかのプログラムを書いていて、なんとなくは扱っていますが、きちんと勉強しないと。</p>
<p>とりあえず、「Rustには例外は存在しません。」が一番知っておくことかな。</p>
<h3 id="panicで回復不能なエラー">panic!で回復不能なエラー</h3>
<ul>
<li><code>panic!</code>マクロでスタックを巻き戻して掃除をして終了。
<ul>
<li>異常終了(<code>panic = 'abort'</code>)にもできる。</li>
</ul>
</li>
<li>「<code>RUST_BACKTRACE</code>を0以外の変数にセットして実行」
*</li>
</ul>
<h3 id="resultで回復可能なエラー">Resultで回復可能なエラー</h3>
<ul>
<li><code>expect()</code>は気持ち悪い名前じゃないかなぁ?</li>
<li><a href="https://doc.rust-jp.rs/book/second-edition/ch09-02-recoverable-errors-with-result.html#a%E3%82%A8%E3%83%A9%E3%83%BC%E3%82%92%E5%A7%94%E8%AD%B2%E3%81%99%E3%82%8B">ここ</a>で<code>io::Error</code>ではないものもエラーが発生する場合には</li>
</ul>
<h3 id="panicすべきかするまいか">panic!すべきかするまいか</h3>
<h2 id="まとめ">まとめ</h2>
<p>「Rustには例外は存在しない」ので、回復不能か可能かを考えつつ処理を書こうと。</p>
</content:encoded>
    </item>
    
    <item>
      <title>第2章の12から19まで(言語処理100本ノック2020)</title>
      <link>https://blog.johtani.info/blog/2020/05/12/reboot-nlp100-ch02-12to19/</link>
      <pubDate>Tue, 12 May 2020 12:23:29 +0900</pubDate>
      
      <guid>https://blog.johtani.info/blog/2020/05/12/reboot-nlp100-ch02-12to19/</guid>
      <description>Rustで言語処理100本ノックの第2章の残りです。 前回はこちら。 ちなみに、標準入力から受け取る処理は書いてないです。 出力に関してはファイル</description>
      <content:encoded><p>Rustで言語処理100本ノックの第2章の残りです。</p>
<p>前回は<a href="/blog/2020/05/08/rebootnlp100-ch02-10to11">こちら</a>。</p>
<p>ちなみに、標準入力から受け取る処理は書いてないです。
出力に関してはファイル分割、保存と支持があるもの以外は文字列として取り出すところで終わっています。</p>
<h2 id="12-1列目をcol1txtに2列目をcol2txtに保存">12. 1列目をcol1.txtに，2列目をcol2.txtに保存</h2>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">extract_column</span>(input_file_name: <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">str</span>, num: <span style="color:#66d9ef">usize</span>, output_file_name: <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">str</span>) {
    <span style="color:#66d9ef">let</span> input_f <span style="color:#f92672">=</span> File::open(input_file_name).expect(<span style="color:#e6db74">&#34;file not found&#34;</span>);
    <span style="color:#66d9ef">let</span> read_buf <span style="color:#f92672">=</span> BufReader::new(input_f);
    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> output_f <span style="color:#f92672">=</span> OpenOptions::new()
        .write(<span style="color:#66d9ef">true</span>)
        .create(<span style="color:#66d9ef">true</span>)
        .open(output_file_name)
        .expect(format<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;can&#39;t open file[{}] with write option&#34;</span>, output_file_name).as_str());
    read_buf.lines().for_each(<span style="color:#f92672">|</span>line<span style="color:#f92672">|</span> <span style="color:#66d9ef">match</span> line {
        Ok(line) <span style="color:#f92672">=&gt;</span> {
            <span style="color:#66d9ef">let</span> columns: Vec<span style="color:#f92672">&lt;</span>_<span style="color:#f92672">&gt;</span> <span style="color:#f92672">=</span> line.split(<span style="color:#e6db74">&#39;\t&#39;</span>).collect();
            writeln<span style="color:#f92672">!</span>(output_f, <span style="color:#e6db74">&#34;{}&#34;</span>, columns[num]);
            output_f.flush().expect(<span style="color:#e6db74">&#34;Error during flush&#34;</span>);
        }
        Err(_) <span style="color:#f92672">=&gt;</span> panic<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;parse error &#34;</span>),
    });
}
</code></pre></div><p>13で出力結果を利用するので入力として出力ファイル名も受け取るようにしました。
問題としては、1列目と2列目を別々に出力すればいいので、1回の処理で書いても良かったのですが、1回1ファイルの出力という形で実装しました(効率は悪い)。</p>
<p>改行コードあたりを考えるのがめんどくさかったので<code>writeln!</code>マクロでファイルに書き出しています。が、普通に<code>write</code>メソッドで改行コードを追加しても良かったのかなと。</p>
<p>あとは、出力先ファイルが存在しない場合だけ<code>open</code>するように<code>OpenOptions</code>を利用してみています。</p>
<p><code>flush</code>を呼び出すべきなのかどうか?を調べないとな。。。</p>
<h2 id="13-col1txtとcol2txtをマージ">13. col1.txtとcol2.txtをマージ</h2>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">merge_files</span>(col1_file: <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">str</span>, col2_file: <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">str</span>, output_file_name: <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">str</span>) {
    <span style="color:#66d9ef">let</span> col1_buf <span style="color:#f92672">=</span> BufReader::new(File::open(col1_file).expect(<span style="color:#e6db74">&#34;file not found&#34;</span>));
    <span style="color:#66d9ef">let</span> col2_buf <span style="color:#f92672">=</span> BufReader::new(File::open(col2_file).expect(<span style="color:#e6db74">&#34;file not found&#34;</span>));
    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> output_f <span style="color:#f92672">=</span> OpenOptions::new()
        .write(<span style="color:#66d9ef">true</span>)
        .create(<span style="color:#66d9ef">true</span>)
        .open(output_file_name)
        .expect(format<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;can&#39;t open file[{}] with write option&#34;</span>, output_file_name).as_str());
    col1_buf
        .lines()
        .zip(col2_buf.lines())
        .for_each(<span style="color:#f92672">|</span>(col1, col2)<span style="color:#f92672">|</span> {
            <span style="color:#66d9ef">let</span> col1 <span style="color:#f92672">=</span> col1.expect(<span style="color:#e6db74">&#34;parse error col1&#34;</span>);
            <span style="color:#66d9ef">let</span> col2 <span style="color:#f92672">=</span> col2.expect(<span style="color:#e6db74">&#34;parse error col2&#34;</span>);
            writeln<span style="color:#f92672">!</span>(output_f, <span style="color:#e6db74">&#34;{}\t{}&#34;</span>, col1, col2);
            output_f.flush().expect(<span style="color:#e6db74">&#34;Error during flush&#34;</span>);
        });
}
</code></pre></div><p>2つのファイル名を入力として受け取り、タブでくっつけて出力します。
<code>zip</code>を利用することで、2つのイテレーターを同時に回しています。</p>
<h2 id="14-先頭からn行を出力">14. 先頭からN行を出力</h2>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">head</span>(input_file_name: <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">str</span>, lines: <span style="color:#66d9ef">usize</span>) -&gt; String {
    <span style="color:#66d9ef">let</span> buf <span style="color:#f92672">=</span> BufReader::new(File::open(input_file_name).expect(<span style="color:#e6db74">&#34;file not found&#34;</span>));
    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> head <span style="color:#f92672">=</span> String::new();
    buf.lines().take(lines).for_each(<span style="color:#f92672">|</span>line<span style="color:#f92672">|</span> {
        head.push_str(format<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;{}\n&#34;</span>, line.expect(<span style="color:#e6db74">&#34;parse error&#34;</span>)).as_str());
    });
    <span style="color:#66d9ef">return</span> head;
}
</code></pre></div><p>イテレーターのメソッドに<a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.take"><code>take</code></a>があります。
これを利用することで、引数に指定した数のエレメントが取得できるので、これでheadが実現できます。</p>
<h2 id="15-末尾のn行を出力">15. 末尾のN行を出力</h2>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">tail</span>(input_file_name: <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">str</span>, lines: <span style="color:#66d9ef">usize</span>) -&gt; String {
    <span style="color:#66d9ef">let</span> buf <span style="color:#f92672">=</span> BufReader::new(File::open(input_file_name).expect(<span style="color:#e6db74">&#34;file not found&#34;</span>));
    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> tail <span style="color:#f92672">=</span> String::new();
    <span style="color:#66d9ef">let</span> line_count <span style="color:#f92672">=</span> word_count(input_file_name);
    buf.lines().skip(line_count <span style="color:#f92672">-</span> lines).for_each(<span style="color:#f92672">|</span>line<span style="color:#f92672">|</span> {
        tail.push_str(format<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;{}\n&#34;</span>, line.expect(<span style="color:#e6db74">&#34;parse error&#34;</span>)).as_str());
    });
    <span style="color:#66d9ef">return</span> tail;
}
</code></pre></div><p>tailの場合は少し複雑で、11で作成した行数をカウントするメソッドで総行数を取り出し、そこから引数で指定された行数を引き算した数(=出力しない行数)を、イテレーターの<code>skip</code>メソッドの引数に渡しています。これにより、指定された数のエレメントをスキップしたあとの処理がかけます。</p>
<h2 id="16-ファイルをn分割する">16. ファイルをN分割する</h2>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">split_files</span>(
    input_file_name: <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">str</span>,
    num: <span style="color:#66d9ef">usize</span>,
    output_file_prefix: <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">str</span>,
    output_file_suffix: <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">str</span>,
) {
    <span style="color:#66d9ef">let</span> total <span style="color:#f92672">=</span> word_count(input_file_name) <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">f64</span>;
    <span style="color:#66d9ef">let</span> lines_in_file <span style="color:#f92672">=</span> total <span style="color:#f92672">/</span> num <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">f64</span>;
    <span style="color:#66d9ef">let</span> lines_in_file <span style="color:#f92672">=</span> lines_in_file.ceil() <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">usize</span>; <span style="color:#75715e">//
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">let</span> buf <span style="color:#f92672">=</span> BufReader::new(File::open(input_file_name).expect(<span style="color:#e6db74">&#34;file not found&#34;</span>));

    <span style="color:#66d9ef">let</span> output_files: Vec<span style="color:#f92672">&lt;</span>File<span style="color:#f92672">&gt;</span> <span style="color:#f92672">=</span> create_file_vec(output_file_prefix, num, output_file_suffix);

    println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;split file each {} lines.&#34;</span>, lines_in_file);
    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> lines <span style="color:#f92672">=</span> buf.lines();

    <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">mut</span> output_f <span style="color:#66d9ef">in</span> output_files {
        <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> current <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
        <span style="color:#66d9ef">while</span> current <span style="color:#f92672">&lt;</span> lines_in_file <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> {
            <span style="color:#66d9ef">let</span> line <span style="color:#f92672">=</span> lines.next();
            <span style="color:#66d9ef">if</span> <span style="color:#66d9ef">let</span> Some(line_rs) <span style="color:#f92672">=</span> line {
                <span style="color:#66d9ef">if</span> <span style="color:#66d9ef">let</span> Ok(line_str) <span style="color:#f92672">=</span> line_rs {
                    writeln<span style="color:#f92672">!</span>(output_f, <span style="color:#e6db74">&#34;{}&#34;</span>, line_str);
                }
            }
            current <span style="color:#f92672">=</span> current <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
        }
        output_f.flush().expect(<span style="color:#e6db74">&#34;error during flush&#34;</span>);
    }
}

<span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">create_file_vec</span>(output_file_prefix: <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">str</span>, num: <span style="color:#66d9ef">usize</span>, output_file_suffix: <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">str</span>) -&gt; Vec<span style="color:#f92672">&lt;</span>File<span style="color:#f92672">&gt;</span> {
    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> files <span style="color:#f92672">=</span> Vec::with_capacity(num);
    <span style="color:#66d9ef">for</span> i <span style="color:#66d9ef">in</span> <span style="color:#ae81ff">0</span>..num {
        <span style="color:#66d9ef">let</span> output_file_name <span style="color:#f92672">=</span> format<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;{}{}{}&#34;</span>, output_file_prefix, i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, output_file_suffix);
        <span style="color:#66d9ef">let</span> output_f <span style="color:#f92672">=</span> OpenOptions::new()
            .write(<span style="color:#66d9ef">true</span>)
            .create(<span style="color:#66d9ef">true</span>)
            .open(output_file_name.as_str())
            .expect(format<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;can&#39;t open file[{}] with write option&#34;</span>, output_file_name).as_str());
        files.push(output_f);
    }
    <span style="color:#66d9ef">return</span> files;
}
</code></pre></div><p>ちょっと長いですね。</p>
<p>入力としては、分割するファイル数<code>N</code>が指定されます。まずは、<code>総行数/N</code>で各ファイルに保存されるべき行数を計算します。
次に、2つ目の関数をつかって、必要な数のファイルオブジェクトをベクトルとして生成します。</p>
<p>ファイルオブジェクトのベクトルの要素を元にしたfor文を回しつつ、それぞれのファイルに必要な行数を出力している処理になっています。</p>
<p>総行数が<code>N</code>で割り切れない場合に<code>ceil</code>で切り上げした行数にするというちょっとした処理を入れてあります。</p>
<h2 id="17-１列目の文字列の異なり">17. １列目の文字列の異なり</h2>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">count_uniq_words</span>(input_file_name: <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">str</span>, col: <span style="color:#66d9ef">usize</span>) -&gt; <span style="color:#66d9ef">usize</span> {
    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> words <span style="color:#f92672">=</span> HashSet::new();
    <span style="color:#66d9ef">let</span> buf <span style="color:#f92672">=</span> BufReader::new(File::open(input_file_name).expect(<span style="color:#e6db74">&#34;file not found&#34;</span>));
    buf.lines().for_each(<span style="color:#f92672">|</span>line<span style="color:#f92672">|</span> <span style="color:#66d9ef">match</span> line {
        Ok(line_str) <span style="color:#f92672">=&gt;</span> {
            <span style="color:#66d9ef">let</span> columns: Vec<span style="color:#f92672">&lt;</span>_<span style="color:#f92672">&gt;</span> <span style="color:#f92672">=</span> line_str.split(<span style="color:#e6db74">&#39;\t&#39;</span>).collect();
            words.insert(columns[col].to_string());
        }
        Err(_) <span style="color:#f92672">=&gt;</span> panic<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;parse error &#34;</span>),
    });
    <span style="color:#66d9ef">return</span> words.len();
}
</code></pre></div><p><code>HashSet</code>を利用することでユニーク性を担保して、最後はHashSetの数を数え上げれば終了です。</p>
<h2 id="18-各行を3コラム目の数値の降順にソート">18. 各行を3コラム目の数値の降順にソート</h2>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">sort_on_col3</span>(input_file_name: <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">str</span>) -&gt; String {
    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> lines: <span style="color:#a6e22e">BTreeSet</span><span style="color:#f92672">&lt;</span>Line<span style="color:#f92672">&gt;</span> <span style="color:#f92672">=</span> BTreeSet::new();
    <span style="color:#66d9ef">let</span> buf <span style="color:#f92672">=</span> BufReader::new(File::open(input_file_name).expect(<span style="color:#e6db74">&#34;file not found&#34;</span>));
    buf.lines().for_each(<span style="color:#f92672">|</span>line<span style="color:#f92672">|</span> <span style="color:#66d9ef">match</span> line {
        Ok(line_str) <span style="color:#f92672">=&gt;</span> {
            <span style="color:#66d9ef">let</span> columns: Vec<span style="color:#f92672">&lt;</span>_<span style="color:#f92672">&gt;</span> <span style="color:#f92672">=</span> line_str.split(<span style="color:#e6db74">&#39;\t&#39;</span>).collect();
            <span style="color:#66d9ef">let</span> num: <span style="color:#66d9ef">u32</span> <span style="color:#f92672">=</span> columns[<span style="color:#ae81ff">2</span>].parse().expect(<span style="color:#e6db74">&#34;parse error&#34;</span>);
            <span style="color:#66d9ef">let</span> line <span style="color:#f92672">=</span> Line {
                line: <span style="color:#a6e22e">line_str</span>,
                num,
            };
            lines.insert(line);
        }
        Err(_) <span style="color:#f92672">=&gt;</span> panic<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;parse error&#34;</span>),
    });
    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> sorted <span style="color:#f92672">=</span> String::new();
    lines.iter().for_each(<span style="color:#f92672">|</span>line<span style="color:#f92672">|</span> {
        sorted.push_str(format<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;{}\n&#34;</span>, line.line).as_str());
    });

    <span style="color:#66d9ef">return</span> sorted;
}

<span style="color:#75715e">#[derive(Eq)]</span>
<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Line</span> {
    line: String,
    num: <span style="color:#66d9ef">u32</span>,
}

<span style="color:#66d9ef">impl</span> Ord <span style="color:#66d9ef">for</span> Line {
    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">cmp</span>(<span style="color:#f92672">&amp;</span>self, other: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">Self</span>) -&gt; <span style="color:#a6e22e">Ordering</span> {
        <span style="color:#66d9ef">let</span> ord <span style="color:#f92672">=</span> other.num.cmp(<span style="color:#f92672">&amp;</span>self.num);
        <span style="color:#66d9ef">if</span> <span style="color:#66d9ef">let</span> Ordering::Equal <span style="color:#f92672">=</span> ord {
            other.line.cmp(<span style="color:#f92672">&amp;</span>self.line)
        } <span style="color:#66d9ef">else</span> {
            ord
        }
    }
}

<span style="color:#66d9ef">impl</span> PartialOrd <span style="color:#66d9ef">for</span> Line {
    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">partial_cmp</span>(<span style="color:#f92672">&amp;</span>self, other: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">Self</span>) -&gt; Option<span style="color:#f92672">&lt;</span>Ordering<span style="color:#f92672">&gt;</span> {
        Some(self.cmp(other))
    }
}

<span style="color:#66d9ef">impl</span> PartialEq <span style="color:#66d9ef">for</span> Line {
    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">eq</span>(<span style="color:#f92672">&amp;</span>self, other: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">Self</span>) -&gt; <span style="color:#66d9ef">bool</span> {
        self.eq(other)
    }
}
</code></pre></div><p><code>Line</code>という、行の文章と第3カラム目の値をもった構造体を作成しました。そこにEq、Ord、PartialOrd、PartialEqを実装し、3カラム目での大小比較できるようにしました。
この構造体をBTeeSetに格納していき、イテレーターで回すことで、ソートされた状態にしてあります。
同一数値の場合は行の降順でソートできるようにOrdを実装してあります。</p>
<h2 id="19-各行の1コラム目の文字列の出現頻度を求め出現頻度の高い順に並べる">19. 各行の1コラム目の文字列の出現頻度を求め，出現頻度の高い順に並べる</h2>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">sort_on_frequency</span>(input_file_name: <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">str</span>) -&gt; String {
    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> names: <span style="color:#a6e22e">HashMap</span><span style="color:#f92672">&lt;</span>String, <span style="color:#66d9ef">u32</span><span style="color:#f92672">&gt;</span> <span style="color:#f92672">=</span> HashMap::new();
    <span style="color:#66d9ef">let</span> buf <span style="color:#f92672">=</span> BufReader::new(File::open(input_file_name).expect(<span style="color:#e6db74">&#34;file not found&#34;</span>));
    buf.lines().for_each(<span style="color:#f92672">|</span>line<span style="color:#f92672">|</span> <span style="color:#66d9ef">match</span> line {
        Ok(line_str) <span style="color:#f92672">=&gt;</span> {
            <span style="color:#66d9ef">let</span> columns: Vec<span style="color:#f92672">&lt;</span>_<span style="color:#f92672">&gt;</span> <span style="color:#f92672">=</span> line_str.split(<span style="color:#e6db74">&#39;\t&#39;</span>).collect();
            <span style="color:#66d9ef">let</span> name_str <span style="color:#f92672">=</span> columns[<span style="color:#ae81ff">0</span>].to_string();
            <span style="color:#66d9ef">let</span> count <span style="color:#f92672">=</span> names.entry(name_str).or_insert(<span style="color:#ae81ff">0</span>);
            <span style="color:#f92672">*</span>count <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>;
        }
        Err(_) <span style="color:#f92672">=&gt;</span> panic<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;parse error&#34;</span>),
    });
    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> sorted <span style="color:#f92672">=</span> String::new();
    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> sorted_names: Vec<span style="color:#f92672">&lt;</span>(<span style="color:#f92672">&amp;</span>String, <span style="color:#f92672">&amp;</span><span style="color:#66d9ef">u32</span>)<span style="color:#f92672">&gt;</span> <span style="color:#f92672">=</span> names.iter().collect();
    sorted_names.sort_by(<span style="color:#f92672">|</span>(aname, acount), (bname, bcount)<span style="color:#f92672">|</span> {
        <span style="color:#66d9ef">let</span> ord <span style="color:#f92672">=</span> bcount.cmp(acount);
        <span style="color:#66d9ef">if</span> <span style="color:#66d9ef">let</span> Ordering::Equal <span style="color:#f92672">=</span> ord {
            bname.cmp(aname)
        } <span style="color:#66d9ef">else</span> {
            ord
        }
    });
    sorted_names.iter().for_each(<span style="color:#f92672">|</span>(name, count)<span style="color:#f92672">|</span> {
        sorted.push_str(format<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;{} {}\n&#34;</span>, count, name).as_str());
    });
    <span style="color:#66d9ef">return</span> sorted;
}

</code></pre></div><p>もうすこしうまくできる気がしますが、いったんこれで。
数え上げのためにまずはHashMapに<code>第1カラムの文字列, 個数</code>という組み合わせでデータを入れていきます。
出来上がったHashMapをタプルのベクターに変換し、変換したベクターの<code>sort_by</code>メソッドに比較用の関数を渡すことで個数の降順に並べています。同一個数の場合は文字列の降順になっています。
で、最後に並びかわったベクターのイテレーターを使って出力しておしまいです。
内部的には最悪3回回る感じでしょうか?
最初からベクトルに入れつつソートできる仕組みにするようなのがいいのかなぁ?</p>
<h2 id="まとめ">まとめ</h2>
<p>Unixコマンドの勉強になりましたw
あとは、HashMapなどの勉強にもなりました。
最後の方は効率がいまいち良くない気もしてはいますが、とりあえず第3章に進もうかと思います。</p>
</content:encoded>
    </item>
    
    <item>
      <title>第2章の10から11まで(言語処理100本ノック2020)</title>
      <link>https://blog.johtani.info/blog/2020/05/08/rebootnlp100-ch02-10to11/</link>
      <pubDate>Fri, 08 May 2020 23:37:20 +0900</pubDate>
      
      <guid>https://blog.johtani.info/blog/2020/05/08/rebootnlp100-ch02-10to11/</guid>
      <description>気づいたら1ヶ月サボってました、ごめんなさい。。。 Rustで言語処理100本ノックの第2章をはじめました。 前回はこちら。 確認用のUnixコマ</description>
      <content:encoded><p>気づいたら1ヶ月サボってました、ごめんなさい。。。</p>
<p>Rustで言語処理100本ノックの第2章をはじめました。</p>
<p>前回は<a href="/blog/2020/05/08/reboot-nlp100-finish-ch01">こちら</a>。</p>
<h2 id="確認用のunixコマンド">確認用のUnixコマンド</h2>
<p>確認用のファイルを先に生成して置きました。
これで、Rustでコードを書いて、作成済みの確認ファイルを元に<code>assert_eq!</code>でチェックするという方式を取ろうかと。</p>
<p>で、コマンド群は<a href="https://github.com/johtani/nlp100-rust/blob/master/commands/chap02.sh">こちら</a>です。</p>
<p>Unix/Linuxコマンド、昔から使っています。が、なにかちょっとした文字列処理やファイル処理をやるときは、Javaのプログラム(最近だとPython)を書くというのが基本になってるので、結構、使ったことの無いコマンドが今回ありました。使ったことがなかったのはこちらです。</p>
<ul>
<li><code>sed</code></li>
<li><code>tr</code></li>
<li><code>expand</code></li>
<li><code>paste</code></li>
<li><code>cut</code></li>
<li><code>split</code></li>
</ul>
<p><code>sed</code>とかは普通さわってるだろ?って思われそうですね。。。</p>
<p>で、コマンドを<code>man</code>で調べつつやりました、macOS上で。
これがまたいくつか罠があったので書き残しておきます(自分が知らないだけかもしれないので、おかしいところがあったらツッコミお願いします。)。</p>
<h3 id="sedコマンドでのタブの扱い"><code>sed</code>コマンドでのタブの扱い</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh"><span style="color:#75715e">## sed command for macOS. If using Linux, use &#34;\t&#34; for tab character</span>
cat $INPUT_FILE_NAME | sed -e <span style="color:#e6db74">&#39;s/	/ /g&#39;</span> &gt; $OUTPUT_DIR/11_sed.txt
</code></pre></div><p><code>\t</code>で行けると思ったのですが、うまく動きませんでした。<code>&lt;tab&gt;</code>みたいな書き方もあると思うのですが、これも駄目で、結局タブ文字をそのまま打ち込みました。。。
これ、めんどくさくないですか???
ちなみに、ターミナルで動作確認して、GitHubにあげてあるシェルファイルにコピペしてたのですが、CLionに貼り付けたらタブ文字がスペースに変換されてしまってて20分くらい悩みました。。。</p>
<h3 id="splitコマンドに-nオプションがない"><code>split</code>コマンドに<code>-n</code>オプションがない</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">
LINES<span style="color:#f92672">=</span><span style="color:#e6db74">`</span>cat $OUTPUT_DIR/10.txt<span style="color:#e6db74">`</span>
SPLIT_LINES<span style="color:#f92672">=</span><span style="color:#e6db74">`</span>echo $LINES/$N | bc<span style="color:#e6db74">`</span>
split -a <span style="color:#ae81ff">1</span> -l $SPLIT_LINES $INPUT_FILE_NAME $OUTPUT_DIR/16_
</code></pre></div><p><code>split</code>コマンドについてググると、<code>-n</code>で指定した数のファイルに分割できるという記事がいくつも出てくるのですが、<code>man split</code>をターミナル上でやるとそんなオプションがないと。。。
macOSがBSD系だからっぽいです。
ということで、行数を元に、指定した数(<code>N</code>)で行数を割ってから、指定行数ごとにファイルを分割する方式にしました。</p>
<p>これらのコマンドの違いはHomebrewとかでインストールするとなくなるのかなぁ?(めんどくさいので確認してないですが。。。)</p>
<p>ってことで、2章のそれぞれの課題の正解ファイルの生成はこれでできたはずです。</p>
<h2 id="10-行数のカウント">10. 行数のカウント</h2>
<p><code>wc -l</code>ですね。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#75715e">// ch02-10 行数のカウント
</span><span style="color:#75715e"></span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">word_count</span>(file_name: <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">str</span>) -&gt; <span style="color:#66d9ef">usize</span> {
    <span style="color:#66d9ef">let</span> f <span style="color:#f92672">=</span> File::open(file_name).expect(<span style="color:#e6db74">&#34;file not found&#34;</span>);
    <span style="color:#66d9ef">let</span> buf <span style="color:#f92672">=</span> BufReader::new(f);
    <span style="color:#66d9ef">return</span> buf.lines().count();
}
</code></pre></div><p>ファイルを読み込んで行数を数えます。
文字列として読み込んで改行コードの数を数えるというのもありかな?と思いましたが、Rustの<code>BufReader</code>に<code>lines()</code>という行のイテレータ?が取れることがわかったので、それでカウントを取りました。</p>
<h2 id="11-タブをスペースに置換">11. タブをスペースに置換</h2>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#75715e">// ch02-11 タブをスペースに置換
</span><span style="color:#75715e"></span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">tab_2_space</span>(file_name: <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">str</span>) -&gt; String {
    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> f <span style="color:#f92672">=</span> File::open(file_name).expect(<span style="color:#e6db74">&#34;file not found&#34;</span>);
    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> contents<span style="color:#f92672">=</span> String::new();
    f.read_to_string(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> contents).expect(<span style="color:#e6db74">&#34;read error&#34;</span>);
    <span style="color:#66d9ef">return</span> contents.replace(<span style="color:#e6db74">&#34;\t&#34;</span>, <span style="color:#e6db74">&#34; &#34;</span>);
}
</code></pre></div><p>こっちはファイル全体を文字列に読み込んでしまってから、文字列の<code>replace</code>で置換するという方式です。
ファイルが大きい場合にこれでいいのか?という問題がある気がしますが、まずはこの実装にしました。
やるとしたら、<code>read</code>メソッドと<code>buffer</code>を用意して、少しずつ読みながら、置換して吐き出す感じでしょうか?
ちゃんとした文字コードの区切りで取れるかどうかを気にしないと行けないと思うので、思ったよりはめんどくさくなりそう。</p>
<p><code>BufReader</code>をつかって<code>read_line</code>のほうがましかも?</p>
<h2 id="まとめ">まとめ</h2>
<p>ということで、サボっていたのを再開しました。
Rustのコードを書く前に、Unixコマンドの処理に結構悩みましたw</p>
<p>Rustのコードとしてはファイル処理なので、今後も役立つ気がしてます。
ということで、頑張っていくぞと。</p>
</content:encoded>
    </item>
    
    <item>
      <title>第1章の08から09まで(言語処理100本ノック2020)</title>
      <link>https://blog.johtani.info/blog/2020/05/08/reboot-nlp100-finish-ch01/</link>
      <pubDate>Fri, 08 May 2020 16:40:57 +0900</pubDate>
      
      <guid>https://blog.johtani.info/blog/2020/05/08/reboot-nlp100-finish-ch01/</guid>
      <description>Rustで言語処理100本ノックのリファクタリングの続き。 前回はこちら。 とっくに終わってたのに、ブログ書いてなかった。。。 08. 暗号文 pub fn cipher(text: &amp;amp;str) -&amp;gt;</description>
      <content:encoded><p>Rustで言語処理100本ノックのリファクタリングの続き。</p>
<p>前回は<a href="/blog/2020/04/09/reboot-nlp100-ch01-03to05/">こちら</a>。</p>
<p>とっくに終わってたのに、ブログ書いてなかった。。。</p>
<h3 id="08-暗号文">08. 暗号文</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">cipher</span>(text: <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">str</span>) -&gt; String {
    <span style="color:#66d9ef">return</span> String::from_iter(text.chars().map(<span style="color:#f92672">|</span>x<span style="color:#f92672">|</span> {
        <span style="color:#66d9ef">if</span> x.is_ascii_alphanumeric() <span style="color:#f92672">&amp;&amp;</span> x.is_lowercase() {
            <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> b <span style="color:#f92672">=</span> [<span style="color:#ae81ff">0</span>; <span style="color:#ae81ff">4</span>];
            x.encode_utf8(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> b);
            b[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">219</span> <span style="color:#f92672">-</span> b[<span style="color:#ae81ff">0</span>];
            char::from(b[<span style="color:#ae81ff">0</span>])
        } <span style="color:#66d9ef">else</span> {
            x
        }
    }));
}
</code></pre></div><p>Rustの文字列はUTF-8でエンコードされたテキストを保持しているので、文字コード自体は意識していないです。
<code>chars()</code>でUnicodeスカラー値のイテレータが返ってくるので、1文字ずつ扱えるようになります。</p>
<p>ただ、1文字をバイトとして扱うのに手こずりました。
<code>encode_utf8</code>というメソッドを利用して1バイトだけ取り出して、計算するというのをやっています。
文字種の判別のメソッドが用意されているのは便利ですね。</p>
<p>なんかもうちょっとスマートにできないのかな?と思いつつ動いたのでこれになってます。</p>
<h3 id="09-typoglycemia">09. Typoglycemia</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">typoglycemia</span>(text: <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">str</span>) -&gt; String {
    <span style="color:#66d9ef">return</span> text
        .split_whitespace()
        .map(<span style="color:#f92672">|</span>word<span style="color:#f92672">|</span> {
            <span style="color:#66d9ef">if</span> word.len() <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">4</span> {
                word.to_string()
            } <span style="color:#66d9ef">else</span> {
                <span style="color:#66d9ef">let</span> original <span style="color:#f92672">=</span> word.chars().collect::<span style="color:#f92672">&lt;</span>Vec<span style="color:#f92672">&lt;</span>char<span style="color:#f92672">&gt;&gt;</span>();
                <span style="color:#66d9ef">let</span> first <span style="color:#f92672">=</span> original.get(<span style="color:#ae81ff">0</span>).unwrap();
                <span style="color:#66d9ef">let</span> last <span style="color:#f92672">=</span> original.last().unwrap();
                <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> typo <span style="color:#f92672">=</span> original[<span style="color:#ae81ff">1</span>..original.len() <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>]
                    .iter()
                    .map(<span style="color:#f92672">|</span>x<span style="color:#f92672">|</span> x.clone())
                    .collect::<span style="color:#f92672">&lt;</span>Vec<span style="color:#f92672">&lt;</span>char<span style="color:#f92672">&gt;&gt;</span>();
                <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> rng <span style="color:#f92672">=</span> thread_rng();
                typo.shuffle(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> rng);
                <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> typo <span style="color:#f92672">=</span> String::from_iter(typo.iter());
                typo.insert(<span style="color:#ae81ff">0</span>, first.clone());
                typo.push(last.clone());
                typo
            }
        })
        .collect::<span style="color:#f92672">&lt;</span>Vec<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;&gt;</span>()
        .join(<span style="color:#e6db74">&#34; &#34;</span>);
}
</code></pre></div><p>一応、1行で記述できたかな?
まずは、スペースで単語ごとに区切った後に、<code>word</code>(単語)の長さによって、処理を分岐し、単語が5文字以上の場合にランダムに並び替えを行うというのをやっています。
文字単位で処理を行うために、<code>chars()</code>で1文字ずつ取り出しています。
最初と最後の文字だけはそのままに、間の文字をランダムにシャッフルするというのをやるのに、もとの<code>word</code>のスライスからコピーした文字列を作り出してから組み立て直すということをやっています。</p>
<p>コピーしないでゴニョゴニョする方法ってあるのかなぁ?
思いつかなかったので、結構泥臭い感じの実装になってしまいました。</p>
<h2 id="まとめ">まとめ</h2>
<p>めんどくさいので、コードをGitHubのソースコードからではなく、ブログにコードスニペットとしてコピペしました。Hugoでいい感じにGitHubのコードスニペット表示するのないかなぁ?</p>
<p>ということで、2年越しで1章が終了しました。
2章もやらないとなぁ。</p>
</content:encoded>
    </item>
    
    <item>
      <title>Rust the book - 第8章</title>
      <link>https://blog.johtani.info/blog/2020/04/16/chap8-rust-the-book/</link>
      <pubDate>Thu, 16 Apr 2020 18:17:30 +0900</pubDate>
      
      <guid>https://blog.johtani.info/blog/2020/04/16/chap8-rust-the-book/</guid>
      <description>前回の記事はこちら。自分用のメモなので、読みにくいかもです。 Rust the Bookを読み始めた Rust the book - 第4章 Rust the book - 第5章 Rust the book - 第6章 第8章 7章はパ</description>
      <content:encoded><p>前回の記事はこちら。自分用のメモなので、読みにくいかもです。</p>
<ul>
<li><a href="/blog/2020/03/23/start-reading-rust-the-book/">Rust the Bookを読み始めた</a></li>
<li><a href="/blog/2020/03/26/chap4-rust-the-book/">Rust the book - 第4章</a></li>
<li><a href="/blog/2020/04/02/chap5-rust-the-book/">Rust the book - 第5章</a></li>
<li><a href="/blog/2020/04/07/chap6-rust-the-book/">Rust the book - 第6章</a></li>
</ul>
<h2 id="第8章">第8章</h2>
<p>7章はパッケージなので後回しにして、8章に入ります。
8章はコレクションです。</p>
<h3 id="ベクタ型">ベクタ型</h3>
<ul>
<li>ベクタは同じ型の値だけ保持可能。
<ul>
<li>ジェネリクスで型を指定可能 - <code>Vec&lt;i32&gt;</code>とか。</li>
</ul>
</li>
<li><code>vec!</code>マクロで初期値とか設定すると便利。</li>
<li>ベクタに値を追加するのは<code>push</code>。もちろん値が変わるので元のベクタには<code>mut</code>が必要</li>
<li>ベクタのスコープ(ライフサイクル)は要素に対する参照があるのとないので話が変わってくる
<ul>
<li>メモリの確保などの影響で、ベクタ全体に対して借用の規則が矯正されると。</li>
</ul>
</li>
<li>ベクタの値を読むのはいくつか方法あり
<ul>
<li><code>get</code>メソッドはOptionを返す</li>
<li><code>&amp;v[2]</code>の添字記法の場合はパニックの可能性あり</li>
</ul>
</li>
<li>走査(唐突に参照外しが出てきた)
<ul>
<li>単純に値を取り出す場合は<code>for - in &amp;v</code></li>
</ul>
</li>
<li>Enumをベクタにいれることで、異なる型も保持可能(まぁ、Enumの型では固定されるけど)。
<ul>
<li>これだけのためにEnumを使うことってあるのかな?</li>
<li>トレイとオブジェクトに関する文章はちょっとわかりにくい。。。</li>
</ul>
</li>
</ul>
<p>説明以外のメソッドなどについてはAPIドキュメント見ましょうと(リンクも張ってくれてると嬉しいなぁと思ったり。まぁ、バージョンとかの絡みがあるから難しいか)。</p>
<h3 id="文字列型">文字列型</h3>
<ul>
<li>
<p>文字列はUTF-8でエンコードされた文字を扱うための型。</p>
</li>
<li>
<p><code>str</code>は文字列データへの参照。</p>
</li>
<li>
<p><code>String</code>型は言語のコアではなく、標準ライブラリに入っている文字列型。</p>
<ul>
<li>他にもあるのか。。。<code>OsString</code>とか。。。</li>
</ul>
</li>
<li>
<p>文字リテラルはDisplayトレイトを実装していると。</p>
</li>
<li>
<p><code>.to_string()</code> = <code>String::from</code></p>
</li>
<li>
<p>Stringはコレクションだから追加とかが可能なのか、なるほど。</p>
</li>
<li>
<p><code>push_str</code>と<code>push</code></p>
</li>
<li>
<p><a href="https://doc.rust-jp.rs/book/second-edition/ch08-02-strings.html#a%E6%BC%94%E7%AE%97%E5%AD%90%E3%81%BE%E3%81%9F%E3%81%AFformat%E3%83%9E%E3%82%AF%E3%83%AD%E3%81%A7%E9%80%A3%E7%B5%90"><code>+</code>演算子での参照</a>。</p>
<ul>
<li><code>&amp;String</code>は<code>&amp;str</code>に型強制(キャスト?)してくれる。してくれる場合としてくれない場合もあるのかな?<code>s2</code>の所有権は奪わない形で扱うので<code>s2</code>はこのあとも使えていると。</li>
<li>ここでは、<code>s1</code>を変更したあとに所有権が<code>s3</code>に持っていかれてる?</li>
<li><code>format!</code>を使うとどの所有権も奪わないので、これを使うほうが考え方は簡単そう。ただし、効率がいいかはわからん。</li>
</ul>
</li>
<li>
<p>添字記法でのアクセスを<code>String</code>は許容していない</p>
<ul>
<li>文字の境界が必ずしも1バイトとは限らないから。</li>
<li>スライスも同様。</li>
</ul>
</li>
<li>
<p>基本的には<code>.chars()</code>で文字としてアクセスするのが良い。</p>
</li>
<li>
<p>逆にバイト表現を得る方法はどうするんだろう?</p>
<ul>
<li><a href="https://github.com/johtani/nlp100-rust/blob/master/src/chapter01/answer.rs#L155">NLP100本ノックでは<code>encode_utf8</code>メソッド使ったけど。</a></li>
</ul>
</li>
</ul>
<h3 id="ハッシュマップ">ハッシュマップ</h3>
<ul>
<li>いろんな呼び方あるよね。Rustではハッシュマップだよ。</li>
<li>ハッシュマップは<code>use</code>しないと使えない</li>
<li>キーは1つの型、値も1つの型</li>
<li>タプルのベクタから<code>collect</code>で生成。なるほど。
<ul>
<li>タプルのベクタだと、タプルの中身は同じものであることが言える?
<ul>
<li>-&gt; 言える。エレメント数が異なるとコンパイルエラーになった</li>
</ul>
</li>
</ul>
</li>
<li><a href="https://doc.rust-jp.rs/book/second-edition/ch08-03-hash-maps.html#a%E3%83%8F%E3%83%83%E3%82%B7%E3%83%A5%E3%83%9E%E3%83%83%E3%83%97%E3%81%A8%E6%89%80%E6%9C%89%E6%A8%A9">所有権周りの話。</a>
<ul>
<li>これ、ベクタのときに話してほしい感じがした。</li>
<li>値を渡すか参照を渡すかによって話が変わってくる。詳しくは10章</li>
<li>このあたりが自分が混乱していた元だ。</li>
</ul>
</li>
<li><code>entry</code>と<code>insert</code>の違い
<ul>
<li><code>entry</code>の戻り値は<code>Entry</code>というenumで<code>or_insert</code>というメソッドがありそれを使うと存在しない場合だけinsertが呼ばれる。
<ul>
<li>これ便利だ。毎回<code>exist</code>あたりで存在チェックしてた気がする。</li>
</ul>
</li>
</ul>
</li>
<li><code>or_insert</code>は可変参照<code>&amp;mut V</code>を返す。
<ul>
<li>これを<code>let count</code>で束縛するときに、中身が可変かどうかをcountには指定しないのか。。。</li>
</ul>
</li>
</ul>
<h2 id="まとめ">まとめ</h2>
<p>一応、大学などで習ってた(はず)ですが、
スタックとヒープを意識して考えないといけないなぁというのを何度か意識させられた感じです。</p>
<p>あと、これはRustに限らずですが、それぞれがどんな関数を持っているか、どんなメソッドを持っているか、どんなマクロが存在するかなどを探すときにみんなどうしてるんだろう?
人に教えてもらっているのか、APIリファレンスを探すのか、そういったところをみんながどういう感じにプログラミング言語を勉強しているか、業務で書いているのかと言うのが気になりました。</p>
</content:encoded>
    </item>
    
    <item>
      <title>第1章の03から06まで(言語処理100本ノック2020)</title>
      <link>https://blog.johtani.info/blog/2020/04/09/reboot-nlp100-ch01-03to05/</link>
      <pubDate>Thu, 09 Apr 2020 18:14:55 +0900</pubDate>
      
      <guid>https://blog.johtani.info/blog/2020/04/09/reboot-nlp100-ch01-03to05/</guid>
      <description>Rustで言語処理100本ノックのリファクタリングの続き。 前回はこちら。 コードも載せたほうが見やすいかなぁ? 03. 円周率 2年前はこちら。 どちらか</description>
      <content:encoded><p>Rustで言語処理100本ノックのリファクタリングの続き。</p>
<p>前回は<a href="/blog/2020/04/08/reboot-nlp10-with-rust/">こちら</a>。</p>
<p>コードも載せたほうが見やすいかなぁ?</p>
<h3 id="03-円周率">03. 円周率</h3>
<p><a href="/blog/2018/02/19/nlp100-ch01-03to04/#03-%E5%86%86%E5%91%A8%E7%8E%87">2年前はこちら</a>。
どちらかというとJavaっぽい書き方かな?
入れ物を用意して、入力を整形して、それからループを回す感じで書いてました。</p>
<p><a href="https://github.com/johtani/nlp100-rust/blob/master/src/chapter01/answer.rs#L50">今回は1行で収めてみました</a>。
Rustっぽく、<code>return</code>を省略してみました。
あとは、Iteratorを組み合わせる感じでやってます。
アルファベットの文字数ということで、<code>is_alphabetic()</code>メソッドでfilterしてます。</p>
<h3 id="04-元素記号">04. 元素記号</h3>
<p><a href="/blog/2018/02/19/nlp100-ch01-03to04/#04-%E5%85%83%E7%B4%A0%E8%A8%98%E5%8F%B7">2年前はこちら</a>。
エラー処理が多いのと、文字の扱いがちょっと</p>
<p>ここまで同様に<a href="https://github.com/johtani/nlp100-rust/blob/master/src/chapter01/answer.rs#L64">極力イテレータを利用する</a>という方針でリファクタリングしました。
あとは、エラー処理を除去してます。
正常系だけのテストなのでスッキリさせました。</p>
<p>こういった、ストリーム系?の書き方の場合にエラー処理をどう入れるかってところはちょっと悩みどころになるんじゃないかなぁ?と思いつつ、イレギュラーなものは後回しで(あとにやるのかなぁ?)</p>
<h3 id="05-n-gram">05. n-gram</h3>
<p><a href="/blog/2018/03/20/nlp100-ch01-05to06/#05-n-gram">2年前はこちら</a>。
これまでと同じく、入れ物を作ってから処理をしてます。</p>
<p>同じく、<a href="https://github.com/johtani/nlp100-rust/blob/master/src/chapter01/answer.rs#L82">極力イテレータを利用する形</a>で実装しました。
いくつか型の変換が必要なので、<code>.map()</code>を呼び出して詰め替えたりしています。</p>
<h3 id="06-集合">06. 集合</h3>
<p><a href="/blog/2018/03/20/nlp100-ch01-05to06/#06-%E9%9B%86%E5%90%88">2年前はこちら</a>。
独自に実装しています。</p>
<p>せっかく<code>05</code>で文字n-gramの配列を返す処理を実装しているので、
そちらを呼び出して、Setに入れるという処理に書き換えました。
その後の集合に対する処理については特にリファクタリングしてないです。</p>
<h2 id="まとめ">まとめ</h2>
<p>2年前にやってたところまでは追いつきました。
07は特にリファクタリングする必要がないので、次は08からの予定です。</p>
<p>リファクタリングしているときになるのは、速度とかでしょうか。
実装の違いでなにか差が出るのかどうかはちょっと気になるところですが、
今回の目的ではないので、目をつぶって進める予定です。</p>
</content:encoded>
    </item>
    
    <item>
      <title>言語処理100本ノック、再び</title>
      <link>https://blog.johtani.info/blog/2020/04/08/reboot-nlp10-with-rust/</link>
      <pubDate>Wed, 08 Apr 2020 18:33:45 +0900</pubDate>
      
      <guid>https://blog.johtani.info/blog/2020/04/08/reboot-nlp10-with-rust/</guid>
      <description>今回もツイートから。 言語処理100本ノックの2020年版を公開しました。最近の自然言語処理の研究動向を反映し、深層ニューラルネットワークに関</description>
      <content:encoded><p>今回もツイートから。</p>
<blockquote class="twitter-tweet"><p lang="ja" dir="ltr">言語処理100本ノックの2020年版を公開しました。最近の自然言語処理の研究動向を反映し、深層ニューラルネットワークに関する問題を追加しました。留学生も一緒に取り組めるように多言語化を進め、その第１弾として英訳を部分公開しています（40番以降は順次公開予定）。 <a href="https://t.co/52h362PIQQ">https://t.co/52h362PIQQ</a></p>&mdash; Naoaki Okazaki (@chokkanorg) <a href="https://twitter.com/chokkanorg/status/1247312205671874561?ref_src=twsrc%5Etfw">April 6, 2020</a></blockquote>
<script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>

<p><a href="https://nlp100.github.io/ja/">言語処理100本ノック</a>が2020年版になったそうです。
そうです、2年前に初めて、<a href="/blog/2018/03/20/nlp100-ch01-05to06/">準備運動</a>で止まっていたんです!(衝撃的な続かなさ。。。)</p>
<p>ということで、Rust the bookも読んでいることだし、過去のプログラムをチェックしつつ再開しようかなと。
ということで、いくつかリファクタリングしてみました。</p>
<p><a href="https://github.com/johtani/nlp100-rust/blob/master/src/chapter01/answer.rs">ソースはリポジトリ</a>を御覧ください。</p>
<h3 id="00-文字列の逆順">00. 文字列の逆順</h3>
<p><a href="https://github.com/johtani/nlp100-rust/blob/5439f96e8521bffe34689c23aa076eb3a2fe817b/src/chapter01/answer.rs#L6">2年前の実装</a>では、<code>chars()</code>メソッドで取り出したあとに、<code>collect()</code>でVecにしていたのですが、<a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.rev">RustのIteratorトレイトに<code>rev()</code>という便利なメソッドが存在していました</a>。</p>
<p>ということで、これを取り出すと、最初の文字列の逆順で文字を取り出すIteratorが取得できます。
あとは、<a href="https://doc.rust-lang.org/std/iter/trait.FromIterator.html#tymethod.from_iter">Stringが実装してくれている<code>from_iter</code></a>に渡せば文字列が出来上がります。</p>
<h3 id="01-パタトクカシーー">01. 「パタトクカシーー」</h3>
<p>ストリーム処理っぽい書き方に変更しました。
2年前はIteratorを取り出して、詰替していましたが、
<code>enumerate()</code>で添字と文字のタプルのイテレータに変換し、
<code>filter</code>で添字が偶数のときだけフィルタリングして、
<code>map</code>で対象の文字をまとめたイテレータにします。
で、最後はそれを元に文字列を生成することにしました。
<code>iter</code>を使わないでそのまま<code>String::from_iter</code>の引数に渡すことも可能ですね。</p>
<h3 id="02-パトカータクシーパタトクカシーー">02. 「パトカー」＋「タクシー」＝「パタトクカシーー」</h3>
<p>2年前は<a href="https://github.com/johtani/nlp100-rust/blob/5439f96e8521bffe34689c23aa076eb3a2fe817b/src/chapter01/answer.rs#L30">2つのIteratorを<code>loop</code>で回して頑張って結合してました</a>。
ではなく、<a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.zip"><code>zip()</code></a>を使って、2つのイテレータを組み合わせる方法に替えてみました。
このとき、2つの文字列が違う文字数の場合の処理として、長い方から取り出した文字をあとに結合する処理を追加で記述しました。
ちょっとスマートな感じになりましたかね?</p>
<p><code>zip</code>したあとに出てきたタプルの文字列を結合するのに<code>format!</code>マクロを使いましたが、他にいい方法有るかなぁ?</p>
<h2 id="まとめ">まとめ</h2>
<p>とりあえず最初の3つをリファクタリングしてみました。
残りもやりつつ、準備運動以降もがんばるぞと。</p>
</content:encoded>
    </item>
    
    <item>
      <title>Rust the book - 第6章</title>
      <link>https://blog.johtani.info/blog/2020/04/07/chap6-rust-the-book/</link>
      <pubDate>Tue, 07 Apr 2020 19:27:11 +0900</pubDate>
      
      <guid>https://blog.johtani.info/blog/2020/04/07/chap6-rust-the-book/</guid>
      <description>前回の記事はこちら。自分用のメモなので、読みにくいかもです。 Rust the Bookを読み始めた Rust the book - 第4章 Rust the book - 第5章 第6章 Enumです。matc</description>
      <content:encoded><p>前回の記事はこちら。自分用のメモなので、読みにくいかもです。</p>
<ul>
<li><a href="/blog/2020/03/23/start-reading-rust-the-book/">Rust the Bookを読み始めた</a></li>
<li><a href="/blog/2020/03/26/chap4-rust-the-book/">Rust the book - 第4章</a></li>
<li><a href="/blog/2020/04/02/chap5-rust-the-book/">Rust the book - 第5章</a></li>
</ul>
<h2 id="第6章">第6章</h2>
<p>Enumです。<code>match</code>式に大活躍</p>
<h3 id="enumを定義する">Enumを定義する</h3>
<ul>
<li>列挙型は取りうる値をすべて<em>列挙</em>できる。これが名前の由来</li>
<li>列挙型と列挙子
<ul>
<li>2連コロン(<code>::</code>)で列挙子を指定可能</li>
</ul>
</li>
<li>列挙子にデータ(構造体も)が格納可能。
<ul>
<li><a href="https://doc.rust-lang.org/stable/std/net/enum.IpAddr.html">標準ライブラリに実装例あり。</a></li>
</ul>
</li>
<li>疑問:<code>Write(String)</code>とかはタプルの表現になるのかな?
<ul>
<li>と思ったが、タプルでは1つだけの変数を持つものは定義(正確には定義できるが、内部で普通の変数にもどされてるっぽい)できなかった。</li>
</ul>
</li>
<li>メソッド定義も可能
<ul>
<li>関連関数もできる? -&gt; できる</li>
</ul>
</li>
</ul>
<h4 id="optionの紹介">Optionの紹介</h4>
<ul>
<li>Rustに<code>null</code>はない。代わりにOptionがある</li>
<li>Noneを指定する場合に型が必要。Someの場合はすでに値が入るから推測可能なため。</li>
</ul>
<h3 id="match制御フロー演算子">match制御フロー演算子</h3>
<ul>
<li>アーム -&gt; matchしたときの処理のこと
<ul>
<li>短い場合は波括弧は不要</li>
</ul>
</li>
<li>returnなしでmatchが書いてあるだけだと、慣れない場合に値を返していることに気づかないかも(実際気づけてないかも)</li>
<li>Enumが値を持っているときに、値の束縛がmatch式で可能</li>
<li>すべての列挙子を網羅していないことをコンパイラが検知してくれるのはすごく助かる。
<ul>
<li>ただし、<code>_</code>を利用していなければだけど</li>
</ul>
</li>
</ul>
<h3 id="if-letで簡潔な制御フロー">if letで簡潔な制御フロー</h3>
<ul>
<li>enumで1つのパターンのときに処理をしたい場合に使えるmatchの糖衣構文</li>
<li>elseもかけるよ。</li>
</ul>
<h2 id="まとめ">まとめ</h2>
<p>enumに慣れていないので、値や構造体を持つenumを利用するという想像ができないことがありそうだなぁと読みながら思いました。
それになれると、色々とプログラムがシンプルに書ける部分が多くなりそうかな。</p>
</content:encoded>
    </item>
    
    <item>
      <title>Rust the book - 第5章</title>
      <link>https://blog.johtani.info/blog/2020/04/02/chap5-rust-the-book/</link>
      <pubDate>Thu, 02 Apr 2020 15:09:18 +0900</pubDate>
      
      <guid>https://blog.johtani.info/blog/2020/04/02/chap5-rust-the-book/</guid>
      <description>前回の記事はこちら。自分用のメモなので、読みにくいかもです。 Rust the Bookを読み始めた Rust the book - 第4章 第5章 構造体です。勝手知ったるなんとやら?</description>
      <content:encoded><p>前回の記事はこちら。自分用のメモなので、読みにくいかもです。</p>
<ul>
<li><a href="/blog/2020/03/23/start-reading-rust-the-book/">Rust the Bookを読み始めた</a></li>
<li><a href="/blog/2020/03/26/chap4-rust-the-book/">Rust the book - 第4章</a></li>
</ul>
<h2 id="第5章">第5章</h2>
<p>構造体です。勝手知ったるなんとやら?オブジェクト指向的な部分は問題ないかなぁと。</p>
<h3 id="定義とインスタンス化">定義とインスタンス化</h3>
<ul>
<li><code>struct</code>で定義</li>
<li>インスタンスの生成は引数は順不同でOK</li>
<li>構造体のインスタンスを可変にするとフィールドの値も変更可能
<ul>
<li>特定のフィールドのみ可変にすることは不可能</li>
</ul>
</li>
<li>インスタンス化する関数の最後でreturnなしでインスタンスの返却を暗黙にできる(return書いてほしいな。。。)</li>
<li>インスタンス化時にフィールド初期化省略記法が可能(これはちょっと便利?)</li>
<li>構造体更新記法<code>..user1</code>のように、明示的に設定されていない他のフィールドをコピーしてくれる機能あり</li>
</ul>
<h4 id="タプル構造体">タプル構造体</h4>
<ul>
<li>タプル構造体!? <code>struct Color(i32, i32, i32);</code>
<ul>
<li>いつ使うんだろう?</li>
</ul>
</li>
</ul>
<h4 id="ユニット様構造体">ユニット様構造体</h4>
<ul>
<li>ユニット様構造体 = フィールドのない構造体。トレイトを実装したいけどインスタンスで持つ値はない場合に利用</li>
</ul>
<h4 id="ライフタイム">ライフタイム</h4>
<ul>
<li>構造体が参照を持つときにライフタイムという話が出てくる。なるほど。
<ul>
<li>ライフタイム指定子が必要になる -&gt; 10章での話</li>
</ul>
</li>
</ul>
<h3 id="プログラム例">プログラム例</h3>
<ul>
<li>タプルを引数かぁ。タプルは慣れないので構造体作りそう</li>
<li>Debugトレイトと<code>{:?}</code>という書き方
<ul>
<li><code>derive(Debug)</code>でデバッグ用のトレイトを自動で実装=継承してくれる</li>
<li><code>{:#?}</code>だとpretty printになる(改行とか入る)</li>
</ul>
</li>
</ul>
<p>この辺の便利なトレイとは<a href="https://doc.rust-jp.rs/book/second-edition/appendix-03-derivable-traits.html">付録C</a>にあるらしい。この辺はやりながら覚えるしかないか。</p>
<h3 id="メソッド記法">メソッド記法</h3>
<ul>
<li>最初の引数は必ず<code>self</code></li>
<li><code>impl</code>は構造体とは別の場所に書く = Javaのクラスとは違う</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Rectangle</span> {
    width: <span style="color:#66d9ef">u32</span>,
    height: <span style="color:#66d9ef">u32</span>,
}

<span style="color:#66d9ef">impl</span> Rectangle {
    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">area</span>(<span style="color:#f92672">&amp;</span>self) -&gt; <span style="color:#66d9ef">u32</span> {
        self.width <span style="color:#f92672">*</span> self.height
    }
}
</code></pre></div><ul>
<li>参照じゃない<code>self</code>も使えるらしい。どういうときに使うんだろう?</li>
</ul>
<h4 id="関連関数">関連関数</h4>
<ul>
<li><code>self</code>なしの関数をimplにかける。Javaのスタティックメソッドみたいな感じ</li>
</ul>
<h4 id="その他">その他</h4>
<ul>
<li><code>impl</code>ブロックがあちこちにかける。これはつらいな。。。</li>
<li>2つにわかれた<code>impl</code>ブロックに同じメソッドを書いてみたら、CLionのプラグインではエラーを検知してもらえなかった。
<ul>
<li>cargo buildではきちんとエラーが表示された。</li>
</ul>
</li>
<li>
<blockquote>
<p>複数のimplブロックが有用になるケースは第10章で見ますが、そこではジェネリック型と、トレイトについて議論します。</p>
</blockquote>
<ul>
<li>人の構造体に自分のトレイトを適用したりもできる。</li>
</ul>
</li>
</ul>
<h4 id="実験">実験</h4>
<p>スコープとかどうなりそう?って実験もしてみた。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">trait</span> Hoge {
        <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">trim</span>(<span style="color:#f92672">&amp;</span>self);
    }

    <span style="color:#66d9ef">impl</span> Hoge <span style="color:#66d9ef">for</span> String {
        <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">trim</span>(<span style="color:#f92672">&amp;</span>self) {
            println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;hogehoge {}&#34;</span>, <span style="color:#f92672">&amp;</span>self);
        }
    }
    <span style="color:#66d9ef">let</span> c <span style="color:#f92672">=</span> String::from(<span style="color:#e6db74">&#34;hoge&#34;</span>);
    c.trim();
    println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;{}&#34;</span>, fuga(<span style="color:#f92672">&amp;</span>c));
}

<span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">fuga</span>(d: <span style="color:#66d9ef">&amp;</span>String) -&gt; <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">str</span> {
    d.trim()
}
</code></pre></div><p>出力はこんな感じ</p>
<pre><code>hogehoge hoge
hoge
</code></pre><h2 id="まとめ">まとめ</h2>
<p>気になったのは以下の点。そのうち分かるようになってくるのかな。</p>
<ul>
<li>構造体更新記法はどういったときに使うのを想定して作ったんだろう?とか</li>
<li>可変長引数はマクロじゃないとだめ</li>
</ul>
</content:encoded>
    </item>
    
    <item>
      <title>Rust the book - 第4章</title>
      <link>https://blog.johtani.info/blog/2020/03/26/chap4-rust-the-book/</link>
      <pubDate>Thu, 26 Mar 2020 17:12:11 +0900</pubDate>
      
      <guid>https://blog.johtani.info/blog/2020/03/26/chap4-rust-the-book/</guid>
      <description>前回の記事はこちら。自分用のメモなので、読みにくいかもです。 Rust the Bookを読み始めた 第4章 第4章です。たぶん、これがいちばん大事な概念だと思</description>
      <content:encoded><p>前回の記事はこちら。自分用のメモなので、読みにくいかもです。</p>
<ul>
<li><a href="https://blog.johtani.info/blog/2020/03/23/start-reading-rust-the-book/">Rust the Bookを読み始めた</a></li>
</ul>
<h2 id="第4章">第4章</h2>
<p>第4章です。たぶん、これがいちばん大事な概念だと思います、Rustの。
そして、つまみ食いしながらRust書いてましたが、ここがきちんと理解できないまま書いてたってのもあります。。。</p>
<h3 id="所有権とは">所有権とは?</h3>
<ul>
<li><code>drop</code>関数ってのがあって、明示的に呼ぶことも可能。次のような感じで。2つ目の<code>println!</code>はエラーになる。sがもう無いのに借用しようとしてるから。</li>
</ul>
<pre><code>fn main() {
    let mut s = String::from(&quot;hello&quot;);
    s.push_str(&quot;, world!&quot;);
    println!(&quot;{}&quot;, s);
    drop(s);
    println!(&quot;{}&quot;, s);
}
</code></pre><ul>
<li>ムーブ - shallow copyではない。以下の2行目がムーブ。</li>
</ul>
<pre><code>let s1 = String::from(&quot;hello&quot;);
let s2 = s1;

println!(&quot;{}, world!&quot;, s1);
</code></pre><p>スタックとヒープの話が絡んでくる。あんまり意識すること無いよなぁ。
スタック = 固定長のデータを入れる場所。ポインタ、数値など
ヒープ = 可変長のデータが入る場所。可変の文字列とか。</p>
<ul>
<li>クローン - ヒープのデータをコピーすること。</li>
<li>コピー - スタックに収まるデータの場合はクローンが必要なくコピーで事足りる。
<ul>
<li>CopyトレイととDropトレイとは同居できない。</li>
<li>タプルのコピーはややこしそう</li>
</ul>
</li>
<li><a href="https://doc.rust-jp.rs/book/second-edition/ch04-01-what-is-ownership.html#a%E6%89%80%E6%9C%89%E6%A8%A9%E3%81%A8%E9%96%A2%E6%95%B0">所有権と関数</a>でまた、スタックに入れられるような変数と可変のオブジェクトの違いが出てくる。
<ul>
<li><code>takes_ownership(s: String)</code>が参照を受け取れば問題なく、このあとも使える。</li>
<li>戻り値でもムーブが発生</li>
</ul>
</li>
</ul>
<h3 id="参照と借用">参照と借用</h3>
<ul>
<li>借用 - 関数の引数に参照を取ること</li>
<li>可変な参照<code>&amp;mut</code>は1つ(不変な参照も含めて1つ)しか許さない
<ul>
<li>データの競合を防ぐため。</li>
<li>不変な参照を複数用いるのはOK</li>
<li>実際に変更が実行されるタイミングでエラーと判定される場合もある。</li>
</ul>
</li>
</ul>
<pre><code>let mut s = String::from(&quot;hello&quot;);

{
    let r1 = &amp;mut s;

} // r1はここでスコープを抜けるので、問題なく新しい参照を作ることができる

let r2 = &amp;mut s;
</code></pre><ul>
<li>ダングリング参照はテスト書くときとかにやってるかも。。。</li>
</ul>
<pre><code>fn dangle() -&gt; &amp;String { // dangleはStringへの参照を返す

    let s = String::from(&quot;hello&quot;); // sは新しいString

    &amp;s // String sへの参照を返す
} // ここで、sはスコープを抜け、ドロップされる。そのメモリは消される。
  // 危険だ
</code></pre><h3 id="スライス型">スライス型</h3>
<ul>
<li>部分的な参照。開始位置+長さで構成されているっぽい</li>
<li><code>&amp;str</code>の説明がよくわからなかった。</li>
</ul>
<p><a href="https://doc.rust-jp.rs/book/second-edition/ch04-03-slices.html#a%E5%BC%95%E6%95%B0%E3%81%A8%E3%81%97%E3%81%A6%E3%81%AE%E6%96%87%E5%AD%97%E5%88%97%E3%82%B9%E3%83%A9%E3%82%A4%E3%82%B9">引数としての文字列スライス</a>のテクニックは色々と使いまわせそう。</p>
<h2 id="まとめ">まとめ</h2>
<p>所有権、これまで特に難しいと思ってたのは、固定長の変数と、可変長の変数の違いを意識してなかったのが原因っぽい。
まぁ、Vecとかがどうなるのかとか、他にもいくつか気になるところはあるので、もうちょっとやらないといけないなと思いました。</p>
</content:encoded>
    </item>
    
    <item>
      <title>Rust the Bookを読み始めた</title>
      <link>https://blog.johtani.info/blog/2020/03/23/start-reading-rust-the-book/</link>
      <pubDate>Mon, 23 Mar 2020 10:57:22 +0900</pubDate>
      
      <guid>https://blog.johtani.info/blog/2020/03/23/start-reading-rust-the-book/</guid>
      <description>自転車本を読み始めましたが、その前にRust the bookを読んだほうが良いかも?と知り合いと話をしていてなったので、先にRust the bookを読</description>
      <content:encoded><p>自転車本を読み始めましたが、その前にRust the bookを読んだほうが良いかも?と知り合いと話をしていてなったので、先にRust the bookを読み始めてます。
コツコツ読むってのが苦手なので、知り合いと小規模オンライン読書会しながら読むことになりました(基本的になにか書きながら、使い方を調べるので、存在そのものを知らない記述や使用法などがあったりする)。</p>
<ul>
<li><a href="https://doc.rust-jp.rs/book/second-edition/">日本語版Rust the book</a></li>
<li><a href="https://doc.rust-lang.org/book/title-page.html">Rust the book</a></li>
</ul>
<p>基本は日本語版を読んでいます。まずは1章から3章あたり。</p>
<p>気になった点などを。自分用のメモなので、読みやすさとかは考えてないです(あとで自分が死ぬパターン?)。</p>
<h2 id="1章">1章</h2>
<ul>
<li>
<p>rustfmt便利。</p>
<ul>
<li>CLionのRustプラグインでは、保存時にrustfmtするというオプションがある。デフォルトはオフ。&ldquo;Run rustfmt on Save&rdquo;</li>
</ul>
</li>
<li>
<p>cargoの<code>--bin</code>オプション。意識してつけたことなかった=デフォルトだった。</p>
<ul>
<li>ライブラリにするときは<code>--lib</code></li>
</ul>
</li>
</ul>
<h2 id="2章">2章</h2>
<ul>
<li>「変数を値に束縛」という言い回しにまだ慣れない。
<ul>
<li>「代入」という言い方に慣れているから?</li>
<li>ただ、エラーにはassignってあるな。&ldquo;error[E0384]: cannot assign twice to immutable variable <code>x</code>&rdquo;</li>
</ul>
</li>
<li>preludeというのがデフォルトで読み込まれる型が存在する場所。</li>
<li><code>.expect()</code>により、Resultが評価済みになる</li>
<li>マクロがまだ慣れない</li>
<li><code>extern crate rand;</code>が<a href="https://doc.rust-lang.org/book/ch02-00-guessing-game-tutorial.html#generating-a-random-number">最新版だと要らなくなっている</a>。</li>
<li><code>rand::Rng</code>は<code>gen_range</code>のためにuseしている。CLionだとかってにuseを推測して追加してくれた。</li>
<li><code>match</code>はswitch文みたいな感じ。けど、defaultが必ず実行されるって感じではないな。
<ul>
<li>ただし、全て網羅しないと怒られるのが便利。</li>
<li>アームという呼び方が新鮮</li>
<li>単一の式のときは{}が省略できる</li>
<li>ブロック{}のときは、終わりにカンマを入力するとrustfmtが除去する(最後の条件かどうかは関係ない)。</li>
</ul>
</li>
<li>シャドーイングは面白い。
<ul>
<li>よく、<code>hoge_str</code>や<code>hoge_int</code>のような変数を書くので、ありがたい。</li>
<li>ただし、コードを読むときに少し混乱しそう?</li>
</ul>
</li>
<li><code>let ... match</code>で変数への束縛でmatchが使えるのは便利(これまで知らなかったので、変数宣言して条件つけて束縛する処理書いてた)。</li>
</ul>
<h3 id="シャドーイング">シャドーイング?</h3>
<pre><code>fn main() {
    let x = 5;

    let x = x + 1;

    let x = x * 2;

    println!(&quot;The value of x is: {}&quot;, x);
}
</code></pre><p>とか</p>
<pre><code>let spaces = &quot;   &quot;;
let spaces = spaces.len();
</code></pre><p>みたいに、同一変数名を使い回せること。再代入ではない</p>
<h2 id="3章">3章</h2>
<ul>
<li>constは型注釈が必須</li>
<li><code>100_000</code>のような記述が便利(<a href="https://docs.oracle.com/javase/jp/8/docs/technotes/guides/language/underscores-literals.html">Javaもできるって言われてびっくりしたw</a>)</li>
<li>タプルの中身を一部だけ書き換え可能。(mutを指定すれば)
<ul>
<li><code>tup.0 = 20;</code>のような感じで。</li>
</ul>
</li>
<li>配列は固定長でかつ、同一の型のものだけが入る</li>
<li>文末にセミコロンがない場合に四季になるというのはちょっと射にくいので辛いのでは。。。
<ul>
<li>自分は明示的に<code>return</code>を書きたくなる。が、returnだと動かない場合もある。。。</li>
</ul>
</li>
<li><code>let ... if</code>のような記述もできる。</li>
<li><code>(1..4)</code>はRange型</li>
</ul>
<h3 id="おまけ">おまけ</h3>
<p>フィボナッチ数列計算してみろというのがまとめにあったので。こんな感じでいいのかな?</p>
<pre><code>fn calc_fibonacci(n: usize) -&gt; usize {
    if n == 0 {
        return 0;
    } else if n==1 {
        return 1;
    } else {
        return calc_fibonacci(n-1) + calc_fibonacci(n-2);
    }
}
</code></pre><h2 id="その他">その他</h2>
<p>知り合いと読みすすめると、人が不思議に思ったところが、自分が理解が曖昧だったことなどに気づけて便利です。</p>
</content:encoded>
    </item>
    
    <item>
      <title>実践Rust入門の3章を読み終わった</title>
      <link>https://blog.johtani.info/blog/2020/03/02/finish-bicycle-book-chap3/</link>
      <pubDate>Mon, 02 Mar 2020 18:20:13 +0900</pubDate>
      
      <guid>https://blog.johtani.info/blog/2020/03/02/finish-bicycle-book-chap3/</guid>
      <description>これまで 実践Rust入門はじめました 実践Rust入門の3章を読んでるところ 3章終了 3章の終わりまで読み終えた。 いきなり実践的なプログラムで少</description>
      <content:encoded><p>これまで</p>
<ul>
<li><a href="/blog/2020/01/31/start-reading-bicycle-book">実践Rust入門はじめました</a></li>
<li><a href="/blog/2020/02/23/bicycle-book-chap3">実践Rust入門の3章を読んでるところ</a></li>
</ul>
<h2 id="3章終了">3章終了</h2>
<p>3章の終わりまで読み終えた。</p>
<p>いきなり実践的なプログラムで少し面食らっていたが、ステップを追って所有権周りの話まで来たので、
なんとなくRustのいいところが理解できたような気がする。</p>
<p>ただ、最後の<code>split_at_mut</code>が実際には内部でどういう形に変換することによって、コンパイルエラーにならずに、
借用がうまく行っているのかあたりは、まだきちんと理解できていない。</p>
<p>これは、どの言語にも言えるんだけど、リファレンスをうまく読み解きながら、
自分がやりたい処理ができるかどうかを考えるのって結構むずかしいなぁと思う。</p>
<p><code>benchmark.rs</code>はコピペして実行しただけなので、またあとで読み返してみるかな。</p>
<p>ということで、ここから先は、基本を勉強する感じで4章から読みつつ、なんかプログラムをまた書いてみるか。</p>
</content:encoded>
    </item>
    
    <item>
      <title>実践Rust入門の3章を読んでるところ</title>
      <link>https://blog.johtani.info/blog/2020/02/23/bicycle-book-chap3/</link>
      <pubDate>Sun, 23 Feb 2020 16:37:17 +0900</pubDate>
      
      <guid>https://blog.johtani.info/blog/2020/02/23/bicycle-book-chap3/</guid>
      <description>これまでのはこちら。読書メモなので、本と合わせて読んでいただくのが良いです。 実践Rust入門はじめました 3章のクイックツアーを読んでます。 バ</description>
      <content:encoded><p>これまでのはこちら。読書メモなので、本と合わせて読んでいただくのが良いです。</p>
<ul>
<li><a href="/blog/2020/01/31/start-reading-bicycle-book">実践Rust入門はじめました</a></li>
</ul>
<p>3章のクイックツアーを読んでます。
バイトニックソート自体の理解はちょっとおいておいて、読み進めています。
いくつか疑問に思ったことがあったので、またメモを。
まだ、3.5.7の手前ですが。</p>
<h2 id="疑問点">疑問点</h2>
<ol>
<li>
<p>3.4.1のジェネリクス対応のテストケースの部分で、既存のu32用のテストケースの入力のデータ列に<code>Vec&lt;u32&gt;</code>という型注釈をつけるのですが、
追加した文字列の入力データには注釈をここではつけないのはなんでなんだろう?<em>ちなみに、なくても動いた。バージョンの違いとかあるのかしら?</em></p>
</li>
<li>
<p>3.4.6のmatch文</p>
<ul>
<li><code>match</code>文の引数?が<code>*order</code>になっていたが、<code>order</code>でも実行できた。引数にくるのが参照だから<code>*</code>が付いてるんだとも運だが、なくても動くのはコンパイラがよしなに解釈してくれてるからかな?</li>
</ul>
</li>
</ol>
<h2 id="便利なツール">便利なツール</h2>
<p>Rust標準のツールの説明がいくつか3章で紹介されてて便利だったのでメモ。</p>
<ol>
<li>rustfmt</li>
</ol>
<p>フォーマッター。デフォルトでフォーマット機能が付いてるの便利ですね。言語として決まってると、プロジェクトごとに悩まなくていいってのがありますし。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-zsh" data-lang="zsh">rustfmt ファイル名
</code></pre></div><p>という形で使えるみたい。
プロジェクトごとだと<code>cargo fmt</code>のほうが楽そうかな。</p>
<ol start="2">
<li>標準ライブラリAPIドキュメントをブラウザで閲覧</li>
</ol>
<pre><code>rustup doc --std
</code></pre><p>これでデフォルトブラウザでRustの公式ドキュメントが開きます。
しかもローカルファイルだからサクサク。検索バーもついてて便利です。</p>
<ol start="3">
<li>エラーのドキュメントを閲覧</li>
</ol>
<pre><code>rustc --explain 308
</code></pre><p>コンパイル時にエラーが出たときに、<code>error[E0308]</code>のようにコンソールに出てきます。
ヒントも出てくるのですが、詳細が上記のコマンドで読めるみたいです。</p>
</content:encoded>
    </item>
    
    <item>
      <title>実践Rust入門はじめました</title>
      <link>https://blog.johtani.info/blog/2020/01/31/start-reading-bicycle-book/</link>
      <pubDate>Fri, 31 Jan 2020 21:58:12 +0900</pubDate>
      
      <guid>https://blog.johtani.info/blog/2020/01/31/start-reading-bicycle-book/</guid>
      <description>実践Rust入門という本を買っていた(去年の7月だ。。。)のですが、積んであったので、時間を作って読み始めようかと。 実践Rust入門[言語仕</description>
      <content:encoded><p>実践Rust入門という本を買っていた(去年の7月だ。。。)のですが、積んであったので、時間を作って読み始めようかと。</p>


<div class="amazon-shortcode-box">
  <div class="amazon-shortcode-image">
    <a style="display: inline-block;" target="_blank" href="https://www.amazon.co.jp/gp/product/4297105594/?tag=johtani-22">
      <img border="0" src="//ws-fe.amazon-adsystem.com/widgets/q?_encoding=UTF8&MarketPlace=JP&ASIN=4297105594&ServiceVersion=20070822&ID=AsinImage&WS=1&Format=_SL160_&tag=johtani-22" >
    </a>
  </div>
  <div class="amazon-shortcode-info">
    <p class="amazon-shortcode-title">
      <a target="_blank" href="https://www.amazon.co.jp/gp/product/4297105594/?tag=johtani-22">
      実践Rust入門[言語仕様から開発手法まで] | κeen, 河野 達也, 小松 礼人 |本 | 通販 | Amazon
      </a>
    </p>
  </div>
</div>
<h2 id="経緯">経緯</h2>
<p>もともとは、<a href="/blog/2018/02/14/start-nlp100-with-rust/#undefined">言語処理100本ノックはじめました(Rust)</a>という感じで、触っていたのですが、場当たり的にやってても時間を持っていかれるだけだなということに気づいたのが最初です。</p>
<p>今年の目標は、覚えられなので、ちょっとずつでもアウトプットしていこうってのもあり、
読書記録をつけつつ、読んでいこうかなぁと。</p>
<h2 id="どこまで読んだ">どこまで読んだ?</h2>
<p>2章の<code>2-2-5</code>までです。
前回、Rustの環境はセットアップしていたのですが、新PCに切り替わったので、<code>rustup</code>からはじめました。</p>
<h3 id="rustup">rustup</h3>
<p><code>rustup</code>ではデフォルト設定のままではなく、<code>PATH</code>変数の書き換えだけはしない形でインストールを行いました。</p>
<p><code>PATH</code>変数は<code>.zshrc</code>ファイルで変更したかったためです(<code>rustup</code>コマンドに変更して貰う場合は<code>.profile</code>などのファイルが変更されそうだったため)。</p>
<p>インストールが終わったあとに<code>.zshrc</code>に以下の行を追加しました。</p>
<pre><code>### For Rust env
source $HOME/.cargo/env
</code></pre><h2 id="疑問点">疑問点</h2>
<p>ここまで読んだ疑問点です。</p>
<ol>
<li><code>cargo new hello</code>したあとに<code>main.rs</code>に以下の<code>main()</code>関数が出来上がっている!?</li>
</ol>
<pre><code>fn main() {
    println!(&quot;Hello, world!&quot;);
}
</code></pre><p>驚きましたが、<code>cargo new hoge</code>ってやっても、おなじ<code>main.rs</code>ができてました。デフォルトで出来上がるんですね。どんな超能力!?と思ってしまいましたw</p>
<ol start="2">
<li><code>cargo new hello</code>して出来上がった<code>Cargo.toml</code>に著者名が入力されていた。</li>
</ol>
<pre><code>authors = [&quot;Jun Ohtani &lt;メアド&gt;&quot;]
</code></pre><p>なんで?と思いました。まだ解明してないです。
本を読んでいけばわかるかな?</p>
<ul>
<li>予想:gitの設定(<code>~/.gitconfig</code>)に氏名とメアドが設定されているので、これを利用しているのかな?</li>
</ul>
</content:encoded>
    </item>
    
    <item>
      <title>第1章の05から06までやってみた（言語処理100本ノック）</title>
      <link>https://blog.johtani.info/blog/2018/03/20/nlp100-ch01-05to06/</link>
      <pubDate>Tue, 20 Mar 2018 21:34:45 +0900</pubDate>
      
      <guid>https://blog.johtani.info/blog/2018/03/20/nlp100-ch01-05to06/</guid>
      <description>Rustで言語処理100本ノックの続きで、05と06です。 05. n-gram 問題はこちら。 みんな大好きn-gramです。単語と文字があるので、それぞれ別関</description>
      <content:encoded><p>Rustで言語処理100本ノックの続きで、05と06です。</p>
<!-- more -->
<h3 id="05-n-gram">05. n-gram</h3>
<p>問題は<a href="http://www.cl.ecei.tohoku.ac.jp/nlp100/#sec05">こちら</a>。</p>
<p>みんな大好きn-gramです。単語と文字があるので、それぞれ別関数として実装しました。問題はbi-gramと<code>n=2</code>だったのですが、一応、<code>n</code>を引数に取る形にして実装しました。</p>
<p>まずは、単語です。</p>
<script src="http://gist-it.appspot.com/https://github.com/johtani/nlp100-rust/blob/5439f96e8521bffe34689c23aa076eb3a2fe817b/src/chapter01/answer.rs?slice=128:139"></script>
<p>前に実装した時は、自分で頑張って、先頭から数えたりしてたんですが、Rustには<a href="https://rust-lang-ja.github.io/the-rust-programming-language-ja/1.6/std/primitive.slice.html#method.windows">windows(n)</a>という便利なメソッドがsliceにあり、これを利用したらこんな簡単になりました。
sliceは特定のシーケンス（配列）に対してある特定のサイズのViewを作ってくれます（説明あってる？）。
ということで、文字列から、単語の配列（スペース区切りで単語にしている）を作り出して、<code>windows(n)</code>メソッドを通すと、
<code>n</code>で指定した数字の個数だけの単語の配列を先頭から、1単語ずつずらして作ってくれます。まさに、n-gram!
戻り値は配列の配列です。
1点だけ疑問点があるのは、「空白で区切ったものが単語」という考え方で良いかどうか？という点です。特に問題文にはそれが明示されていなかったので、このような前提を置いてあります。</p>
<p><code>invalid_n(text, n)</code>は<code>n</code>の値や入力された文字列をチェックする関数です。入力チェックですね。<code>n</code>が1よりも小さい場合、入力文字列が空文字の場合は、warningでメッセージを出して、空の配列を返す仕組みになっています。</p>
<script src="http://gist-it.appspot.com/https://github.com/johtani/nlp100-rust/blob/5439f96e8521bffe34689c23aa076eb3a2fe817b/src/chapter01/answer.rs?slice=115:126"></script>
<p>次は、文字です。</p>
<script src="http://gist-it.appspot.com/https://github.com/johtani/nlp100-rust/blob/5439f96e8521bffe34689c23aa076eb3a2fe817b/src/chapter01/answer.rs?slice=128:139"></script>
<p>単語とほぼ一緒ですが、入力文字列を、1文字ずつの配列にしているところが異なります。
また、<code>windows</code>メソッドで取り出された、1文字ずつの<code>n</code>個の配列を文字列に修正してから、結果の配列に入れています。
ここでも疑問は空白をどう扱うか？になります。
現時点では、空白も1文字とカウントして扱うことにしてあります。
どっちがいいのかなぁ？</p>
<h3 id="06-集合">06. 集合</h3>
<p>問題は<a href="http://www.cl.ecei.tohoku.ac.jp/nlp100/#sec06">こちら</a>。</p>
<p>まずは、文字n-gramで出てきた文字列をSetに入れる関数から。</p>
<script src="http://gist-it.appspot.com/https://github.com/johtani/nlp100-rust/blob/5439f96e8521bffe34689c23aa076eb3a2fe817b/src/chapter01/answer.rs?slice=159:174"></script>
<p>n-gramの問題で実装した文字n-gramの関数の戻り値を配列ではなく、BTreeSetに変えたものになります。比較などがしやすいように？と思い、BTreeSetを利用していますが、実装としてはHashSetでも問題ないかと。
この関数の集合（Set）を元に、和集合、積集合、差集合を求める関数を実装しました。</p>
<script src="http://gist-it.appspot.com/https://github.com/johtani/nlp100-rust/blob/5439f96e8521bffe34689c23aa076eb3a2fe817b/src/chapter01/answer.rs?slice=176:187"></script>
<p>Setのメソッドとして、それぞれ、<code>union</code>＝和集合、<code>intersection</code>＝積集合、<code>difference</code>＝差集合のメソッドが用意されているので、特に困ることはなかったです。
差集合については、1-2と2-1で結果が異なるはずなので、それぞれをテストケース、main.rsで出力するようにしてあります。</p>
<h3 id="所感">所感</h3>
<p>今回は、Rustがすでに実装してくれているメソッドがあったので楽ができました。
やりたいことに相当するメソッドがあるかどうかを調べるためにリファレンスを探さないといけないのがちょっと苦労しましたが。。。
ということで、今日はこの辺りまで。</p>
</content:encoded>
    </item>
    
    <item>
      <title>第1章の03から04までやってみた（言語処理100本ノック）</title>
      <link>https://blog.johtani.info/blog/2018/02/19/nlp100-ch01-03to04/</link>
      <pubDate>Mon, 19 Feb 2018 18:34:08 +0900</pubDate>
      
      <guid>https://blog.johtani.info/blog/2018/02/19/nlp100-ch01-03to04/</guid>
      <description>Rustで言語処理100本ノックの続きで、03と04です。 03. 円周率 問題はこちら。 入力文字列を.split_whitespace()で分割して</description>
      <content:encoded><p>Rustで言語処理100本ノックの続きで、03と04です。</p>
<!-- more -->
<h3 id="03-円周率">03. 円周率</h3>
<p>問題は<a href="http://www.cl.ecei.tohoku.ac.jp/nlp100/#sec03">こちら</a>。</p>
<script src="http://gist-it.appspot.com/http://github.com/johtani/nlp100-rust/blob/8ca508cc16fbc7a11ac04bbc43687dfec4f25483/src/chapter01/answer/mod.rs?slice=60:71"></script>
<p>入力文字列を<code>.split_whitespace()</code>で分割しておいて、単語ごとのベクタを作り出し、そこに対して文字を数えました。「アルファベットの」という注意書きがあるので&rdquo;,&ldquo;や&rdquo;.&ldquo;は含めずに数えるのかなということで、
charの<code>.is_alphabetic()</code>で<code>A-z</code>までの判定をしつつ、文字のベクタを作ってから、そのベクタの長さを詰め込むという感じでやりました。</p>
<p>これ、ひょっとして、collectでベクタにしなくても、i32とかの変数でカウントするとベクタ作らなくてもいいなじゃにか？というのに書きながら気づいた。。。
必要じゃないオブジェクトを作ってるよなぁ。</p>
<p><code>.filter().map</code>とかかな？この辺りの操作がイマイチ苦手。Javaでもまだ馴染めてないところなんだよなぁ。頭固すぎ。</p>
<h3 id="04-元素記号">04. 元素記号</h3>
<p>問題は<a href="http://www.cl.ecei.tohoku.ac.jp/nlp100/#sec04">こちら</a>。</p>
<script src="http://gist-it.appspot.com/http://github.com/johtani/nlp100-rust/blob/8ca508cc16fbc7a11ac04bbc43687dfec4f25483/src/chapter01/answer/mod.rs?slice=73:112"></script>
<p>大作ですね。何だろう、大作。。。
最終的に連想配列（辞書型もしくはマップ型）」ということだったので、BTreeMapに詰め込んでます。
HashMapでもいいんですが、文字列で出力した時にキーが並んで見やすいからという理由で、BTreeMap使いました。それ以上の理由はないです。普通にやるなら、HashMapかな？</p>
<p>入力として、1文字だけの出力をする場所（インデックス番号）の配列を受け取ってます。1点だけ、チェックしていない、けど入力値の想定をしていて、<code>idx_one_symbols</code>がソートされていて、小さいものから順番に出てくるものとしてます。関数作って、チェックすべきかな？</p>
<p>で、指定された場所の最後のものが入力文字列よりも大きいかどうかというチェックもしています。（あー、テストケース書いてないな）この辺りのせいでちょっと長めになってます。</p>
<p>単語の配列を作るのは03の時と同じやり方です。
回しかたがちょっと違って、<code>.iter().enumerate()</code>で回して、添字と値をタプル？でとりだしてます。添字を見ながら1文字取り出すのか、2文字取り出すのかの判断が必要だからです。あとは一緒ですね。1文字取り出すときは、<code>.first()</code>を使って見ました。
実は、2文字取り出す時と、1文字の時と同じロジック使った方が共通化できて、短くなった？？？</p>
<p>ということで、こんな感じでした。いつものようにツッコミお待ちしてます。</p>
<h3 id="所感">所感</h3>
<p>問題それぞれについてではなく、
やってて思ったのですが、問題に対して想定される結果が記載されていると嬉しいなと思いました。
ロジックについては、各自実装者に寄ったり、言語によって違いが出たりするし、議論するベースになっていいかなと思うんですが、
問題で想定されている結果（出力）があると、自分の実装にケアが足りないところがないのか？とか、ケアしなくていい点とかがわかるのかもなぁと。
ユニットテスト相当のものがあると楽かなぁと。</p>
<p>このケースどうするんだろ？みたいなのが、ところどころコメントに残ったりしてます。
出題の意図としては、その部分も議論の対象ということなのかな？</p>
</content:encoded>
    </item>
    
    <item>
      <title>第1章の00から02までやってみた（言語処理100本ノック）</title>
      <link>https://blog.johtani.info/blog/2018/02/15/nlp100-ch01-00to02/</link>
      <pubDate>Thu, 15 Feb 2018 21:59:01 +0900</pubDate>
      
      <guid>https://blog.johtani.info/blog/2018/02/15/nlp100-ch01-00to02/</guid>
      <description>「鉄は熱いうちに打て」ということで、言語処理100本ノックの第1章の00から02を実装してみました。 さて、これが効率がいいのかどうかはさてお</description>
      <content:encoded><p>「鉄は熱いうちに打て」ということで、言語処理100本ノックの第1章の00から02を実装してみました。</p>
<!-- more -->
<p>さて、これが効率がいいのかどうかはさておき。</p>
<h3 id="00-文字列の逆順">00. 文字列の逆順</h3>
<p>問題は<a href="http://www.cl.ecei.tohoku.ac.jp/nlp100/#sec00">こちら</a>。</p>
<p>最初、<a href="https://github.com/johtani/nlp100-rust/blob/48567d107511541d0401af4ef58c6abb98a6083b/src/chapter01/answer.rs">Vecのreverse()で逆順にして0からlen()まで回してた</a>んですが、pop()がいい感じに後ろから取れることがわかったんで、切り替えました。
シンプルかな？</p>
<script src="http://gist-it.appspot.com/http://github.com/johtani/nlp100-rust/blob/ccbdf272adbb5aa738dc73e78e3667e4300a49c1/src/chapter01/answer.rs?slice=2:12"></script>
<h3 id="01-パタトクカシーー">01. 「パタトクカシーー」</h3>
<p>問題は<a href="http://www.cl.ecei.tohoku.ac.jp/nlp100/#sec01">こちら</a>。</p>
<script src="http://gist-it.appspot.com/http://github.com/johtani/nlp100-rust/blob/ccbdf272adbb5aa738dc73e78e3667e4300a49c1/src/chapter01/answer.rs?slice=14:24"></script>
<p>1文字ずつ取り出して、インデックスの番号が2で割ってあまりが0なら文字列に追加していくってのでやってみました。
（ブログ書いてるところで、<code>i in 0..char_array.len()</code>じゃなくて、<code>(i, x) in char_array.iter().enumerate()</code>に切り替えました。）
matchとか使って綺麗に書けたりするのかなぁ？</p>
<h3 id="02-パトカータクシーパタトクカシーー">02. 「パトカー」＋「タクシー」＝「パタトクカシーー」</h3>
<p>問題は<a href="http://www.cl.ecei.tohoku.ac.jp/nlp100/#sec02">こちら</a>。</p>
<script src="http://gist-it.appspot.com/http://github.com/johtani/nlp100-rust/blob/ccbdf272adbb5aa738dc73e78e3667e4300a49c1/src/chapter01/answer.rs?slice=26:56"></script>
<p>だいぶ思考錯誤してる感じがソースに現れてます。
とりあえず、両方の文字列をcharsの配列にして個々のイテレータを回しながら、next()の戻り値があれば追加していく感じにして、
終了条件が両方Noneを通ったらにしてるけど、、、
なんか、もっと綺麗にできないのかなぁ。。。
next()のタプル返す関数作って、とかでなんかできたりするかなぁ？</p>
<h3 id="gist-it">gist-it</h3>
<p>関係ないですが、GitHubのコードを貼り付けるのに便利なサービスがあるみたいです。</p>
<p><a href="http://gist-it.appspot.com">http://gist-it.appspot.com</a></p>
<p>これほんと便利だな。行数指定もできるし。
説明するのが簡単だ。</p>
<p>とりあえず、今日はこの辺まで。なんか、いい知恵あれば教えてください！</p>
</content:encoded>
    </item>
    
    <item>
      <title>言語処理100本ノックはじめました(Rust)</title>
      <link>https://blog.johtani.info/blog/2018/02/14/start-nlp100-with-rust/</link>
      <pubDate>Wed, 14 Feb 2018 19:52:31 +0900</pubDate>
      
      <guid>https://blog.johtani.info/blog/2018/02/14/start-nlp100-with-rust/</guid>
      <description>ども。新しいもの始めないと頭が退化する。。。ということで、こちら（ happy new year and new language - katsyoshiのめもみたいなもの）のブログに触発されて、</description>
      <content:encoded><p>ども。新しいもの始めないと頭が退化する。。。ということで、こちら（
<a href="http://blog.katsyoshi.org/blog/2018/01/16/happy-new-year-and-new-language/">happy new year and new language - katsyoshiのめもみたいなもの</a>）のブログに触発されて、言語処理100本ノックをはじめてみました。</p>
<!-- more -->
<p><a href="http://www.cl.ecei.tohoku.ac.jp/nlp100/#ch1">言語処理100本ノック</a>とは、自然言語処理になるのかな、東北大学の研究室の先生が公開している言語処理に関する実践的な課題をベースにプログラミングなどのスキルを学んでいくための問題集です。
元々はPythonを対象とされているようですが、Rustでやってみようかと。
まぁ、先ほどあげたブログの二番煎じです。。。
ちなみに、インスパイアされた元のブログの方はRust book 2nd editionを読み終えたらしいですが、私はかじった程度です（ダメかも？）。</p>
<p>NLPもRustもかじった程度なので、苦戦しそうですが、ちょっとずつやっていこうかなと。
ということで、準備運動の第1章から始めようかと。
GitHubにちょっとずつあげていく予定です。
<a href="https://github.com/johtani/nlp100-rust">https://github.com/johtani/nlp100-rust</a></p>
<p>まぁ、まずは宣言のブログを書いてみただけです。
続いてなかったら、叱咤激励してください。叱咤だけかも？</p>
</content:encoded>
    </item>
    
  </channel>
</rss>
