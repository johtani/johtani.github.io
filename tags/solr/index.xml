<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>solr on @johtaniの日記 3rd</title>
    <link>https://blog.johtani.info/tags/solr/</link>
    <description>Recent content in solr on @johtaniの日記 3rd</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja</language>
    <lastBuildDate>Wed, 29 Jan 2014 18:46:00 +0900</lastBuildDate><atom:link href="https://blog.johtani.info/tags/solr/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>第13回Solr勉強会を開催しました</title>
      <link>https://blog.johtani.info/blog/2014/01/29/hold-to-japan-solr-meetup/</link>
      <pubDate>Wed, 29 Jan 2014 18:46:00 +0900</pubDate>
      
      <guid>https://blog.johtani.info/blog/2014/01/29/hold-to-japan-solr-meetup/</guid>
      <description>改訂新版Solr入門出版記念ということで、第13回Solr勉強会 #SolrJP 新Solr本出版記念を開催しました。 出版記念なので、技術評論社様より、プレ</description>
      <content:encoded><p>改訂新版Solr入門出版記念ということで、<a href="http://solr.doorkeeper.jp/events/7260">第13回Solr勉強会 #SolrJP 新Solr本出版記念</a>を開催しました。</p>
<p>出版記念なので、技術評論社様より、プレゼント用にSolr本を用意していただきました！ありがとうございます！！
書籍をゲット出来た方は、ツイートしたりブログ書いたり書評書いたりして、宣伝してください！！！</p>
<p>今回は、私は手を抜いて他の人に喋ってもらいました！</p>
<!-- more -->
<p>今回は、著者陣（関口さんは特別ゲスト）でスピーカーを固めてみました。
以下は、いつもの簡単なメモです。
スライドが集まったらまた更新していきます。</p>
<h2 id="1-はじめての検索エンジンsolr-株式会社nttデータccs鈴木-教嗣さん">1. 「はじめての検索エンジン＆Solr」 株式会社NTTデータCCS　鈴木 教嗣さん</h2>
<p>スライド：<a href="http://www.slideshare.net/suzu2525/solr-13">はじめての検索エンジン＆Solr 第13回Solr勉強会</a></p>
<p>鈴木さんの発表初めて聞きましたｗ。
趣味が多いなぁ。
ちょこちょこと、宣伝を入れてるのが流石ですｗ</p>
<ul>
<li>入門らしい概要</li>
<li>クエリの概要とかも。</li>
<li>スコア計算とか</li>
<li>導入するとうれしいところとか</li>
<li>Solr盛り上げましょう！</li>
</ul>
<h2 id="2-solr-searchcomponent-再訪-株式会社ロンウイット関口-宏司さん">2. 「Solr SearchComponent 再訪」 株式会社ロンウイット　関口 宏司さん</h2>
<p>スライド：公開待ち</p>
<ul>
<li>ベン図で検索の評価指標の説明</li>
<li>理論的なお話</li>
<li>Solrのサーチコンポーネントを使って何ができるか。ベン図で。</li>
<li>サーチコンポーネント以外にも
<ul>
<li>NGramTokenizerも</li>
<li>SynonymFilterも</li>
<li>パーソナライズ検索</li>
</ul>
</li>
</ul>
<p>いきなり話をふられたのでちょっとびっくりしましたｗ</p>
<h2 id="3-自動補完autocompleteともしかしてdid-you-mean-株式会社-ロンウイット大須賀-稔さん">3. 「自動補完(Autocomplete)ともしかして？(Did You Mean?)」 株式会社 ロンウイット　大須賀 稔さん</h2>
<p>スライド：<a href="http://www.slideshare.net/mosuka/solr-autocomplete-and-did-you-mean">Solr AutoComplete and Did You Mean?</a><br>
デモ：https://github.com/mosuka/solr-suggester-demo-ui</p>
<ul>
<li>職歴が相変わらずおもしろい</li>
<li>編集距離のお話</li>
<li>素晴らしいCM！</li>
</ul>
<p>候補のランキングを変更できる？
SpellcheckComponentのパラメータで指定できるものなら楽ですが。。。</p>
<h2 id="4-lucene-revolution-2013-dublin振り返り-楽天株式会社平賀-一昭さん">4. 「Lucene Revolution 2013 Dublin振り返り」 楽天株式会社　平賀 一昭さん</h2>
<p>スライド：公開待ち</p>
<ul>
<li>ダブリンどこ？（間違ってベルリンって言っちゃいましたｗ）</li>
<li>スタジアムで開催。グランドにも入れるのかなぁ？</li>
<li>まずはTwitter
<ul>
<li>Luceneの改良版</li>
<li>ちょっと特殊。１４０文字とか</li>
</ul>
</li>
<li>青いRさんのライバル。Careerbuilder
<ul>
<li>元FASTユーザ</li>
<li>企業向けに検索キーワードとかの解析画面を用意</li>
<li>検索精度の改良の話とか</li>
<li>転職で引っ越す意思があるかとか。</li>
</ul>
</li>
<li>最後はLinkedIn
<ul>
<li>Luceneのユーザ</li>
</ul>
</li>
</ul>
<h3 id="まとめ">まとめ</h3>
<p>ということで、スピーカーの方々のスライドにもありましたが、
<a href="http://www.amazon.co.jp/dp/4774161632?tag=johtani-22&amp;camp=243&amp;creative=1615&amp;linkCode=as1&amp;creativeASIN=4774161632&amp;adid=11S5FJFPHF9685VRE24M&amp;&amp;ref-refURL=http%3A%2F%2Fblog.johtani.info%2F">改訂新版Apache Solr入門</a>は良い本なので、購入していただけると嬉しいです。</p>
<p>感想、コメントなど、いつでもお待ちしています！</p>
</content:encoded>
    </item>
    
    <item>
      <title>lucene-gosen 4.6.1のリリースに関する注意点</title>
      <link>https://blog.johtani.info/blog/2014/01/28/release-lucene-gosen-4-dot-6-1/</link>
      <pubDate>Tue, 28 Jan 2014 12:34:00 +0900</pubDate>
      
      <guid>https://blog.johtani.info/blog/2014/01/28/release-lucene-gosen-4-dot-6-1/</guid>
      <description>Lucene/Solr 4.6.1がリリースされそう(バイナリ配布待ち)lucene-gosenの4.6.1対応版をリリースしました。 ライブラリのインタフェースな</description>
      <content:encoded><p>Lucene/Solr 4.6.1がリリースされそう(バイナリ配布待ち)<a href="https://code.google.com/p/lucene-gosen/">lucene-gosen</a>の4.6.1対応版をリリースしました。</p>
<p>ライブラリのインタフェースなどは特に変更はないのですが、ライブラリのダウンロード先が変更になっているため、注意喚起です。</p>
<!-- more -->
<p>Google Project Hostingの仕様変更により、Downloadsに新規ファイルがアップロードできなくなっています。（2014年から）</p>
<p>このため、プロジェクトの選択肢としては以下の3点となっています。</p>
<ol>
<li>Google Driveにファイルをアップロードしてダウンロードしてもらう</li>
<li>他のソースコード管理サイトなどを利用する。</li>
<li>他のダウンロードサイトを利用する</li>
</ol>
<p>1.と3.は場所が違うだけで、方法は一緒です。
今回は、暫定的に1.を利用してダウンロードするように対応しました。</p>
<p>ダウンロード先はプロジェクトのページにリンクが有りますが、わかりにくいのでキャプチャを撮ってみました。</p>

<link rel="stylesheet" href="/css/hugo-easy-gallery.css" />
<div class="box" >
  <figure  itemprop="associatedMedia" itemscope itemtype="http://schema.org/ImageObject">
    <div class="img">
      <img itemprop="thumbnail" src="/images/entries/20140128/project_home.jpg" />
    </div>
    <a href="/images/entries/20140128/project_home.jpg" itemprop="contentUrl"></a>
      <figcaption align="center"><h4>ダウンロード先</h4>
      </figcaption>
  </figure>
</div>

<p>これまでの<code>Featured - Downloads</code>とは異なり、<code>Links - External links</code>の下に
<a href="https://drive.google.com/folderview?id=0B0xz3tf1TTPnYTlSNExkTzBhWnc&amp;usp=sharing">Downloads lucene-gosen 4.6.1</a>というリンクを用意してあります。</p>
<p>フォルダとなっており、各種jarファイルがリストされていますので、こちらからダウンロードをお願いします。
今後は、この下にダウンロードリンクを追加していく予定です。</p>
<p>ただし、2.で述べたように「別のソースコード管理サイト」も検討中です。</p>
</content:encoded>
    </item>
    
    <item>
      <title>Solrへのプラグインの配置方法について</title>
      <link>https://blog.johtani.info/blog/2013/12/19/add-jar-file-to-solr/</link>
      <pubDate>Thu, 19 Dec 2013 19:09:00 +0900</pubDate>
      
      <guid>https://blog.johtani.info/blog/2013/12/19/add-jar-file-to-solr/</guid>
      <description>Solr本が出てから、質問を受けてブログ書くと言いながら書いてなかったことを思い出しました。。。 プラグインの配置方法についてこんな質問を受け</description>
      <content:encoded><p>Solr本が出てから、質問を受けてブログ書くと言いながら書いてなかったことを思い出しました。。。</p>
<p>プラグインの配置方法についてこんな質問を受けてたので、それっぽいエントリを書いておきます。（想像と違ってたらツッコミ入れてください）</p>
<!-- more -->
<blockquote class="twitter-tweet" lang="ja"><p><a href="https://twitter.com/johtani">@johtani</a> 追加でプラグインの配置方法とかあると便利かなと思いました</p>&mdash; Tsubosaka (@tsubosaka) <a href="https://twitter.com/tsubosaka/statuses/407395766471110656">2013, 12月 2</a></blockquote>
<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>
<p>改定前のSolr本では、日本語の形態素解析器をjarファイルとして追加する方法が書かれていました。
ただ、改定後のSolr本では、KuromojiがLuceneで実装されているためサンプルとしてjarファイルを追加するような方法の記載が明確にはありません。</p>
<p>19ページのcollection1の説明ですこしだけ、libディレクトリについて触れています。</p>
<p>独自のTokenizer（lucene-gosenなど）はjar形式でSolrに追加し、schema.xmlなどに利用するFactoryを指定してから利用します。</p>
<p>このとき、追加のjarファイルを配置する先がlibディレクトリです。</p>
<p>libディレクトリは2つの種類のスコープのディレクトリが存在します。</p>
<ul>
<li>Solr全体で利用可能なlibディレクトリ</li>
<li>コア単位で利用可能なlibディレクトリ</li>
</ul>
<h2 id="solr全体で利用するlibディレクトリ">Solr全体で利用するlibディレクトリ</h2>
<p>これは、起動しているSolrにある全てのコアで利用するようなjarファイルを配置するディレクトリになります。
場所は<code>$SOLR_HOME/lib</code>です。ここにjarファイルを配置することで、この<code>$SOLR_HOME</code>を利用するすべてのコアで同じjarファイルを利用することができるようになります。</p>
<p>ですので、例えば、lucene-gosenはすべてのコアで利用するという場合にはここに配置すれば、1つのjarファイルを配置するだけで済むことになります。</p>
<h2 id="コア単位で利用するlibディレクトリ">コア単位で利用するlibディレクトリ</h2>
<p>これは、コアごとにlibディレクトリを用意する場合です。
19ページにも記載されていますが、<code>$SOLR_HOME/コアディレクトリ名/lib</code>となります。</p>
<p>特定のコアのみで利用するライブラリについてはこちらに配置する形になります。
他のコアで利用してほしくないjarファイルなどを配置するのに利用すればよいかと。</p>
<p>簡単ですが、補足記事でした。
UIMAやlangidの利用方法などもあるとうれしですかね？
そのうち気が向けば書くかもしれません。（他の人に書いてもらうのもありかも。）</p>
</content:encoded>
    </item>
    
    <item>
      <title>改訂版Solr入門のPDF版も発売</title>
      <link>https://blog.johtani.info/blog/2013/12/09/release-introduction-solr-ebook/</link>
      <pubDate>Mon, 09 Dec 2013 11:08:00 +0900</pubDate>
      
      <guid>https://blog.johtani.info/blog/2013/12/09/release-introduction-solr-ebook/</guid>
      <description>少し遅くなってしまいましたが、12/05に電子書籍も発売されました。 技術評論社の電子書籍サイトから購入可能です。 書籍のページへのリンク PDF</description>
      <content:encoded><p>少し遅くなってしまいましたが、12/05に電子書籍も発売されました。</p>
<!-- more -->
<p>技術評論社の電子書籍サイトから購入可能です。</p>
<ul>
<li><a href="https://gihyo.jp/dp/ebook/2013/978-4-7741-6240-9">書籍のページへのリンク</a></li>
</ul>
<p>PDF版となっております。
購入の際は、技術評論社の電子書籍サイトに会員登録後購入可能となります。</p>
<p>個人的には電子書籍が便利なので、こちらを普段活用しようと思っています。</p>
<p>もちろん、紙の書籍も発売中です！購入の際は右の書影をクリックしていただければと！</p>
</content:encoded>
    </item>
    
    <item>
      <title>改訂版Solr入門を執筆しました</title>
      <link>https://blog.johtani.info/blog/2013/11/26/introduction-to-solr-new-edition/</link>
      <pubDate>Tue, 26 Nov 2013 12:27:00 +0900</pubDate>
      
      <guid>https://blog.johtani.info/blog/2013/11/26/introduction-to-solr-new-edition/</guid>
      <description>勉強会で宣伝もしましたが、改めて。 Solr入門の改訂版を執筆しました。 考えてみれば、もう3年も前なんですね、Solr入門は。 Solr勉強会な</description>
      <content:encoded><p>勉強会で宣伝もしましたが、改めて。</p>
<p>Solr入門の改訂版を執筆しました。
考えてみれば、もう3年も前なんですね、<a href="http://gihyo.jp/book/2010/978-4-7741-4175-6">Solr入門</a>は。
Solr勉強会などでも何度も新しいのは出ないのですか？と聞かれていましたが、やっと出ました。（お待たせしました。）</p>
<p>時が立つのは早いものです。前回のSolr入門はバージョン1.4にて執筆していましたが、今回は4.4をベースにし、4.5.1への対応を行っています。</p>

<link rel="stylesheet" href="/css/hugo-easy-gallery.css" />
<div class="box" >
  <figure  itemprop="associatedMedia" itemscope itemtype="http://schema.org/ImageObject">
    <div class="img">
      <img itemprop="thumbnail" src="/images/entries/20131126/intro_solr.jpg" />
    </div>
    <a href="/images/entries/20131126/intro_solr.jpg" itemprop="contentUrl"></a>
  </figure>
</div>

<p>月曜日には手元に見本が届き、今週金曜日に発売予定です！</p>
<!-- more -->
<p>SolrCloud、SoftCommit、Spatial、Joinなど、多彩な機能についても記載してあります。
また、<a href="http://manifoldcf.apache.org/ja_JP/index.html">ManifoldCF</a>というSolrにデータを登録するのに
利用できるコネクタフレームワークについても書いてあります。</p>
<p>より多彩になったSolrの機能を活用するための一助となれればと思います。
（電子版も出る予定です。詳細についてはもう少々お待ちください）</p>
<p>また、出版を記念して少し時期が先になりますが、Solr勉強会を開催しようと思います。</p>
<ul>
<li>日時：2014年01月29日</li>
<li><a href="http://solr.doorkeeper.jp/events/7260">第13回Solr勉強会 #SolrJP 新Solr本出版記念</a></li>
</ul>
<p>今回はせっかくのSolr入門の書籍の出版記念ということで入門的な話をしてもらう予定です。
Solr初心者の方、Solrに興味のある方などに来ていただきたいと思っています。
（プレゼントも用意できるかも！？）</p>
<p>ということで、「改訂版Apache Solr入門」をよろしくお願いします。
（もちろん、購入は下のリンクからですよね！）</p>
<iframe src="http://rcm-fe.amazon-adsystem.com/e/cm?t=johtani-22&o=9&p=8&l=as1&asins=4774161632&nou=1&ref=tf_til&fc1=000000&IS2=1&lt1=_blank&m=amazon&lc1=0000FF&bc1=000000&bg1=FFFFFF&f=ifr" style="width:120px;height:240px;" scrolling="no" marginwidth="0" marginheight="0" frameborder="0"></iframe>
</content:encoded>
    </item>
    
    <item>
      <title>第12回Solr勉強会を主催しました。#SolrJP</title>
      <link>https://blog.johtani.info/blog/2013/10/10/solr-meetup-memo/</link>
      <pubDate>Thu, 10 Oct 2013 11:35:00 +0900</pubDate>
      
      <guid>https://blog.johtani.info/blog/2013/10/10/solr-meetup-memo/</guid>
      <description>不定期開催ですが第12回Solr勉強会を主催しました。 今回は、前回ほどの過熱ぶりでは無かったですが、70人ほどの参加者の方がいらっしゃったか</description>
      <content:encoded><p>不定期開催ですが<a href="http://atnd.org/events/43532/">第12回Solr勉強会</a>を主催しました。</p>
<p>今回は、前回ほどの過熱ぶりでは無かったですが、70人ほどの参加者の方がいらっしゃったかと。
ありがとうございます！</p>
<p>今回は聞きたかったYokozunaの話をしてもらいました。あと、リベンジManifoldCF。
<em>一部、追記しました。Bashoさんからツッコミがあったので。あと、4.5.1の話とか。</em></p>
<!-- more -->
<h2 id="manifoldcfのとsolrの組み合わせ仮株式会社-ロンウイット大須賀稔さん">ManifoldCFのとSolrの組み合わせ（仮）株式会社 ロンウイット　大須賀　稔さん</h2>
<p>前回お休みだったのでリベンジですw。</p>
<p>英語だ。。。やっぱ英語がいいですか、スライド。。。<br>
ManifoldCFの概要から。
最新版は1.3です。色々サポートしてるなぁ。</p>
<p>デモもありました。（やっぱりちゃんと動かないので、鬼門みたいですが）</p>
<h4 id="デモ">デモ</h4>
<p>ManifoldCFのGUIで操作しながら。
いまいちちゃんと動かなかった。。。</p>
<h4 id="qa">QA</h4>
<ul>
<li>Q:Zipはうまく動かなかった</li>
<li>A:Solr側で処理してくれてる。</li>
<li>Q:Notes対応するの？</li>
<li>A:いまのところない。</li>
<li>Q:ExcelとかPDFはTika？</li>
<li>A:Tika次第です。</li>
<li>Q:認証周りどこから取ってくるの？</li>
<li>A:クローラ側にはなくて、SharePointとかの権限をみてる。</li>
<li>Q:Web系の認証は？</li>
<li>A:まだないのでは。。。（調査します）</li>
</ul>
<p>あー、デモの続き忘れてましたね。。。</p>
<h2 id="solrを組み込んだriak-20の全文検索機能--yokozuna--bashoジャパン株式会社鈴木一弘さん">Solrを組み込んだRiak 2.0の全文検索機能 -Yokozuna- Bashoジャパン株式会社　鈴木　一弘さん</h2>
<p>Riak色々使われてるよ！アングリーバードとか、Y!とか。
Riakで提供されている1機能としてのYokozuna。単独製品ではないですよと。</p>
<p>Riakの説明。スケールするよ、いつでもRead/Writeできるよ、運用にフォーカスしてるよと。
マスターレスですよ。
Riak2.0のリリースは2013年末。Yokozunaもかな？</p>
<p>ダイナミックフィールド使ってるので、Yokozunaをonにするだけで簡単に使えるよ。</p>
<p>RiakがSolrのプロセスを管理。</p>
<p>インデックスの不整合の検知とかってどうやってるのかなぁ？
インデックス比較用のハッシュツリーをノード間でコピーしつつ検査してる。（Active Anti-Entropy）</p>
<p>(デモには魔物がいるようだ。。。)</p>
<h4 id="qa-1">QA</h4>
<ul>
<li>Q:JSONの属性を元にしてフィールドにインデックス可能か？</li>
<li>A:可能です。IIJさんの発表で話が出ます。</li>
<li>Q:ProtocolBufferでSolrにアクセス可能？</li>
<li>A:<strike>そのうちできそうです。</strike>リリース時にはできるようになっています。</li>
<li>Q:コアのスワップは？スキーマの変更は？</li>
<li>A:事前に設定するのは可能。</li>
<li>Q:RiakのデータとSolrでデータがずれるってのはあるの？</li>
<li>A:可能性はありますが、<strike>極力ずれ</strike>AAEで修復。</li>
<li>Q:復旧中のインデックスにアクセスが行かないようにする仕組みなどはある？</li>
<li>A:今はないです。</li>
</ul>
<h2 id="yokozuna-ベンチマークしました株式会社インターネットイニシアティブ曽我部崇さん田中-義久さん">Yokozuna ベンチマークしました　株式会社インターネットイニシアティブ　曽我部　崇さん、田中 義久さん</h2>
<p>いいとこ取りで楽だなぁと。いうことで、試してみてます。
デモが動いてる。</p>
<p>extractorでXMLやJSONをパースできる。
ベンチマーク結果。</p>
<p>Riak Meetup Tokyo #2の時のQAも入ってるので助かります。素晴らしい。</p>
<h4 id="qa-2">QA</h4>
<ul>
<li>Q:スナップショットは両方取れるの？</li>
<li>A:Riakは取れますが、インデックスは今は無理です。</li>
<li>フォロー:0.8はYokozunaにボトルネックがあったので、0.9以降だともっと性能が出るはずですとのこと。また次回とかに発表してもらうのもありですかねぇ。</li>
</ul>
<h2 id="solr-45の新機能など-johtani">Solr 4.5の新機能など @johtani</h2>
<p><a href="/images/entries/20131009/Solr4_5_Changes.pdf">発表資料のPDF</a>です。</p>
<p>ツイート見てて誤解を招いたなと思ったのですが、7u40は4.5限定ではなく、すべてのバージョンと考えてください。
チケットを見ると分かりますが、影響バージョンの記載はありません。</p>
<p>※あ、4.5のChangesを紹介しましたが、4.5.1が出るかも。このへんが困ってるらしいです。</p>
<ul>
<li><a href="https://issues.apache.org/jira/browse/SOLR-5306">SOLR-5306: can not create collection when have over one config</a></li>
<li><a href="https://issues.apache.org/jira/browse/SOLR-5317">SOLR-5317: CoreAdmin API is not persisting data properly</a></li>
<li><a href="https://issues.apache.org/jira/browse/LUCENE-5263">LUCENE-5263: Deletes may be silently lost if an IOException is hit and later not hit (e.g., disk fills up and then frees up)</a></li>
</ul>
<h2 id="lt">LT</h2>
<h3 id="haruyama-さん">@haruyama さん</h3>
<p>資料：<a href="http://haruyama.github.io/solr_20131009/#(1)">http://haruyama.github.io/solr_20131009/#(1)</a></p>
<p>記号が捨てられるTokenizer困るので、捨てないのを作ってみました。</p>
<p>Kuromojiの困ったこと。全角数字を分解しちゃう。→MappingCharFilterFactoryで全角から半角にしましょう。
lucene-gosenデフォで半角記号が未知語になってしまい、半角カナと混ざるので、記号を全角にしましょう。</p>
</content:encoded>
    </item>
    
    <item>
      <title>MorphlinesのloadSolrをちょっとだけ調べてみた</title>
      <link>https://blog.johtani.info/blog/2013/08/02/morphlines-loadsolr/</link>
      <pubDate>Fri, 02 Aug 2013 18:02:00 +0900</pubDate>
      
      <guid>https://blog.johtani.info/blog/2013/08/02/morphlines-loadsolr/</guid>
      <description>宿題その2？かな。Solr勉強会でCloudera Searchのスキーマ周りってどうなってるの？という質問が出てて、 なんか調べることになって</description>
      <content:encoded><p>宿題その2？かな。Solr勉強会でCloudera Searchのスキーマ周りってどうなってるの？という質問が出てて、
なんか調べることになってたので、関係しそうなMorphlinesの<a href="https://github.com/cloudera/cdk/blob/master/cdk-morphlines/cdk-morphlines-solr-core/src/main/java/com/cloudera/cdk/morphline/solr/LoadSolrBuilder.java">LoadSolr</a>コマンドを調べてみました。
こいつが、Solrへの書き込みを実行するコマンドみたいだったので。<br>
（※Cloudera Searchのスキーマの設定方法とかは調べてないです。）<br>
（※めんどくさかったので、パッケージ名すっ飛ばしてクラス名書いてます。githubへのリンクを代わりに貼ってます。）</p>
<!-- more -->
<h2 id="recordsolrのドキュメント">Record＝Solrのドキュメント</h2>
<p>convert()メソッドにて、MorphlinesのRecord（コマンドの処理するデータの１単位）に格納されているKey-ValueデータをSolrInputDocumentクラスのフィールドとして格納しています。
Recordにもフィールドという概念があり、Recordのフィールド＝Solrのフィールドという事みたいです。</p>
<p>ということで、Solrのフィールドは事前に定義しておき、Morphlinesの処理内部でSolrのフィールド名に値を詰めていく感じでしょうか。
別途、<a href="https://github.com/cloudera/cdk/blob/master/cdk-morphlines/cdk-morphlines-solr-core/src/main/java/com/cloudera/cdk/morphline/solr/SanitizeUnknownSolrFieldsBuilder.java">sanitizeUnknownSolrFilds</a>というコマンドが用意されていて、Solrのスキーマにないものはこのコマンドを使って、無視するフィールド名に変えたり、雑多なデータを入れるためのフィールド名にするといった処理ができるようです。このコマンド内部で、Solrのスキーマ設定を元に、Solrのフィールドに合致する物があるかをチェックして処理しています。</p>
<h2 id="solrへの登録処理は">Solrへの登録処理は？</h2>
<p>Solrへの登録処理自体はLoadSolrクラス内部でDocumentLoaderというクラスのload()メソッドを呼び出しているだけでした。ということで、<a href="https://github.com/cloudera/cdk/blob/master/cdk-morphlines/cdk-morphlines-solr-core/src/main/java/com/cloudera/cdk/morphline/solr/DocumentLoader.java">DocumentBuilder</a>クラスを少し調査。</p>
<h3 id="documentloader">DocumentLoader</h3>
<p>IFでした。。。実クラスは次の条件</p>
<ol>
<li>SolrMorphlineContextにDocumentLoaderがあればそちらを採用（他の種類はなにがあるんだろ？）</li>
<li>なければ、<a href="https://github.com/cloudera/cdk/blob/b6f98cff4a027af04f97fdec9abf729785d74cf5/cdk-morphlines/cdk-morphlines-solr-core/src/main/java/com/cloudera/cdk/morphline/solr/SolrServerDocumentLoader.java">SolrServerDocumentLoader</a>をnewしたものを利用</li>
</ol>
<p>2.の場合がおそらくMapReduceではないパターンのloadSolrだと思われます。SolrServerDocumentBuilderはSolrJのAPIを利用して、Solrへデータ登録していく普通のアプリです。（対象とするSolrは外部に起動しているもののはず＝FlumeのSolrSinkではこちらを採用かな？）<br>
Solrへの接続情報とか設定ファイルとかSolrCloud用のZooKeeperとかは<a href="https://github.com/cloudera/cdk/blob/master/cdk-morphlines/cdk-morphlines-solr-core/src/main/java/com/cloudera/cdk/morphline/solr/SolrLocator.java">SolrLocatorクラス</a>に設定される内容が利用されます。</p>
<p>1.のパターンは、どうやら、<a href="https://github.com/cloudera/search/blob/master/search-mr/src/main/java/org/apache/solr/hadoop/morphline/MorphlineMapper.java">Cloudera SearchのMapReduceIndexerToolのクラス</a>にあるMyDocumentLoaderかなぁと。
こちらは、MapReduceを利用する場合に、利用されてるっぽいです（ちゃんと見てないけど）
内部処理は、HadoopのContext.writeメソッドにでSolrInputDocument（＝MorphlinesのRecord）を書きだして、ReducerでSolrOutputFormatでインデックス作成の流れかなと。たぶん、<a href="https://github.com/cloudera/search/blob/master/search-mr/src/main/java/org/apache/solr/hadoop/morphline/MorphlineMapRunner.java">MorphlineMapRunner</a>あたりを読みこめば解読できるかと。
ちなみに、こちらは、2.とは異なり、SolrLocatorの設定は無視されそう。</p>
<h2 id="感想妄想">感想＋妄想？</h2>
<p>ということで、Morphlinesのデータ流れを考える上で、現時点ではSolrのスキーマを頭の片隅に置きつつ、
Recordの中にあるデータをゴニョゴニョしてデータを形成していくって感じになりそうです。
うまく処理できなかったものとかのカウントとかもとれたりするのかなぁ？とか、また色々と気になるところが出てきますが、一旦ここまでで。。。（だれか、続きを調べて書いてみてくれてもいいんですよ！コマンドもいっぱいあるし！）</p>
<p>とまぁ、こんなかんじでMorphlinesをちょっとだけ読みました。
よくよく考えたら、こんなの作ったことあるなぁと（こんなに汎用的じゃないけど）。
みんな同じ事考えるんですねぇ。
コマンドパターン？みたいな感じで、I/F決めてSolrとか別のシステムとかにデータ入れる処理を順番に記述できる的なバッチ処理良くかいてます（書いてましたのほうが正解かなぁ）。</p>
</content:encoded>
    </item>
    
    <item>
      <title>Morphlines入門？</title>
      <link>https://blog.johtani.info/blog/2013/07/31/introduction-morphlines/</link>
      <pubDate>Wed, 31 Jul 2013 19:12:00 +0900</pubDate>
      
      <guid>https://blog.johtani.info/blog/2013/07/31/introduction-morphlines/</guid>
      <description>Morphlinesについてちょっとだけ、さらに調べました。 誤解 Solr勉強会でなんとなく私の認識を話しましたが、ちょっと誤解してたみたいで</description>
      <content:encoded><p>Morphlinesについてちょっとだけ、さらに調べました。</p>
<h2 id="誤解">誤解</h2>
<p>Solr勉強会でなんとなく私の認識を話しましたが、ちょっと誤解してたみたいです。スミマセン。</p>
<!-- more -->
<h3 id="誤解morphlineというプラットフォームミドルウェアがありそうなイメージ">誤解：Morphlineというプラットフォーム/ミドルウェアがありそうなイメージ</h3>
<p>まぁ、書いてあるのでちゃんと読めって話ですが、Morphlineはあくまでライブラリだということでした。
私はなんとなくManifoldCFのようなミドルウェアorプラットフォームが存在して、
そこにFlumeのSinkとかMapReduceによるIndexerが動作するのかと思ってました。</p>

<link rel="stylesheet" href="/css/hugo-easy-gallery.css" />
<div class="box" style="max-width:300">
  <figure  itemprop="associatedMedia" itemscope itemtype="http://schema.org/ImageObject">
    <div class="img">
      <img itemprop="thumbnail" src="/images/entries/20130731/wrong_image.jpg" />
    </div>
    <a href="/images/entries/20130731/wrong_image.jpg" itemprop="contentUrl"></a>
  </figure>
</div>

<p>まぁ、これが間違いでした。正解のイメージはこっちですね。</p>


<div class="box" style="max-width:300">
  <figure  itemprop="associatedMedia" itemscope itemtype="http://schema.org/ImageObject">
    <div class="img">
      <img itemprop="thumbnail" src="/images/entries/20130731/correct_image.jpg" />
    </div>
    <a href="/images/entries/20130731/correct_image.jpg" itemprop="contentUrl"></a>
  </figure>
</div>

<p>各プラットフォーム（FlumeとかHadoopとか）に組み込んむライブラリで、
それぞれ組み込んだ先でMorphlineの設定を記述することで、パイプライン処理ができるっぽいです。</p>
<p>Flumeについては、MorphlineSolrSinkというクラスでMorphlineの設定ファイルを読み込み、いろいろ処理出来ます。</p>
<p>Map/ReduceだとCloudera Searchに含まれてる<a href="https://github.com/cloudera/search">MapReduceIndexerTool</a>がMorphlineの設定を読み込んでコマンド実行してくれるみたいです。
MapReduceIndexerToolはまだちゃんと読んでないのですが、MapperとしてMorphlineのコマンドが実行されるのかなぁ？という感じです。
（結構入り組んでるので、ちゃんと読まないとわからない。。。）</p>
<p>ということで、Morphlineというプラットフォームがあって、一元的にFlumeやMap/Reduceに対するコマンドをパイプライン化するという話でありませんでした。</p>
<p>※ちなみに、上の画像ですが、愛用しているNUBoardを使って書いてます。
考えをまとめるのにすごく役立つ一品です。持ち運び可能なノート型ホワイトボードです。</p>
<iframe src="http://rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&bc1=000000&IS1=1&nou=1&bg1=FFFFFF&fc1=000000&lc1=0000FF&t=johtani-22&o=9&p=8&l=as1&m=amazon&f=ifr&ref=qf_sp_asin_til&asins=B00A08IVT4" style="width:120px;height:240px;" scrolling="no" marginwidth="0" marginheight="0" frameborder="0"></iframe>
<h3 id="疑問点">疑問点</h3>
<p>ただ、読んでてまだ不明な点があります。まぁ、ぼちぼち調べるかなぁと。。。</p>
<ul>
<li>Solrのschemaはどーなってんの？</li>
<li>MorphlineにSolrへロードするコマンド（loadSolr）があるけど、FlumeのMorphlineSolrSinkってのもSolrに書き込みそうだけど？</li>
<li>Map/ReduceでSolrに書き込むもMorphlineのコマンドとの違いは？（前にソースを見たときはSOLR-1301がベースになっていて、SolrOutputFormatってクラスがEmbeddedSolrServer起動してインデクシングしてた）</li>
<li>GoLiveってなんだろ？（MapReduceIndexerToolに入ってて、M/Rでインデックス作ったあとにSolrのクラスタに配布＋マージするやつっぽい）</li>
<li>どんなコマンドがあるの？（<a href="http://cloudera.github.io/cdk/docs/0.4.1/cdk-morphlines/morphlinesReferenceGuide.html">Cloudera Morphlines Ref Guide</a>）</li>
</ul>
<p>以下は、参考資料と参考資料にあるSlideshareの資料を一部訳したものになります。</p>
<h3 id="参考資料">参考資料</h3>
<ul>
<li><a href="http://www.slideshare.net/cloudera/using-morphlines-for-onthefly-etl">Using Morphlines for On-the-Fly ETL(slideshare)</a></li>
<li><a href="https://github.com/cloudera/cdk/tree/master/cdk-morphlines">cloudera/cdk/cdk-morphlines(github)</a></li>
</ul>
<h2 id="メモ">メモ</h2>
<h3 id="現在のコマンドライブラリスライド-18-19ページ">現在のコマンドライブラリ（スライド 18-19ページ）</h3>
<ul>
<li>Solrへのインテグレートとロード</li>
<li>フレキシブルなログファイル解析</li>
<li>1行、複数行、CSVファイル</li>
<li>正規表現ベースのパターンマッチと展開</li>
<li>Avro、JSON、XML、HTMLのインテグレーション</li>
<li>Hadoop シーケンスファイルのインテグレーション</li>
<li>SolrCellとApache Tikaパーサすべてのインテグレーション</li>
<li>Tikaを利用したバイナリデータからMIMEタイプの自動判別</li>
<li>動的Javaコードのスクリプティングサポート</li>
<li>フィールドの割り当て処理、比較処理</li>
<li>リストやセット書式のフィールド処理</li>
<li>if-then-else条件分岐</li>
<li>簡易ルールエンジン（tryRules）</li>
<li>文字列とタイムスタンプの変換</li>
<li>slf4jロギング</li>
<li>Yammerメトリックとカウンター</li>
<li>ネストされたファイルフォーマットコンテナの解凍</li>
<li>などなど</li>
</ul>
<h3 id="プラグインコマンドスライド20ページ">プラグインコマンド（スライド　20ページ）</h3>
<ul>
<li>簡単に新しいI/Oや変換コマンドが追加可能</li>
<li>サードパーティや既存機能のインテグレード</li>
<li>CommandインタフェースかAbstractCommandのサブクラスを実装</li>
<li>Javaクラスパスに新規作成したものを追加</li>
<li>登録処理などは必要ない</li>
</ul>
<h3 id="新しいプラグインコマンドとして考えられるもの22ページ">新しいプラグインコマンドとして考えられるもの（22ページ）</h3>
<ul>
<li>RDBやKVSやローカルファイルなどの外部データソースをレコードにjoin</li>
<li>DNS名前解決とか短縮URLの展開とか</li>
<li>ソーシャル・ネットワークからリンクされたメタデータのフェッチ（？？）</li>
<li>レコードの感情分析とアノテーション？</li>
</ul>
<p>31ページの図がわかりやすいかも</p>
<p>以上。</p>
</content:encoded>
    </item>
    
    <item>
      <title>第11回Solr勉強会を主催しました。#SolrJP</title>
      <link>https://blog.johtani.info/blog/2013/07/29/study-of-solr/</link>
      <pubDate>Mon, 29 Jul 2013 23:15:00 +0900</pubDate>
      
      <guid>https://blog.johtani.info/blog/2013/07/29/study-of-solr/</guid>
      <description>不定期開催ですが第11回Solr勉強会を主催しました。 今回も大入り90人くらい？の参加者の皆さんがいらっしゃいました。ありがたいことです！（</description>
      <content:encoded><p>不定期開催ですが<a href="http://atnd.org/events/41368/">第11回Solr勉強会</a>を主催しました。</p>
<p>今回も大入り90人くらい？の参加者の皆さんがいらっしゃいました。ありがたいことです！（20時時点で最終的に補欠17人でした。）</p>
<p><strike>とりあえず、第一報です。このあと懇親会なので。</strike></p>
<p>ということで、帰りの電車でいくつか感想を（忘れちゃうから）。</p>
<!--  more -->
<p>小林さんの苦労話は細かいですが、結構はまりがちな点を共有していただいたので良かったかなぁと。
Solrのexampleの設定とか、ManifoldCFとかちょっとずつ罠があったりするので、あるあるネタはありがたいと思いますｗ</p>
<p>Cloudera Searchについては、安定の嶋内さんの喋りに圧巻でした。検索だけの視点とは異なる観点についての
話は私には足りないしてんだったりするので参考になります。
なんか、気づいたらMorphlineやスキーマ周りを調べてブログ書くことになっちゃったけど。。。
一つ質問しそこねたのがあって、Cloudera社は基本的に公開したOSSについてのトレーニングも立ち上げているイメージです。Cloudera Searchについてもトレーニングが立ち上がるのかなぁと密かに期待をしてみたり（予算の関係上参加できるかは不明ですが。。。）</p>
<p>牧野さんの話は画像系について、私は詳しくないので、また関口さんのalikeと比較とかしてもらえると面白いかなぁと。とりあえず、青いロボットがちゃんと検索できるようになるといいですねｗｗ</p>
<p>秀野さんの空間検索は緯度経度以外のPOLYGONなどを利用した検索で、実は私も知らない機能でしたｗ<br>
なとなくは知ってたんですが、そこまでちゃんと検索できるとは！地図以外にも活用できるような気がします（想像つかないんだけど。。。）</p>
<p>最後は私の発表で、簡単な資料ですみませんでした。しかも発表よりも宣伝が。。。（ブログの宣伝だったりとか。。。）
最後に宣伝した「<a href="http://www.ipsj.or.jp/dp/cfp/copy_of_copy_of_dp0502s.html">「ビッグデータ活用を支えるOSS」特集への論文投稿のご案内</a>」もご検討ください！</p>
<p>懇親会も楽しかったです。また思いついたら開催しますー<br>
最後に、今回の発表者の皆様、会場提供していただいたVOYAGE GROUPの皆様ありがとうございました！</p>
<p>以下はいつものメモです。</p>
<h2 id="manifoldcfのとsolrの組み合わせ仮株式会社-ロンウイット大須賀さん">ManifoldCFのとSolrの組み合わせ（仮）株式会社 ロンウイット　大須賀さん</h2>
<p>残念ながら、発熱のため発表は次回に持ち越しに。</p>
<p>##社内ファイル及びWEBコンテンツの検索システム構築時に苦労したこと ソフトバンクBB㈱　小林さん</p>
<ul>
<li>ManifoldCF＋Solrを使って社内ファイルの検索システム構築</li>
<li>約1000万ドキュメント</li>
<li>さまざまなDCにドキュメントがある</li>
</ul>
<h4 id="クロールジョブのハング">クロールジョブのハング。。。</h4>
<ul>
<li>ログをDEBUGにしたら。。。ログファイル150GB。。。</li>
<li>一定時間ごとにAgentをリスタートするバッチを。。。（力技）</li>
</ul>
<h4 id="mcfエラーによるジョブの停止">MCFエラーによるジョブの停止</h4>
<ul>
<li>CONNECTORS-590</li>
<li>エラーが発生して止まったジョブを起動するバッチをcronで。。。</li>
</ul>
<h4 id="自作リアルタイムインデクシングの問題">自作リアルタイムインデクシングの問題</h4>
<ul>
<li>MCF使わないでSlaveにインデックス</li>
<li>openSearcher=falseだとautoCommitが実行されてもSearcherを再起動しないので検索にでてこない</li>
</ul>
<h4 id="リプリケーションのnw負荷">リプリケーションのNW負荷</h4>
<ul>
<li>別DCからのレプリケーションが複数が一度に実施される→ネットワーク負荷が。。。</li>
<li>cronで別々にレプリすることでNW負荷を分散できてるかな。。。
　　</li>
</ul>
<h2 id="cloudera-search-入門仮-cloudera-株式会社嶋内さん">Cloudera Search 入門(仮) Cloudera 株式会社　嶋内さん</h2>
<ul>
<li>マサカリ画像がｗ</li>
<li>SolrのコミッターMark Millerさんもジョインしてる</li>
</ul>
<h4 id="clouderaとhadoop入門とか">ClouderaとHadoop入門とか。</h4>
<ul>
<li>いろいろあるよ、エコシステム</li>
<li>4つの分類。
<ul>
<li>データの取り込み</li>
<li>データの保存</li>
<li>データの活用</li>
</ul>
</li>
</ul>
<h4 id="search">Search</h4>
<ul>
<li>検索エンジンなら数十億人が使い方を知ってる（Clouderaのチャールズ・ゼドルースキ）</li>
</ul>
<h4 id="cloudera-search">Cloudera Search</h4>
<ul>
<li>
<p>Hadoopのためのインタラクティブな検索</p>
</li>
<li>
<p>CDHとSolrの統合</p>
</li>
<li>
<p>OSS！</p>
</li>
<li>
<p>利点とか。</p>
<ul>
<li>データ解析にも使えるよね、検索</li>
<li>非構造化データの検索にもいいよね</li>
<li>単一プラットフォームによるコスパ</li>
</ul>
</li>
</ul>
<h4 id="cloudera-searchの事例">Cloudera Searchの事例</h4>
<ul>
<li>バイオテクノロジー企業で画像検索とか</li>
<li>医療系企業でいろんなログイベントの管理とか</li>
</ul>
<h4 id="cloudera-searchのアーキテクチャ">Cloudera Searchのアーキテクチャ</h4>
<ul>
<li>Flumeでストリーミングで登録</li>
<li>HBaseデータの登録</li>
<li>M/Rでバッチ登録</li>
<li>HueのWebインタフェース</li>
</ul>
<p>Morphlines、HBaseはLinyプロジェクトのもの</p>
<p>Solr使うならCDH！！</p>
<h4 id="qa">QA</h4>
<ul>
<li>
<p>Q：デモで使われたTwitterの検索のデータ料とかは？</p>
</li>
<li>
<p>A：デモ環境ですので小さい。</p>
</li>
<li>
<p>Q：スキーマってどうするの？</p>
</li>
<li>
<p>A：スキーマは。。。私が書こうかなぁ、ブログ。。。</p>
</li>
</ul>
<h2 id="コンピュータビジョン株式会社-curious-vehicle牧野さん">コンピュータビジョン　株式会社 Curious Vehicle　牧野さん</h2>
<ul>
<li>色々やってます</li>
<li>コンピュータビジョンの説明（某ネコ型ロボットのいろんな画像がｗ）</li>
</ul>
<h4 id="画像検索の流れ">画像検索の流れ</h4>
<ol>
<li>特徴情報の抽出</li>
<li>特徴情報のクラスタリングによるword化</li>
<li>Solrによる画像情報の検索</li>
</ol>
<h5 id="1-特徴情報の抽出">1. 特徴情報の抽出</h5>
<ul>
<li>SIFT特徴点解析</li>
<li>グレースケールしてからSIFT</li>
<li>注意！SIFTは商用ライセンスが必要です</li>
</ul>
<h5 id="2-特徴情報のクラスタリングによるword化">2. 特徴情報のクラスタリングによるword化</h5>
<ul>
<li>K-meansでクラスタリング</li>
<li>クラスタ情報をヒストグラム化してSolrへ</li>
</ul>
<h5 id="3-solrによる画像情報の検索">3. Solrによる画像情報の検索</h5>
<ul>
<li>物体認識ベンチマークセット（ケンタッキー大）を使って。</li>
<li>やっぱり良し悪しある。データセットに特化したチューニングしてます。</li>
</ul>
<h4 id="つぎのステップ">つぎのステップ</h4>
<ul>
<li>文字認識とか顔認識</li>
<li>つぎはドラえもんじゃねぇ、検索とかも。。。</li>
</ul>
<h5 id="ガウシアンによる画像ぼかしの例">ガウシアンによる画像ぼかしの例</h5>
<h4 id="qa-1">QA</h4>
<p>マイク回しててメモ取れず。。。</p>
<h2 id="国土交通省のデータをsolrで検索株式会社ネクスト秀野さん">国土交通省のデータをSolrで検索　株式会社ネクスト　秀野さん</h2>
<p><a href="https://speakerdeck.com/ryo0301/guo-jiao-sheng-falsedetawosolrdejian-suo">スライドはこちら</a></p>
<ul>
<li>評価の関係で。。。</li>
<li>Spatial検索の話</li>
</ul>
<h4 id="デモの想定機能">デモの想定機能</h4>
<ul>
<li>地図上の小学校を起点に物件検索</li>
<li>地図上をクリックしたところを中心に検索</li>
</ul>
<h4 id="デモ環境">デモ環境</h4>
<ul>
<li>Solr4.3.0、PostGIS 2.0.3、東京都のデータ</li>
</ul>
<h4 id="事前知識">事前知識</h4>
<ul>
<li>ジオメトリーデータ（点、線、面がある）</li>
<li>WKB/WKT、Intersects（しらなかった。こんなのもあるのか）</li>
</ul>
<h4 id="環境">環境</h4>
<ul>
<li>EC2上にPostGIS＋Solrで構築</li>
<li>WKT形式でDIHでインポートできるらしい。</li>
<li>Solr＋S3をJSでGoogleMapへ</li>
</ul>
<h2 id="solr-44新機能をちょっと紹介johtani">Solr 4.4新機能をちょっと紹介　@johtani</h2>
<p>紹介というよりも宣伝。。。</p>
</content:encoded>
    </item>
    
    <item>
      <title>Yokozunaの気になる点というかなんというか</title>
      <link>https://blog.johtani.info/blog/2013/07/11/yokozuna-check-point/</link>
      <pubDate>Thu, 11 Jul 2013 01:43:00 +0900</pubDate>
      
      <guid>https://blog.johtani.info/blog/2013/07/11/yokozuna-check-point/</guid>
      <description>Yokozunaの気になる点というか、自分だったらこのへん調べるだろうなって観点を上げてみます。 別に調べるわけじゃないので、完全に自己満足な</description>
      <content:encoded><p>Yokozunaの気になる点というか、自分だったらこのへん調べるだろうなって観点を上げてみます。
別に調べるわけじゃないので、完全に自己満足なメモですけど。<br>
ちなみに、分散システムとかRiakの仕組みは詳しくないので、ズレてる点がいっぱいあるかも。<br>
というか、分散システムでテストというか、検討する点とかってまとまってる資料とかあるのかなぁ？</p>
<!-- more -->
<ul>
<li>スキーマ変更時の挙動
<ul>
<li>フィールド型変更とか、フィールド追加とか</li>
</ul>
</li>
<li>既存RiakクラスタにYokozunaの機能を追加する方法と制限
<ul>
<li>タイムラグとかも</li>
</ul>
</li>
<li>Riak＋Yokozunaクラスタに対してノード追加時に発生するオーバーヘッド（ネットワークとかディスクIOとか）</li>
<li>性能検証のためのシナリオ（どっちが先に悲鳴をあげるかとか）
<ul>
<li>Riakメインで、Yokozunaはおまけ程度に検索するというシナリオ</li>
<li>Yokozunaメインで使うシナリオ</li>
<li>更新が多い場合のシナリオ</li>
</ul>
</li>
<li>Riakのみ、Riak＋Yokozunaの各種統計情報（CPU、メモリ、ディスクサイズ、ネットワークIO）</li>
<li>運用系（監視とか）の手法とか機能？とか</li>
<li>バージョンアップなどの対応方法</li>
<li>Solrがコケた時とかの対処</li>
</ul>
<p>とりあえず、こんな感じかなぁ。</p>
</content:encoded>
    </item>
    
    <item>
      <title>Riak Meetup Tokyo #2に参加しました。#riakjp</title>
      <link>https://blog.johtani.info/blog/2013/07/10/riak-meetup-tokyo-no2/</link>
      <pubDate>Wed, 10 Jul 2013 18:57:00 +0900</pubDate>
      
      <guid>https://blog.johtani.info/blog/2013/07/10/riak-meetup-tokyo-no2/</guid>
      <description>先日、Bashoさんにおじゃましたのもあり、Riak Meetup Tokyo #2に参加しました。 Yokozunaの話も聞けるということで。 懇親会も参加しました。</description>
      <content:encoded><p>先日、Bashoさんにおじゃましたのもあり、<a href="http://connpass.com/event/2656/">Riak Meetup Tokyo #2</a>に参加しました。<br>
Yokozunaの話も聞けるということで。
懇親会も参加しました。Vさん＆リピさんと話し込んじゃってあんまり他の人と話せなかったけど。。。</p>
<p>以下はいつものメモです。</p>
<!-- more -->
<h2 id="freakout-久森さん-riak環境をプロダクションで構築運用してみた仮">FreakOut 久森さん 「Riak環境をプロダクションで構築＆運用してみた（仮）」</h2>
<h3 id="freakoutとrtb">FreakOutとRTB</h3>
<ul>
<li>ディスプレイ広告の新しい配信の枠の話</li>
<li>この人には何出すの？いくらで？みたいな感じ</li>
<li>純広告：表示保証、期間保証など</li>
<li>RTB：1回の広告表示ごとに買い付け</li>
<li>DSP（デマンド・サイト・プラットフォーム）</li>
<li>広告表示は大体0.1秒で表示しないといけない。この間に色々やってる。
<ul>
<li>50ms or die.で戦ってます。</li>
</ul>
</li>
<li>RTBはCPUバウンド
<ul>
<li>多コアを安く並べたい</li>
<li>Tokyoなんとかとか使ってた。
<ul>
<li>スケーラビリティがキツイ（クライアント側でアルゴリズム分散してる）</li>
<li>データ解析もしたいけど、検索ができない</li>
</ul>
</li>
<li>RTBに適したRiakがうまくハマるのではと。</li>
</ul>
</li>
</ul>
<h3 id="構成とかとか">構成とかとか</h3>
<ul>
<li>アプリはPerlなので、PerlでRiakクライアントが必要。Memcached互換とかあると嬉しい。</li>
<li>ProtobufサポートもPurePerlしかなかった。</li>
<li>ないなら、作ろうと。<a href="https://github.com/myfinder?tab=repositories">githubに上がってます。このへんかな？</a></li>
<li>監視はcloudforecastとかでやってる。</li>
</ul>
<h3 id="課題">課題</h3>
<ul>
<li>Redirectがつらい（haproxy？がつらい？）</li>
<li>Setが詰まるとつらい（ケースがまだわからない）</li>
<li>対策１
<ul>
<li>memcached＋Riak</li>
</ul>
</li>
<li>対応２（案）
<ul>
<li>hashからpartitionに直接取りに行くとか</li>
</ul>
</li>
</ul>
<h3 id="まとめ">まとめ</h3>
<ul>
<li>素のままRiakはちょっとつらい</li>
</ul>
<h4 id="qa">QA</h4>
<p>聞き取れたやつだけ</p>
<ul>
<li>Q：1台いくら位ですか？
<ul>
<li>A：10万から11万くらい</li>
</ul>
</li>
<li>Q：どのくらいの性能ですか？
<ul>
<li>A：同時1000くらいをさばいてる？</li>
</ul>
</li>
<li>Q：50ms以下を出すのに、ネットワーク周りで近さとかを考えることありますか？
<ul>
<li>A：国内だと10msあればなんとかなる。それよりもアプリ側のチューニングのほうがまだ重要</li>
</ul>
</li>
<li>Q：Cassandraとか候補に挙がらなかったんですか？
<ul>
<li>A：苦しんでる人が知人にいるので。。。あと、用途的に違うので。</li>
</ul>
</li>
<li>Q：バックエンドとしてはなにを？
<ul>
<li>A：bitcaskにしてる</li>
</ul>
</li>
<li>Q：サーバ構成、ネットワーク構成がどうなってる？
<ul>
<li>A：。。。</li>
</ul>
</li>
<li>Q：Redirectとは？RiakがやってるRedirect？
<ul>
<li>A：はい。</li>
</ul>
</li>
<li>Q：他に候補にあがったのは？
<ul>
<li>A：<a href="http://www.aerospike.com">商用のaerospike（これかな？）</a>がスケールできそうだったけど、クライアントがいまいち。。。</li>
</ul>
</li>
</ul>
<h3 id="感想">感想</h3>
<p>広告業界のことをよくわかってないので、微妙にピンときてなかったりもするのですが、以下に素早く返すかって観点でどこに注力して、問題点を潰していくのかってのは面白そうだなぁと。
リクエスト処理の性能がクリアできたらつぎはスケールの観点（ノード追加時の挙動とか）で検証していくんだろうなと。次回の話も聞いてみたい感じです。</p>
<h2 id="iij-曽我部さん田中さん-yokozuna-日本語検索性能を評価しました">IIJ 曽我部さん、田中さん 「Yokozuna 日本語検索性能を評価しました」</h2>
<h3 id="yokozunaって">Yokozunaって？</h3>
<ul>
<li>Riak＋Solrでいいとこ取り</li>
<li>データの登録とかはRiakのAPIで。</li>
<li>SolrのAPIが使える。</li>
<li>YokozunaがSolrの分散検索の部分を隠してくれる。</li>
</ul>
<h3 id="yokozunaのインストールとか">Yokozunaのインストールとか。</h3>
<ul>
<li>SolrのAPIっぽい形で検索できるし、戻りもSolrのXMLっぽいのが出てくるよ。</li>
</ul>
<h3 id="wikipediaデータってstoreの性能とか">Wikipediaデータってstoreの性能とか。</h3>
<ul>
<li>Riakのノード32台。（Xeon、メモリ24GB、HDD。。。）</li>
<li>yz_extractor：Riakのコンテンツタイプを見てSolrにデータを入れる処理が書いてある。</li>
<li>自分でschema.xmlを書いてYokozunaに指定することもできる。
<ul>
<li>スキーマの変更とか登録とか。
<ul>
<li>すでに指定済みスキーマを変更した場合の挙動ってどうなるの？</li>
</ul>
</li>
</ul>
</li>
<li>デモではSolrからid取って、Riakからその他のデータを取り出していた。</li>
</ul>
<h4 id="rubyでの性能評価">Rubyでの性能評価</h4>
<ul>
<li>ベンチマークプログラム側の問題が先に影響が出てしまった。</li>
</ul>
<h3 id="qa-1">QA</h3>
<ul>
<li>Q：Riak単体とYokozunaつかった時でディスク容量がどのくらい増えた？
<ul>
<li>A：ちゃんと調べてないが、10%くらい増えた気がする。</li>
</ul>
</li>
<li>Q：Solr側の設定でstored=trueだけど、falseにしてもいいんじゃないの？
<ul>
<li>A：デモはfalseにしてます。</li>
</ul>
</li>
<li>Q：スキーマってあとから変更できるんですかね？
<ul>
<li>A：まだ良くわかってないです。</li>
</ul>
</li>
<li>Q：ノードの追加、削除時の挙動とかも気になります。</li>
</ul>
<h3 id="感想-1">感想</h3>
<p>今回はStore性能に関してでしたが、今後は検索性能やシナリオによる性能（KVSの処理メインで、時々全文検索とか、全文検索の処理も結構あるパターンとか）の測定とか、耐障害性とかの観点で調査を進めてもらってSolr勉強会で話をしてもらえると面白そうだなぁと勝手に思ってみたり。
Solr勉強会へのコンタクトお待ちしてます！ｗ</p>
</content:encoded>
    </item>
    
    <item>
      <title>スキーマレスモード？（SOLR-4897）を調べて見ました。</title>
      <link>https://blog.johtani.info/blog/2013/07/04/schemaless-example/</link>
      <pubDate>Thu, 04 Jul 2013 01:12:00 +0900</pubDate>
      
      <guid>https://blog.johtani.info/blog/2013/07/04/schemaless-example/</guid>
      <description>Solr 4.4に取り込まれる予定のチケットで、気になるものを見つけたのでいつものごとく調べてみました。 元となるチケットはこちら。SOLR-4897</description>
      <content:encoded><p>Solr 4.4に取り込まれる予定のチケットで、気になるものを見つけたのでいつものごとく調べてみました。</p>
<p>元となるチケットは<a href="https://issues.apache.org/jira/browse/SOLR-4897">こちら。SOLR-4897</a>。</p>
<!-- more -->
<h2 id="スキーマレス">スキーマレス？</h2>
<p>Solrはschema.xmlにデータの定義（フィールドタイプやフィールドなど）を記述して、データを登録する全文検索システムです。
これまでのSolrではこの設定ファイルを元にデータを登録するフィールド名を決定しており、
変更を行う場合はSolrのコアを再起動するなどの手順が必要でした。（※ダイナミックフィールドはすこし特殊）</p>
<p>それだと、Solrを管理するのがめんどくさいですね？という感じで現れたのが<a href="http://wiki.apache.org/solr/SchemaRESTAPI">SchemaREST API</a>です。（たぶん。）</p>
<h2 id="schema-rest-api">Schema REST API</h2>
<p>Solr 4.2から導入されたSolrのスキーマに関する情報を提供するためのREST APIです。
4.2で導入されたのはあくまでもschema.xmlの情報を取得するためのAPIでした。
たとえば、Fieldの一覧を取得するとか。</p>
<p>4.4から、フィールドの追加（変更、削除はできない）ができるようになりました。あくまでも、フィールドの追加で、フィールドタイプなどの追加はまだできません。（できるようになるのかもわからないですが。）
フィールドの追加方法などは<a href="http://wiki.apache.org/solr/SchemaRESTAPI?highlight=%28managed%29#Adding_fields_to_a_schema">Wiki</a>に記載がありました。</p>
<p>ということで、簡単に試してみることに。</p>
<h2 id="起動方法">起動方法</h2>
<p>exampleディレクトリの下にexample-schemalessというディレクトリが新設されています。
ここに、スキーマレスモード用の設定がされているファイルが入っているので、こちらを利用します。</p>
<pre><code>cd $SOLR/example
java -Dsolr.solr.home=example-schemaless/solr -jar start.jar
</code></pre><p>ログにいくつかWARNが出ますが、影響の内パス設定ミスなので無視してOKです。</p>
<p>最初に定義されているフィールドは「id」と「_version_」のみになります。（Schema Browserなどで確認できます。あ、REST APIでもいいですね。<a href="http://localhost:8983/solr/schema/fields">http://localhost:8983/solr/schema/fields</a>）</p>
<h2 id="スキーマの更新">スキーマの更新</h2>
<p>さて、フィールドを追加してみます。
PUTを利用すると1フィールドの追加が可能です。
「fugatext」というフィールド名でフィールドを追加しています。今のところJSONのみ対応みたいです。</p>
<pre><code>$ curl -X PUT http://localhost:8983/solr/schema/fields/fugatext -H 'Content-Type: application/json' -d '{&quot;type&quot;:&quot;text_ja&quot;,&quot;stored&quot;:false,&quot;multiValued&quot;:true}'
{
  &quot;responseHeader&quot;:{
    &quot;status&quot;:0,
    &quot;QTime&quot;:18}}
</code></pre><p>追加できたかどうかもREST APIで取得してみます。</p>
<pre><code>$ curl http://localhost:8983/solr/schema/fields
{
  &quot;responseHeader&quot;:{
    &quot;status&quot;:0,
    &quot;QTime&quot;:0},
  &quot;fields&quot;:[{
      &quot;name&quot;:&quot;_version_&quot;,
      &quot;type&quot;:&quot;long&quot;,
      &quot;indexed&quot;:true,
      &quot;stored&quot;:true},
    {
      &quot;name&quot;:&quot;fugatext&quot;,
      &quot;type&quot;:&quot;text_ja&quot;,
      &quot;multiValued&quot;:true,
      &quot;stored&quot;:false},
    {
      &quot;name&quot;:&quot;id&quot;,
      &quot;type&quot;:&quot;string&quot;,
      &quot;multiValued&quot;:false,
      &quot;indexed&quot;:true,
      &quot;required&quot;:true,
      &quot;stored&quot;:true,
      &quot;uniqueKey&quot;:true}]}
</code></pre><p>追加できました。
ちなみに、同じフィールド名を追加しようとするとエラーが帰ってきます。</p>
<pre><code>$ curl -X PUT http://localhost:8983/solr/schema/fields/fugatext -H 'Content-Type: application/json' -d '{&quot;type&quot;:&quot;text_ja&quot;,&quot;stored&quot;:false,&quot;multiValued&quot;:true}'
{
  &quot;responseHeader&quot;:{
    &quot;status&quot;:400,
    &quot;QTime&quot;:1},
  &quot;error&quot;:{
    &quot;msg&quot;:&quot;Field 'fugatext' already exists.&quot;,
    &quot;code&quot;:400}}
</code></pre><h2 id="設定の違い">設定の違い</h2>
<p>example-schemalessのsolrconfig.xmlは以下の設定が通常のexampleとは異なるようです。</p>
<h4 id="schemafactoryの設定">schemaFactoryの設定</h4>
<p>schemaをAPIから変更可能にする設定です。これまでの変更しない設定の場合は<code>ClassicIndexSchemaFactory</code>を指定します。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-xml" data-lang="xml">...
  <span style="color:#f92672">&lt;schemaFactory</span> <span style="color:#a6e22e">class=</span><span style="color:#e6db74">&#34;ManagedIndexSchemaFactory&#34;</span><span style="color:#f92672">&gt;</span>
    <span style="color:#f92672">&lt;bool</span> <span style="color:#a6e22e">name=</span><span style="color:#e6db74">&#34;mutable&#34;</span><span style="color:#f92672">&gt;</span>true<span style="color:#f92672">&lt;/bool&gt;</span>
    <span style="color:#f92672">&lt;str</span> <span style="color:#a6e22e">name=</span><span style="color:#e6db74">&#34;managedSchemaResourceName&#34;</span><span style="color:#f92672">&gt;</span>managed-schema<span style="color:#f92672">&lt;/str&gt;</span>
  <span style="color:#f92672">&lt;/schemaFactory&gt;</span>
...
</code></pre></div><h4 id="updatechainの設定">update.chainの設定</h4>
<p>更新処理（update関連のリクエストハンドラ「/update」とか）には次のような設定が追加されていました。（1006行目あたり）</p>
<pre><code>  &lt;requestHandler name=&quot;/update&quot; class=&quot;solr.UpdateRequestHandler&quot;&gt;
    &lt;!-- See below for information on defining 
         updateRequestProcessorChains that can be used by name 
         on each Update Request
      --&gt;
    &lt;lst name=&quot;defaults&quot;&gt;
      &lt;str name=&quot;update.chain&quot;&gt;add-unknown-fields-to-the-schema&lt;/str&gt;
    &lt;/lst&gt;
  &lt;/requestHandler&gt;
</code></pre><p>「add-unknown-fields-to-the-schema」というupdate.chainが指定されています。このchainの定義自体は1669行目くらいに存在します。
（長い。。。）</p>
<pre><code>  &lt;!-- Add unknown fields to the schema 
  
       An example field type guessing update processor that will
       attempt to parse string-typed field values as Booleans, Longs,
       Doubles, or Dates, and then add schema fields with the guessed
       field types.  
       
       This requires that the schema is both managed and mutable, by
       declaring schemaFactory as ManagedIndexSchemaFactory, with
       mutable specified as true. 
       
       See http://wiki.apache.org/solr/GuessingFieldTypes
    --&gt;
  &lt;updateRequestProcessorChain name=&quot;add-unknown-fields-to-the-schema&quot;&gt;
    &lt;processor class=&quot;solr.RemoveBlankFieldUpdateProcessorFactory&quot;/&gt;
    &lt;processor class=&quot;solr.ParseBooleanFieldUpdateProcessorFactory&quot;/&gt;
    &lt;processor class=&quot;solr.ParseLongFieldUpdateProcessorFactory&quot;/&gt;
    &lt;processor class=&quot;solr.ParseDoubleFieldUpdateProcessorFactory&quot;/&gt;
    &lt;processor class=&quot;solr.ParseDateFieldUpdateProcessorFactory&quot;&gt;
      &lt;arr name=&quot;format&quot;&gt;
        &lt;str&gt;yyyy-MM-dd'T'HH:mm:ss.SSSZ&lt;/str&gt;
        &lt;str&gt;yyyy-MM-dd'T'HH:mm:ss,SSSZ&lt;/str&gt;
        &lt;str&gt;yyyy-MM-dd'T'HH:mm:ss.SSS&lt;/str&gt;
        &lt;str&gt;yyyy-MM-dd'T'HH:mm:ss,SSS&lt;/str&gt;
        &lt;str&gt;yyyy-MM-dd'T'HH:mm:ssZ&lt;/str&gt;
        &lt;str&gt;yyyy-MM-dd'T'HH:mm:ss&lt;/str&gt;
        &lt;str&gt;yyyy-MM-dd'T'HH:mmZ&lt;/str&gt;
        &lt;str&gt;yyyy-MM-dd'T'HH:mm&lt;/str&gt;
        &lt;str&gt;yyyy-MM-dd HH:mm:ss.SSSZ&lt;/str&gt;
        &lt;str&gt;yyyy-MM-dd HH:mm:ss,SSSZ&lt;/str&gt;
        &lt;str&gt;yyyy-MM-dd HH:mm:ss.SSS&lt;/str&gt;
        &lt;str&gt;yyyy-MM-dd HH:mm:ss,SSS&lt;/str&gt;
        &lt;str&gt;yyyy-MM-dd HH:mm:ssZ&lt;/str&gt;
        &lt;str&gt;yyyy-MM-dd HH:mm:ss&lt;/str&gt;
        &lt;str&gt;yyyy-MM-dd HH:mmZ&lt;/str&gt;
        &lt;str&gt;yyyy-MM-dd HH:mm&lt;/str&gt;
        &lt;str&gt;yyyy-MM-dd&lt;/str&gt;
      &lt;/arr&gt;
    &lt;/processor&gt;
    &lt;processor class=&quot;solr.AddSchemaFieldsUpdateProcessorFactory&quot;&gt;
      &lt;str name=&quot;defaultFieldType&quot;&gt;text_general&lt;/str&gt;
      &lt;lst name=&quot;typeMapping&quot;&gt;
        &lt;str name=&quot;valueClass&quot;&gt;java.lang.Boolean&lt;/str&gt;
        &lt;str name=&quot;fieldType&quot;&gt;booleans&lt;/str&gt;
      &lt;/lst&gt;
      &lt;lst name=&quot;typeMapping&quot;&gt;
        &lt;str name=&quot;valueClass&quot;&gt;java.util.Date&lt;/str&gt;
        &lt;str name=&quot;fieldType&quot;&gt;tdates&lt;/str&gt;
      &lt;/lst&gt;
      &lt;lst name=&quot;typeMapping&quot;&gt;
        &lt;str name=&quot;valueClass&quot;&gt;java.lang.Long&lt;/str&gt;
        &lt;str name=&quot;valueClass&quot;&gt;java.lang.Integer&lt;/str&gt;
        &lt;str name=&quot;fieldType&quot;&gt;tlongs&lt;/str&gt;
      &lt;/lst&gt;
      &lt;lst name=&quot;typeMapping&quot;&gt;
        &lt;str name=&quot;valueClass&quot;&gt;java.lang.Number&lt;/str&gt;
        &lt;str name=&quot;fieldType&quot;&gt;tdoubles&lt;/str&gt;
      &lt;/lst&gt;
    &lt;/processor&gt;
    &lt;processor class=&quot;solr.LogUpdateProcessorFactory&quot;/&gt;
    &lt;processor class=&quot;solr.RunUpdateProcessorFactory&quot;/&gt;
  &lt;/updateRequestProcessorChain&gt;
</code></pre><p>使ってるUpdateProcessorはこんな感じみたいです。最後の2つはこれ用じゃないので省略。</p>
<table>
<tr><th>プロセッサ名</th><th>説明</th></tr>
<tr><td>RemoveBlankFieldUpdateProcessorFactory</td><td>値がないフィールドは除去</td></tr>
<tr><td>ParseBooleanFieldUpdateProcessorFactory</td><td>スキーマに定義されていないフィールドで、値がBooleanとしてパースできたら、Boolean型とする。</td></tr>
<tr><td>ParseLongFieldUpdateProcessorFactory</td><td>スキーマに定義されていないフィールドで、値がLongとしてパースできたら、Long型とする。</td></tr>
<tr><td>ParseDoubleFieldUpdateProcessorFactory</td><td>スキーマに定義されていないフィールドで、値がDoubleとしてパースできたら、Double型とする。</td></tr>
<tr><td>ParseDateFieldUpdateProcessorFactory</td><td>スキーマに定義されていないフィールドで、値がDateとしてパースできたら、Date型とする。（パースの形式がformatで列挙されてる）</td></tr>
<tr><td>AddSchemaFieldsUpdateProcessorFactory</td><td>入力されたドキュメントの中でスキーマに定義されていないフィールド（静的、動的両方）を見つけた時に、フィールドの値の型を元にフィールド型をマッピングする。</td></tr>
</table>
<p>とここまで見てきたところで、スキーマレスという名前の意図がちょっとわかったかも。</p>
<h2 id="定義されてないフィールドを持ったデータを登録">定義されてないフィールドを持ったデータを登録</h2>
<p>起動時には定義されてないフィールドをもったデータを登録してみます。
boolean型で試してみることに。以下のデータを管理画面のデータ登録画面から登録します。（http://localhost:8983/solr/#/collection1/documents）
（タイトルでbooleanってわかりにくいですが）</p>
<pre><code>{&quot;id&quot;:&quot;change.me&quot;,&quot;title&quot;:true, &quot;price&quot;:1.25, &quot;fuga&quot;:&quot;100,200&quot;}
</code></pre><p>エラーは出ません。で、またフィールド一覧を取得すると。</p>
<pre><code>$ curl http://localhost:8983/solr/schema/fields
{
  &quot;responseHeader&quot;:{
    &quot;status&quot;:0,
    &quot;QTime&quot;:1},
  &quot;fields&quot;:[{
      &quot;name&quot;:&quot;_version_&quot;,
      &quot;type&quot;:&quot;long&quot;,
      &quot;indexed&quot;:true,
      &quot;stored&quot;:true},
    {
      &quot;name&quot;:&quot;fuga&quot;,
      &quot;type&quot;:&quot;tlongs&quot;},
    {
      &quot;name&quot;:&quot;fugatext&quot;,
      &quot;type&quot;:&quot;text_ja&quot;,
      &quot;multiValued&quot;:true,
      &quot;stored&quot;:false},
    {
      &quot;name&quot;:&quot;id&quot;,
      &quot;type&quot;:&quot;string&quot;,
      &quot;multiValued&quot;:false,
      &quot;indexed&quot;:true,
      &quot;required&quot;:true,
      &quot;stored&quot;:true,
      &quot;uniqueKey&quot;:true},
    {
      &quot;name&quot;:&quot;price&quot;,
      &quot;type&quot;:&quot;tdoubles&quot;},
    {
      &quot;name&quot;:&quot;title&quot;,
      &quot;type&quot;:&quot;booleans&quot;}]}
</code></pre><p>おー、最後にtitleが追加されてます。他にもfugaやpriceも。（日付は手を抜きました。。。）</p>
<h2 id="感想">感想</h2>
<p>詳細までは追いかけてないですが、こんなかんじです。
フィールド追加が可能になるのはいいんじゃないでしょうか。SolrCloudの機能との関連もあるのかもしれません。ZooKeeperへの出力も実装されてそうなので。</p>
<p>ただ、機械的に出力されたschema.xml（exampleだとmanaged-schemaというファイル）には_「DO NOT EDIT」_との記述があるので、修正するとなにかおきてしまうかもしれないですねぇ。
現時点では、フィールドタイプの変更やフィールドの更新、削除に関してはSolrCoreの再起動などの手順が必要です。
あと、変なデータ（タイプミスとか）が登録されたりしないかってのは気になりますね。</p>
<p>※ちなみに、別の人が気づいたんですが、ちょっとバグが有ったみたいで、代わりにチケットつくったらキリ番（<a href="https://issues.apache.org/jira/browse/SOLR-5000">SOLR-5000</a>）
ゲットしましたｗ</p>
</content:encoded>
    </item>
    
    <item>
      <title>Solrの管理画面でデータ登録</title>
      <link>https://blog.johtani.info/blog/2013/06/27/upload-docs-solr-admin/</link>
      <pubDate>Thu, 27 Jun 2013 16:28:00 +0900</pubDate>
      
      <guid>https://blog.johtani.info/blog/2013/06/27/upload-docs-solr-admin/</guid>
      <description>SolrのチケットをML経由で眺めてるんですが、便利そうなチケットが流れてきたのでブログを書いてみみようかと。 元になってるチケットはこちらで</description>
      <content:encoded><p>SolrのチケットをML経由で眺めてるんですが、便利そうなチケットが流れてきたのでブログを書いてみみようかと。
元になってるチケットは<a href="https://issues.apache.org/jira/browse/SOLR-4921">こちら</a>です。昨日だか、今朝にtrunkとbranch_4xにコミットされたみたいです。試してみたい方は、branch_4xかtrunkをチェックアウトすると触ることができます。</p>
<!-- more -->
<h2 id="データ登録用の画面json">データ登録用の画面（JSON）</h2>
<p>branch_4xをチェックアウトしてexampleを起動し、Solrにアクセスします。<br>
管理画面に「Dcuments」という項目が追加されてます。開くとこんなかんじです。</p>
<p>
  <img src="/images/entries/20130626/add_default_page.jpg" alt="デフォルトのデータ登録画面">

</p>
<p>なんと、デフォルトはJSONになってます。これも時代の流れでしょうかｗ<br>
Solrでは、これまで設定ファイルやデータ登録もXMLがメインになっていました。（<a href="http://www.amazon.co.jp/gp/product/4774141755/ref=as_li_ss_tl?ie=UTF8&amp;camp=247&amp;creative=7399&amp;creativeASIN=4774141755&amp;linkCode=as2&amp;tag=johtani-22">Apache Solr入門</a>もXMLを基本に書いてます。このころはまだデフォルトでは対応してなかったので）</p>
<p>登録するデータをテキストエリアに記述して、「Submit Document」をクリックすればデータは登録されます。基本的には単件登録の画面でしょうか。
（登録されたデータを確認するには「Query」画面を利用すればいいです。）
また、JSONのデータ形式は<a href="http://wiki.apache.org/solr/UpdateJSON">SolrのWiki</a>を参照してください。</p>
<h3 id="csvやxmlも">CSVやXMLも</h3>
<p>この管理画面ではJSON以外の形式でもデータの登録が可能です。
「Document Type」の項目をクリックすると以下のように選択肢があられます。</p>
<p>
  <img src="/images/entries/20130626/select_document_type.jpg" alt="Document Typeの選択">

</p>
<p>CSV、XMLについては、先ほどのJSONの画面の用に、テキストエリアが表示されます。
テキストエリアにCSV（データの形式は<a href="http://wiki.apache.org/solr/UpdateCSV">こちら</a>）やXML（データの形式は<a href="http://wiki.apache.org/solr/UpdateXmlMessages">こちら</a>）を入力してボタンを押せば登録できます。</p>
<h3 id="solr-command形式もjosnかxml">Solr Command形式も（JOSNかXML）</h3>
<p>Solr Command というのはXMLやJSONで登録、コミット、削除などを実行するための画面になります。
JSONのコマンドは<a href="http://wiki.apache.org/solr/UpdateJSON#Update_Commands">こちら</a>、XMLのコマンドは<a href="http://wiki.apache.org/solr/UpdateXmlMessages">こちら</a>をご覧ください。</p>
<p>あと、便利なのがファイルアップロードです。
こんなかんじで、ファイルを選んでSubmitすればデータが登録出来ます。</p>
<p>
  <img src="/images/entries/20130626/file_upload.jpg" alt="File Uploadの画面">

</p>
<p>ファイルのサイズが大きいとちょっと時間がかかりますが、コマンドを打つより簡単かもしれません。
post.jarツールと違って、デフォルトでコミットをしてくれるわけではないので、「Extracting Req. Handler Params」に「commit=true」をつけないと、データが登録されてない？と思ってしまうかもしれませんが。</p>
<h3 id="組立もできるみたいdocument-builder">組立もできるみたい（Document Builder）</h3>
<p>最後に紹介するのが「Document Builder」というタイプです。</p>
<p>
  <img src="/images/entries/20130626/document_builder_desc.jpg" alt="Document Builderの画面説明">

</p>
<p>もっと簡易にデータを記述できるようにということで用意されているようです。
フィールドの情報はSolrに接続して利用できるフィールド？（ダイナミックはないのかな？）が表示されます。</p>
<p>
  <img src="/images/entries/20130626/document_builder_fields.jpg" alt="Document Builderでフィールド表示">

</p>
<p>追記していくとこんなかんじになります。</p>
<p>
  <img src="/images/entries/20130626/document_builder_.jpg" alt="出来上がったドキュメント">

</p>
<p>日本語のデータもちゃんと登録できました。
ただ、まだ、開発中なんでしょうがないかもしれませんが、以下の様な制約があるようです。</p>
<ul>
<li>multiValuedなフィールドに値を追加できない（上書きされる）</li>
<li>改行が入ったデータをテキストエリアにいれると「Add Field」を押しても反応しない</li>
<li>ダイナミックフィールドは自分で書きましょう</li>
</ul>
<p>ただ、これまでXMLでファイルを作ってコマンドで登録したり、curlコマンドでJSON書いたりして登録していたよりはお手軽にさわれるようになるかと思います。つぎの4x系のバージョンが出たときはこちらからデータを登録してみてください。</p>
</content:encoded>
    </item>
    
    <item>
      <title>Basho Japanに遊びに行きました</title>
      <link>https://blog.johtani.info/blog/2013/06/19/visited-basho/</link>
      <pubDate>Wed, 19 Jun 2013 10:03:00 +0900</pubDate>
      
      <guid>https://blog.johtani.info/blog/2013/06/19/visited-basho/</guid>
      <description>ちょくちょく書こうと言いながら、前の記事が1週間以上前になってる。。。 昨日は、Basho Japanに遊びに行って来ました。 （Riak触ったこ</description>
      <content:encoded><p>ちょくちょく書こうと言いながら、前の記事が1週間以上前になってる。。。</p>
<p>昨日は、Basho Japanに遊びに行って来ました。
（Riak触ったことないのに。。。Erlangも。。。ゴメンナサイ）</p>
<!-- more -->
<p>RiakにSolrを組み合わせたYokozunaというものの名前を最近耳にしていたので、どんなものなのかなぁと興味がありまして。Solrがどんな使い方をされているのかってのが気になったので、
情報交換したいなぁと思っていたところ、Vの人が調整してくれたので色々と有意義な話ができたかなぁと。
（Yokozunaについての最新のスライドは<a href="https://speakerdeck.com/rzezeski/yokozuna-scaling-solr-with-riak">Berlin Buzzword 2013のものがここに</a>）
Twitter上で見かけたことのある方々と話ができたり面白かったです。（やっぱ英語で会話できたりスラスラと読めるの必要だよなぁと痛感したりもしました。。。）</p>
<p>ということで、遊びに行ったのに美味しいピザやこんなおみやげまでもらってしまいました。
（ピザの写真撮るの忘れてたw）</p>

<link rel="stylesheet" href="/css/hugo-easy-gallery.css" />
<div class="box" >
  <figure  itemprop="associatedMedia" itemscope itemtype="http://schema.org/ImageObject">
    <div class="img">
      <img itemprop="thumbnail" src="/images/entries/20130619/riak-goods.jpg" />
    </div>
    <a href="/images/entries/20130619/riak-goods.jpg" itemprop="contentUrl"></a>
      <figcaption align="center"><h4>Riak＆Bashoグッズ</h4>
      </figcaption>
  </figure>
</div>

<p>ちなみに、Yokozunaですが、Riakに登録したデータを裏で起動しているSolにデータを流しこんでくれるものになります。
Solrの機能としては分散検索（Distributed Search）と呼ばれる仕組みを利用しているようです。
YokozunaのI/Fとしては、Solrのインデックスの分散構成は隠してくれていて、かつ、Solr（っぽい？）リクエストを投げれば裏の分散構成に問い合わせた結果をSolrのレスポンスの形で返してくれます。
KVSに全文検索の機能がついてくるお得感が満載な気がしますw。</p>
<p>Riak自身のデータの取り扱いがどんなものかをまだちゃんと理解していないので（ゴメンナサイ。<a href="http://littleriakbook.com">Little Riak Book</a>は開いてるんですが読んでなくて。。。）またおじゃましてもう少し情報交換したいかなぁとｗ。</p>
<p>Cloudera Searchといい、Yokozunaといい、Solrを利用したものが少しずつ増えてきて嬉しい限りです。
Solrの作りがしっかりしている？活発？、だから取り込む形が多いんですかねぇ。
Solr本を書いてから数年たちますが、やっと検索のニーズが出てきたのかもしれないなぁと思ってみたり。
（流れのつながりはあまりないですが）ElasticSearchも少しずつ人気が出てきてるし、日本語の本とかのニーズあったりするかなぁ？</p>
</content:encoded>
    </item>
    
    <item>
      <title>新しいsolr.xmlとCore探索ロジック</title>
      <link>https://blog.johtani.info/blog/2013/06/11/new-solr-xml/</link>
      <pubDate>Tue, 11 Jun 2013 19:11:00 +0900</pubDate>
      
      <guid>https://blog.johtani.info/blog/2013/06/11/new-solr-xml/</guid>
      <description>Lucene/Solr 4.3.1のRCのVoteが始まっていますが、そのMLできになったコトがあり、ちょっと調べたので メモを残しておきます。 マルチコアの設定ファ</description>
      <content:encoded><p>Lucene/Solr 4.3.1のRCのVoteが始まっていますが、そのMLできになったコトがあり、ちょっと調べたので
メモを残しておきます。</p>
<p>マルチコアの設定ファイルであるsolr.xmlの記述方法と、コアの探索ロジックが4.4（実装的には4.3から入っている）から変更されるようです。4.x系の最新版である、branch_4xのexampleディレクトリにあるsolr.xmlも新しい記述に変更されていました。</p>
<!-- more -->
<h3 id="参考url">参考URL</h3>
<ul>
<li><a href="http://wiki.apache.org/solr/Core%20Discovery%20%284.4%20and%20beyond%29">新しいCore探索（4.4以降）</a></li>
<li><a href="http://wiki.apache.org/solr/Solr.xml%204.4%20and%20beyond">新しいsolr.xml（4.4以降）</a></li>
<li><a href="http://wiki.apache.org/solr/Solr.xml%20%28supported%20through%204.x%29">4.3までのsolr.xml</a></li>
</ul>
<p>ちなみに、最後のold styleと呼ばれる4.3までの記述方法はつぎの5.0ではDeprecatedになるようです。（5.0がいつ出るのかはわからないですが。）</p>
<h2 id="core探索ロジック">Core探索ロジック</h2>
<p>4.4から、$SOLR_HOMEディレクトリ以下の探索ロジックは次のようになるようです。
以下では、「新スタイル」（4.4以降の書式）、「旧スタイル」（4.3以下の書式）として記述します。</p>
<ol>
<li>solr.xmlファイルの存在チェック
<ol>
<li>solr.xmlが存在しない場合→旧スタイルとして処理→3へ（旧スタイル）</li>
<li>solr.xmlが存在し<code>&lt;cores&gt;</code>タグが存在しない場合→2へ（新スタイル）</li>
<li>solr.xmlが存在し<code>&lt;cores&gt;</code>タグが存在する場合→3へ（旧スタイル）</li>
</ol>
</li>
<li>新スタイルのロジック
<ol>
<li>SOLR_HOMEディレクトリに存在するディレクトリについて以下の処理を繰り返す</li>
<li>SOLR_HOME/ディレクトリ/core.propertiesファイルが存在する→後続処理へ。存在しなければ終了</li>
<li>SOLR_HOME/ディレクトリ/conf/solrconfig.xmlを読み込み、コアを起動</li>
</ol>
</li>
<li>旧スタイルのロジック
<ol>
<li>これまで同様、solr.xmlの<code>&lt;core&gt;</code>タグの記載内容を元にコアを起動（instanceDir以下のconf/solrconfig.xmlを使って）</li>
<li>solr.xmlが存在しない場合はSOLR_HOME/collection1/conf/solrconfig.xmlが存在するものとしてコアを起動</li>
</ol>
</li>
</ol>
<p>このようなロジックになります。</p>
<p>ちなみに、以下の場合はエラーとなりSolrは起動しますがログや管理画面にエラーである表示がされます。</p>
<ul>
<li>2.3でsolrconfig.xmlが見つけられなかった場合</li>
<li>3.1で<code>&lt;core&gt;</code>タグが存在しなかった場合（この場合、ログにはエラーが出ません）</li>
</ul>
<p>propertiesに記述できる内容やsolr.xmlの記述内容については、Wikiを見てもらうということで。。。
CoreAdminHandlerでコアを生成したりした場合に、新スタイルの設定がどのように出力されるのかといった点が気になりますが、また今度にでも。</p>
</content:encoded>
    </item>
    
    <item>
      <title>Cloudera Searchメモ（妄想版）</title>
      <link>https://blog.johtani.info/blog/2013/06/06/cloudera-search-memo2/</link>
      <pubDate>Thu, 06 Jun 2013 12:26:00 +0900</pubDate>
      
      <guid>https://blog.johtani.info/blog/2013/06/06/cloudera-search-memo2/</guid>
      <description>ざっとインストールガイドとかCloudera Searchのソース眺めて、テキトーにメモを書いてみました。 （ユーザガイドはまだ読んでないです。</description>
      <content:encoded><p>ざっとインストールガイドとかCloudera Searchのソース眺めて、テキトーにメモを書いてみました。
（ユーザガイドはまだ読んでないです。）</p>
<!-- more -->
<h2 id="ざっくりメモ">ざっくりメモ</h2>
<ul>
<li>ストリーム処理でインデックス作るときはFlume経由でSolrに
<ul>
<li>SinkとEventの両方が用意されてる？（Flumeを良く知らないので、違いがわからない）</li>
<li>FluemeからはリモートのSolrに対してインデックス登録するクラスがある。SolrServerDocumentLoaderがソレだと思う。</li>
</ul>
</li>
<li>バッチ処理でインデックス作るときはMapReduceIndexerToolsってのを使ってSolrに
<ul>
<li><a href="https://issues.apache.org/jira/browse/SOLR-1301">SOLR-1301</a>がベースになっている。色々と改良されてるようだけど、コアとなってる処理はSOLR-1301。</li>
<li>GoLiveってクラスの処理の中で、現在動作してるSolrに配布したバッチで作成されたIndexをマージする処理が書いてある。</li>
<li>HDFSへ出力されたインデックスはリモートのSolrからアクセスするとオーバヘッドとかどーなるのかなぁ？</li>
</ul>
</li>
<li>検索処理自体はHueでもできるけど、基本的にSolrCloud任せ</li>
<li>インデキシングの処理のフローについてはCloudera Mrophlinesで定義</li>
</ul>
<p>ということで、
2つの流れがありそう。</p>
<ul>
<li>HDFS→Flume→Solr</li>
<li>HDFS→MapReduce→Solr</li>
</ul>
<p>で、まだ、わかってないですが、構成要素として</p>
<ul>
<li>Hadoop（HDFS）：データソース</li>
<li>Hadoop（MapReduce）：データ変換処理、バッチインデキシング</li>
<li>Zookeeper：SolrCloudのクラスタ管理</li>
<li>Solr：インデキシング、検索エンジン</li>
<li>Flume：データをストリーミングでSolrへ</li>
<li>Coudera Morphlines：HDFSからSolrまでのETLデータ処理を定義実行する環境</li>
</ul>
<p>って感じでしょうか。
SolrCloudのクラスタとHadoopのクラスタが同一マシン上なのか、別なのかとか。組み合わせがどんなものができるのかがまだわかってないです。
ユーザガイド読んでみたらなにか出てくるかなぁ。</p>
<p>ちなみに、Cloudera SearchのgithubリポジトリにあるソースはCloudera Morphlinesのコードがメインで、SolrのHDFS対応版のソースがあるわけでは無かったです。</p>
<ul>
<li>SolrのHdfsDirectoryってのがClouderaのリポジトリにあるSolrには追加されていて、これが、HDFSのインデックスを読み込んだりする処理が出来る仕組みっぽい。</li>
<li>一応、SolrCloud以外（分散検索）も考慮された形になってるっぽい。</li>
</ul>
<p>ってとこでしょうか。</p>
<h2 id="感想">感想</h2>
<p>読んでて思ったんですが、Cloudera Searchの肝はじつは、検索じゃなくて、Morphlinesにあるんじゃないかなぁと。今はSolrが出力先ですが、
その他のデータ変換処理とかが増えてくると、処理の流れがMorphlinesで定義できてデータ変換処理が簡便になりそうな気が。</p>
<h2 id="その他に気になる観点">その他に気になる観点</h2>
<ul>
<li>CDH経由でSolrCloudのクラスタの管理するのかな？</li>
<li>SolrCloud用のクラスタとCDHのクラスタって同一マシンに載るの？別マシンにもできるの？
<ul>
<li>併存したらIOがキツそうだけど</li>
</ul>
</li>
<li>Hueで検索アプリとか組めるの？（そもそもHueがわかってないんだけど。。。）</li>
</ul>
<p>ま、とりあえず、こんなとこで。
つぎは余力があれば、ユーザガイドかなぁ。
英語力。。。</p>
</content:encoded>
    </item>
    
    <item>
      <title>Cloudera Searchのモジュールたち</title>
      <link>https://blog.johtani.info/blog/2013/06/05/cloudera-search-modules/</link>
      <pubDate>Wed, 05 Jun 2013 15:12:00 +0900</pubDate>
      
      <guid>https://blog.johtani.info/blog/2013/06/05/cloudera-search-modules/</guid>
      <description>Cloudera Searchは次のようなモジュールから構成されています。 これはCloudera Searchのモジュールで、さらにこれらがSolrとかを使っ</description>
      <content:encoded><p>Cloudera Searchは次のようなモジュールから構成されています。
これはCloudera Searchのモジュールで、さらにこれらがSolrとかを使ってるみたいですね。pom.xmlを見たら何を使ってるかがわかるかな。</p>
<ul>
<li>cdk-morphlines</li>
<li>search-contrib</li>
<li>search-core</li>
<li>search-flume</li>
<li>search-mr</li>
<li>search-solrcell</li>
</ul>
<p>てきとーに、README.mdみながらメモを残してみました。ソースとかはまだ読んでないです。
ざっと眺めたけど、インデキシング処理の話がメインで、検索側がどうやって動くかってのがわからなかったなぁ。
<a href="http://www.cloudera.com/content/cloudera-content/cloudera-docs/Search/latest/PDF/Cloudera-Search-User-Guide.pdf">ユーザガイド（注：PDF）</a>ってのがあるから、これを読んでみるか。。。</p>
<p>各モジュールについては、以下。</p>
<!-- more -->
<h2 id="cdk-morphlinescloudera-morphlines">cdk-morphlines（Cloudera Morphlines）</h2>
<p>Cloudera Morphlinesという名前みたい。
検インデキシングアプリの構築、変更をラクにするためのフレームワーク。
ETLの処理チェインを簡単にCloudera Searchにデータを入れる設定（Extract/Transform/Load処理）がかけると。
バッチ処理、Near Real Timeのために使えるみたい。検索結果をさらに入れるとかもできるんかなぁ。？</p>
<p>Unixパイプラインのの進化版みたいなもので、一般的なレコードに対するStream処理から、Flueme、MapReduce、Pig、Hie、SqoopのようなHadoopコンポーネントも使えるみたい。</p>
<p>Hadoop ETLアプリケーションのプロトタイピングにも使えて、リアルタイムで複雑なStreamやイベント処理やログファイル解析とかに使えるの？</p>
<p>設定ファイルのフォーマットは<a href="https://github.com/typesafehub/config/blob/master/HOCON.md">HOCONフォーマット</a>。AkkaやPlayで使われてる。</p>
<h3 id="cdk-morphlines-core">cdk-morphlines-core</h3>
<p>Cloudera Morphlinesのコンパイラ、実行環境、コマンドのライブラリを含んでる。
ログファイル解析やsingle-lineレコード、multi-lineレコード、CSVファイル、正規表現パターンマッチ、フィールドごとの比較とか条件分岐とか、文字列変換とか色々なコマンドを含んでる。</p>
<h3 id="cdk-morphlines-avro">cdk-morphlines-avro</h3>
<p>Avroファイルやオブジェクトの抽出、変換、読み込み処理コマンド</p>
<h3 id="cdk-morphlines-tika">cdk-morphlines-tika</h3>
<p>バイナリデータからMIMEタイプを検出して、解凍するコマンド。Tikaに依存</p>
<h4 id="雑感">雑感</h4>
<p>Cloudera Searchへのデータの流し込みを設定ファイルに記述して実行するとデータの変換処理とかが記述できるって感じかな？
Morphlinesのコマンドとして独自処理や使えそうな処理を作ることで、いろんな処理ができるって感じかなぁ。</p>
<h2 id="search-core">search-core</h2>
<p>Solrに対するMorphlineコマンドの上位モジュール</p>
<h3 id="search-solrcell">search-solrcell</h3>
<p>Tikaパーサを使ったSolrCellを使うためのMorphlineコマンド。
HTML、XML、PDF、Wordなど、Tikaがサポートしてるものがサポート対象。</p>
<h3 id="search-flume">search-flume</h3>
<p>Flueme Morphline Solr Sink。
Apache Flumeのイベントから検索ドキュメントを抽出、変換し、SolrにNearRealTimeで読み込むためのコマンド</p>
<h3 id="search-mr">search-mr</h3>
<p>HDFSに保存されたファイルに含まれる大量データをMapReduceで処理してHDFS上の検索インデックスに焼きこむモジュール。</p>
<p><code>MapReduceIndexerTool</code>は入力ファイルの集合からSolrのインデックスシャードの集合を作るためのmorphlineのタスクで、MapReduceのバッチジョブドライバー。
HDFSにインデックスを書き込む。
動作してるSolrサーバに対して出力されたデータをマージするのもサポートしてる。</p>
<p>とりあえず、Near Real Time検索するにはFlueme使って、バッチ処理でインデックス焼くのはMapReduceIndexerToolみたいだなぁ。</p>
</content:encoded>
    </item>
    
    <item>
      <title>Cloudera Searchってのが出たらしい（とりあえず、雑感？）</title>
      <link>https://blog.johtani.info/blog/2013/06/05/what-is-cloudera-search/</link>
      <pubDate>Wed, 05 Jun 2013 15:05:00 +0900</pubDate>
      
      <guid>https://blog.johtani.info/blog/2013/06/05/what-is-cloudera-search/</guid>
      <description>AWS Summitに来ていたのですが、TLでは、Cloudera Searchが賑わってました。 ということで、軽くどんなものか読んだり調べたりした</description>
      <content:encoded><p>AWS Summitに来ていたのですが、TLでは、Cloudera Searchが賑わってました。
ということで、軽くどんなものか読んだり調べたりしたメモを残しとこうかと。
英語力はあやしいので、おかしいとこがあったらツッコミを。</p>
<!-- more -->
<h2 id="cloudera-searchとは">Cloudera Searchとは？</h2>
<p>CDH4.3に対応したCDHユーザ向けの検索システム（beta版）なのかな？
CDHに統合された検索フレームワークなのかな？</p>
<p>基本はLucene/Solr 4.3でHadoopのペタバイトデータを検索することができるようになるみたいです。</p>
<h2 id="どんな仕組み">どんな仕組み？</h2>
<p>次のものを利用しているようです。（GithubのREADMEから。）</p>
<h4 id="使ってるもの">使ってるもの</h4>
<ul>
<li>Apache Solr(4.3.0＋α？)
<ul>
<li>Apache Lucene（Solrつかってるからね）</li>
<li>Apache SolrCloud（うーん、Solrに含まれるのに別に出してるのなんで？）</li>
</ul>
</li>
<li>Apache Flume</li>
<li>Apache Hadoop MapReduce &amp; HDFS</li>
<li>Apache Tika
<ul>
<li>SolrCellとしてSolrにも組み込まれてる、いろんな文書（WordとかHTMLなどなど）からメタデータと本文データとかを取り出せるライブラリラッパー。実際にはさらにpdfboxとかを使って各文書からのデータを取り出してる。</li>
</ul>
</li>
</ul>
<h4 id="何ができるの">何ができるの？</h4>
<p>HBaseやHDFSの用にZookeeperを使ってインデックスのシャーディングや高可用性ができる。（SolrCloudがZookeeperを使ってるからね。）
MapReduceのジョブの出力から自動的にSolrのインデックスにデータをマージできるらしい。
Cloudera Managerを使って、デプロイ、設定モニタリングなどが可能。</p>
<p>Flumeのフィードをつかって、ストリーミングしてインデックスを作れる。FluemeがデータをSolrに流しこむのかな？
将来的にはHiveやHBaseのテーブルをインデックスすることも可能になるらしい。Impalaクエリの結果もフィードできるのか？</p>
<p><a href="http://incubator.apache.org/blur/how_it_works.html">Apache Blur</a>ってキーワードも出てきた。HDFSのデータからLuceneのインデックス作るのかな？
NGDataのチームがSolr/HBaseの統合とかしてるみたい。</p>
<h3 id="参考url">参考URL</h3>
<ul>
<li><a href="http://blog.cloudera.com/blog/2013/06/cloudera-search-the-newest-hadoop-framework-for-cdh-users-and-developers/">Cloudera社のブログ</a></li>
<li><a href="http://cloudera.com/content/cloudera-content/cloudera-docs/Search/latest/PDF/Cloudera-Search-Frequently-Asked-Questions.pdf">Cloudera SearchのFAQ（注：PDF）</a></li>
<li><a href="https://github.com/cloudera/search">Githubのリポジトリ</a></li>
</ul>
</content:encoded>
    </item>
    
    <item>
      <title>Solr4.3.0のChangesを訳してみた。(Jugemより移植)</title>
      <link>https://blog.johtani.info/blog/2013/04/25/solr4-3-0%E3%81%AEchanges%E3%82%92%E8%A8%B3%E3%81%97%E3%81%A6%E3%81%BF%E3%81%9F/</link>
      <pubDate>Thu, 25 Apr 2013 11:14:00 +0900</pubDate>
      
      <guid>https://blog.johtani.info/blog/2013/04/25/solr4-3-0%E3%81%AEchanges%E3%82%92%E8%A8%B3%E3%81%97%E3%81%A6%E3%81%BF%E3%81%9F/</guid>
      <description>まだ、Vote公開されていない、Solr 4.3（2013/04/25 11:00現在）ですが、 ひさびさに訳してみた。詳細まで追っていないので、</description>
      <content:encoded><p><strong><span style="color:#FF0000">まだ、Vote公開されていない、Solr 4.3（2013/04/25 11:00現在）ですが</span>、</strong>
ひさびさに訳してみた。詳細まで追っていないので、誤訳があるかもしれないですが。
おかしいとこあったらツッコミを。</p>
<hr>
<p>○Solr 4.3.0のChanges
　・Upgrading from Solr 4.2.0
　　1.schema REST APIのcopyFields、dynamicFieldsの出力パスをCamelCaseに。他も同様。（<a href="http://issues.apache.org/jira/browse/SOLR-4623">SOLR-4623</a>）
　　2.Slf4j/logging jarをSolrのwarに含めないことに。すべてのlogging jarはexample/lib/extに。（<a href="http://issues.apache.org/jira/browse/SOLR-3706">SOLR-3706</a>、<a href="http://issues.apache.org/jira/browse/SOLR-4651">SOLR-4651</a>）
　　3.SolrCloudでハードコードされてたhostContextとhostPortをdeprecatedに。Solr5.0で削除する。（<a href="http://issues.apache.org/jira/browse/SOLR-4622">SOLR-4622</a>）</p>
<p>　・New Features
　　1.<a href="http://issues.apache.org/jira/browse/SOLR-4648">SOLR-4648</a>　PreAnalyzedUpdateProcessorFactoryでPreAnalyzedFieldの機能をほかのフィールドタイプでも使えるようにした。詳しくはJavadocとexampleを見て。
　　2.<a href="http://issues.apache.org/jira/browse/SOLR-4623">SOLR-4623</a>　REST APIで現在のschemaのエレメントをすべて読めるように。REST APIの返却の形式として、XMLとJSONとschema.xmlの形式を追加REST APIのパッケージを変更。
　　　クラス名も変更しschemaにフォーカスした機能も除去。今後のschema以外のREST APIのために。
　　　copyFieldsとdynamicFieldsの出力パスをすべてlowercaseのものからCamelCaseに変更。他のREST APIも同様。
　　3.<a href="http://issues.apache.org/jira/browse/SOLR-4658">SOLR-4658</a>　REST APIリクエストでschemaを変更できるようにするために、「managed schema」を導入。solrconfig.xmlに「&lt;schemaFactory class=&quot;ManagedSchemaFactory&rdquo; mutable=&quot;true&rdquo;/&gt;」を追加。REST APIリクエストでスキーマ変更が可能にするために。
　　4.<a href="http://issues.apache.org/jira/browse/SOLR-4656">SOLR-4656</a>　2つのハイライトパラメータ（hl.maxMultiValuedToMatch、hl.maxMultiValuedToExamine）を追加。
　　　hl.maxMultiValuedToMatchは指定された数のsnippetが見つかったらそれ以降の探索を停止する設定。multiValuedフィールドがどんなに離れてても探索する。
　　　hl.maxMultiValuedToExamineは指定された数のmultiValuedのエントリ数を調査したら探索を停止する設定。
　　　両方を指定した場合、最初のlimitに達したら停止する。ドキュメント全体をハイライトするためにコピーされるのを削減する。これらの最適化はmultiValuedフィールドに大量のエントリが存在する時に効く。。。
　　5.<a href="http://issues.apache.org/jira/browse/SOLR-4675">SOLR-4675</a>　PostingsSolrHighlighterでper-field/クエリ次のパラメータ指定のサポート
　　6.<a href="http://issues.apache.org/jira/browse/SOLR-3755">SOLR-3755</a>　既存のshardを動的にsplitしてshardを追加するための新コレクションAPI（shard splitting）
　　7.<a href="http://issues.apache.org/jira/browse/SOLR-4530">SOLR-4530</a>　DIH：TikaのIdentityHtmlMapperを使う設定の提供
　　8.<a href="http://issues.apache.org/jira/browse/SOLR-4662">SOLR-4662</a>　solr.xmlにあるSolrCoreの定義よりもディレクトリ構造で見つける。また、solr.xmlのフォーマットを変えて、solrconfig.xmlに近くする。Solrのこのバージョンは旧スタイルの例で提供するが、新しいスタイルも試すことができる。Solr 4.4では、新しいスタイルで提供し、Solr 5.0では旧スタイルは廃止する予定。
　　　<a href="http://issues.apache.org/jira/browse/SOLR-4347">SOLR-4347</a>　Adminハンドラで新しく生成されたコアがsolr.xmlに永続化される
　　　<a href="http://issues.apache.org/jira/browse/SOLR-1905">SOLR-1905</a>　Adminリクエストハンドラで生成されたコアもsolr.xmlに永続化される。また、solr.solr.datadirのようなプロパティの用にsolr.xmlに永続化される問題のfix。
　　9.<a href="http://issues.apache.org/jira/browse/SOLR-4717">SOLR-4717</a>/SOLR-1351　SimpleFacetで同じフィールドに異なるファセットを適用出来るlocalParamsを追加
　　10.<a href="http://issues.apache.org/jira/browse/SOLR-4671">SOLR-4671</a>　CSVResponseWriterのpseudoフィールドのサポート
　　11.<a href="http://issues.apache.org/jira/browse/SOLR-4358">SOLR-4358</a>　HttpSolrServerでuseMultiPartPostでstream名を送信できる
　・Bug Fixes
　　1.<a href="http://issues.apache.org/jira/browse/SOLR-4543">SOLR-4543</a>：solr.xml/solr.propertiesでshardHandlerFactoryの設定が動作しない
　　2.<a href="http://issues.apache.org/jira/browse/SOLR-4634">SOLR-4634</a>：Java 8&quot;Nashorn&quot;JavaScript実装の動作に関するscripting engineのテストのfix
　　3.<a href="http://issues.apache.org/jira/browse/SOLR-4636">SOLR-4636</a>：SolrIndexSearcherをオープンする時に何かの理由でreaderがオープンできない時に、ディレクトリがリリースされない
　　4.<a href="http://issues.apache.org/jira/browse/SOLR-4405">SOLR-4405</a>：Admin UIのadmin-extraファイルでcore-menuが表示されない
　　5.<a href="http://issues.apache.org/jira/browse/SOLR-3956">SOLR-3956</a>：group.facet=trueでfacet.limitがマイナスの時の動作
　　6.<a href="http://issues.apache.org/jira/browse/SOLR-4650">SOLR-4650</a>：copyFieldでダイナミックフィールドや暗黙的なフィールドがsourceでマッチしない。4.2で入ったバグ
　　7.<a href="http://issues.apache.org/jira/browse/SOLR-4641">SOLR-4641</a>：Schemaで、illegalなフィールドパラメータで例外が発生するようにする。
　　8.<a href="http://issues.apache.org/jira/browse/SOLR-3758">SOLR-3758</a>：SpellCheckComponentが分散groupingで動作しない。
　　9.<a href="http://issues.apache.org/jira/browse/SOLR-4652">SOLR-4652</a>：solr.xmlプラグインのresource loaderで共有ライブラリの挙動がおかしい
　　10.<a href="http://issues.apache.org/jira/browse/SOLR-4664">SOLR-4664</a>：ZkStateReaderがaliasを更新しても見えない
　　11.<a href="http://issues.apache.org/jira/browse/SOLR-4682">SOLR-4682</a>：CoreAdminRequest.mergeIndexが複数コアやindexDirが複数の場合にマージできない
　　12.<a href="http://issues.apache.org/jira/browse/SOLR-4581">SOLR-4581</a>：Solr4.2で数値フィールドのファセットでマイナスの値があるとソートがおかしい
　　13.<a href="http://issues.apache.org/jira/browse/SOLR-4699">SOLR-4699</a>：Admin Handlerでデータディレクトリの場所がファイルシステムだと思い込んでる。（RAMの場合もある）
　　14.<a href="http://issues.apache.org/jira/browse/SOLR-4695">SOLR-4695</a>：non-cloudセットアップでもコア管理のSPLITが使えるように
　　15.<a href="http://issues.apache.org/jira/browse/SOLR-4680">SOLR-4680</a>：exampleのspellcheck設定のqueryAnalyzerFieldTypeの修正
　　16.<a href="http://issues.apache.org/jira/browse/SOLR-4702">SOLR-4702</a>：exampleの/browseの「Did you mean?」のサジェストをFix
　　17.<a href="http://issues.apache.org/jira/browse/SOLR-4710">SOLR-4710</a>：Zookeeperから全ノードをアップせずにコレクションを削除できないのを修正
　　18.<a href="http://issues.apache.org/jira/browse/SOLR-4487">SOLR-4487</a>：HttpSolrServerからのSolrExceptionがリモートのサーバから戻るHTTPステータスコードを含んでない
　　19.<a href="http://issues.apache.org/jira/browse/SOLR-4661">SOLR-4661</a>：Admin UIのレプリケーションで現在のレプリカ可能なマスタのバージョンを正確に表示
　　20.<a href="http://issues.apache.org/jira/browse/SOLR-4716">SOLR-4716</a>,<a href="http://issues.apache.org/jira/browse/SOLR-4584">SOLR-4584</a>：SolrCloudリクエストプロキシがTomcatなどJetty出ないコンテナで動作していない
　　21.<a href="http://issues.apache.org/jira/browse/SOLR-4746">SOLR-4746</a>：Distributed groupingのトップレベルグループコマンドでSimpleOrderedMapの代わりにNamedListを使う。non-distributed groupingと出力形式が異なるため。
　　</p>
</content:encoded>
    </item>
    
    <item>
      <title>Lucene 4.3.0のChangesにあるChanges in backwards compatibility policyが気になったので訳してみた。(Jugemより移植)</title>
      <link>https://blog.johtani.info/blog/2013/04/24/lucene-4-3-0%E3%81%AEchanges%E3%81%AB%E3%81%82%E3%82%8Bchanges-in-backwards-compatibility-policy%E3%81%8C%E6%B0%97%E3%81%AB%E3%81%AA%E3%81%A3%E3%81%9F%E3%81%AE%E3%81%A7%E8%A8%B3%E3%81%97%E3%81%A6%E3%81%BF%E3%81%9F/</link>
      <pubDate>Wed, 24 Apr 2013 16:00:00 +0900</pubDate>
      
      <guid>https://blog.johtani.info/blog/2013/04/24/lucene-4-3-0%E3%81%AEchanges%E3%81%AB%E3%81%82%E3%82%8Bchanges-in-backwards-compatibility-policy%E3%81%8C%E6%B0%97%E3%81%AB%E3%81%AA%E3%81%A3%E3%81%9F%E3%81%AE%E3%81%A7%E8%A8%B3%E3%81%97%E3%81%A6%E3%81%BF%E3%81%9F/</guid>
      <description>現在、RC3のVoteをやっている最中（2013/04/24 16:00時点）で、まだリリースされていない、4.3.0についてです。 開発者ML</description>
      <content:encoded><p><span style="color:#FF0000">現在、RC3のVoteをやっている最中（2013/04/24　16:00時点）で、まだリリースされていない、4.3.0についてです。</span>
開発者MLでChangesの書き方を考えないとね、みたいなエントリーが流れてて気になっていたので、訳してみた。
lucene-gosenの実装を変更しないといけないっぽいなぁ。Lucene/Solr 4.2.1以前と4.3.0でI/Fとかが変わることになりそうです。（3.とか8.とか）
（ここで力尽きて、それより下はまだ読んでないです。。。）</p>
<hr>
<p>○Changes in backwards compatibility policy
　　1.<a href="http://issues.apache.org/jira/browse/LUCENE-4810">LUCENE-4810</a>：EdgeNGramTokenFilterが同じ入力tokenから複数のngramを生成した時にpositionを増加させていないのを修正
　　2.<a href="http://issues.apache.org/jira/browse/LUCENE-4822">LUCENE-4822</a>：KeywordMarkerFilterがabstractクラスで、サブクラスがisKeyword()メソッドを実装する必要がある。新しく、SetKeywordTokenFilterというクラスにすでにある機能を分解した。
　　3.<a href="http://issues.apache.org/jira/browse/LUCENE-4642">LUCENE-4642</a>：TokenizerとサブクラスのAttributeSourceのコンストラクタを削除。代わりにAttributeFactoryをもつコンストラクタを追加。
　　4.<a href="http://issues.apache.org/jira/browse/LUCENE-4833">LUCENE-4833</a>：IndexWriterConfigがsetMergePolicy(null)の時にLogByteSizeMergePolicyを使っているのをデフォルトmerge policyをTieredMergePolicyに。また、nullが引数に渡されたらExceptionを返す。
　　5.<a href="http://issues.apache.org/jira/browse/LUCENE-4849">LUCENE-4849</a>：ParallelTaxonomyArraysをDirectoryTaxonomyWriter/Readerのためのabstractとして作成。あと、o.a.l.facet.taxonomyに移動。
　　6.<a href="http://issues.apache.org/jira/browse/LUCENE-4876">LUCENE-4876</a>：IndexDeletionPolicyをInterfaceではなく、abstractクラスに。IndexDeletionPolicy、MergeScheduler、InfoStreamでCloneableをimplement。
　　7.<a href="http://issues.apache.org/jira/browse/LUCENE-4874">LUCENE-4874</a>：FilterAtomicReaderと関連するクラス（FilterTerms、FilterDocsEnumなど）でフィルタされたインスタンスをforwardしないように。メソッドが他のabstractメソッドを実装している場合に。（？）
　　8.<a href="http://issues.apache.org/jira/browse/LUCENE-4642">LUCENE-4642</a>, <a href="http://issues.apache.org/jira/browse/LUCENE-4877">LUCENE-4877</a>：TokenizerFactory、TokenFilterFactory、CharFilterFactoryの実装者は、少なくともMap&lt;String,String&gt;（SPIフレームワーク（Solrとか）によってロードされる）を引数にするコンストラクタを提供する必要がある。さらに、TokenizerFactoryはcreate(AttributeFactory,Reader)メソッドを実装する必要もある。</p>
</content:encoded>
    </item>
    
    <item>
      <title>Partial UpdateとcopyFieldのバグ【Solr 4.0 ALPHA】(Jugemより移植)</title>
      <link>https://blog.johtani.info/blog/2012/07/13/partial-update%E3%81%A8copyfield%E3%81%AE%E3%83%90%E3%82%B0solr-4-0-alpha/</link>
      <pubDate>Fri, 13 Jul 2012 20:02:00 +0900</pubDate>
      
      <guid>https://blog.johtani.info/blog/2012/07/13/partial-update%E3%81%A8copyfield%E3%81%AE%E3%83%90%E3%82%B0solr-4-0-alpha/</guid>
      <description>今日はSolr 4.0 ALPHAの興味深い機能があったので紹介です。 数日前に「Solr 4.0: Partial documents update」という記事を見つけました。 Solrには、</description>
      <content:encoded><p>今日はSolr 4.0 ALPHAの興味深い機能があったので紹介です。
数日前に<a href="http://solr.pl/en/2012/07/09/solr-4-0-partial-documents-update/">「Solr 4.0: Partial documents update」</a>という記事を見つけました。</p>
<p>Solrには、ドキュメント（RDBで言うレコード）のデータを更新したい場合には、特定のフィールドだけを更新するという機能がありませんでした。
ですので、特定の項目（例えば、priceなど）を更新したい場合、ドキュメントの全データをSolrに再度上書き登録するという処理をしなければなりませんでした。
RDBを触っていた方が、Solrを始めた場合に必ず使いづらいと思われる点だと思います。</p>
<p>で、4.0でその機能がありますという、<a href="http://solr.pl/en/2012/07/09/solr-4-0-partial-documents-update/">「Solr 4.0: Partial documents update」</a>の記事を見つけました。
ただ、SolrのWikiや4.0 ALPHAの紹介のページには「partial update」という記述が見当たりません。
（あれ、これかな？<a href="http://wiki.apache.org/solr/Per%20Steffensen/Update%20semantics">Update semantics</a>）
あと、まだ完成していないので、載っていないのかもしれないです。（この<a href="https://issues.apache.org/jira/browse/SOLR-139">チケットSOLR-139</a>が部分更新に関するもののはず。チケット番号をみても古くから望まれている機能だということがわかります。）</p>
<p>ということで、調べてみました。</p>
<p>###機能概要</p>
<hr>
<p>Solrの機能として、特定のフィールドのみを更新するという機能です。
あくまでも、Solrレベルでの機能となり、Luceneの機能を利用したものではありません。
つぎのような流れになっています。</p>
<ol>
<li>Solrに対して特定フィールドを更新したいという形のドキュメントを投げる</li>
<li>Solrはドキュメントを受け取ると、内部のインデックスに保存してあるデータを取り出す</li>
<li>取り出したドキュメントオブジェクトに対して、更新対象フィールドの値だけデータを更新する</li>
<li>ドキュメントオブジェクトをインデックスに保存する</li>
</ol>
<p>このような流れです。
まぁ、言われてみれば当たり前な処理です。
ただし、この機能を使う場合はいくつかの前提条件があります。</p>
<p>###前提条件</p>
<hr>
<p>前提条件はつぎのとおりです。</p>
<ul>
<li>すべてのフィールドをstored=&quot;true&quot;にする</li>
<li>「<em>version</em>」という特殊なフィールドを用意する</li>
</ul>
<p>1点目は、データの保存方法についてです。
先ほど流れに書きましたが、Solrが内部に保存してあるデータを取り出して、更新対象以外のデータを保存しなおしてくれます。
このため、stored=&quot;true&quot;にしておかないと、元のデータがSolr内部で取得できません。</p>
<p>2点目の「<em>version</em>」というフィールドは4.0から導入されたフィールドです。
SolrCloudに必要な機能としてドキュメントのバージョン管理を行うために導入されたフィールドだと思います。（あまり詳しく調べていない。。。）
SolrCloud内でレプリカの更新などに使ってるのかなぁと（そのうち調べます。）
以上の2点が前提条件です。すべてのデータをstored=&quot;true&quot;としなければならない点は、インデックスのサイズや性能に関わってくるので考えて利用するほうがいいかと思います。</p>
<p>###利用方法</p>
<hr>
<p>Solrのサンプルデータ（exampledocs/mem.xml）を例として利用します。
部分更新を行うにはつぎのような形のデータを投げると部分更新が可能です。
（JSONでの更新のサンプルについては、<a href="http://solr.pl/en/2012/07/09/solr-4-0-partial-documents-update/">こちらの記事</a>を参考にしてください。）
####XMLのサンプル（partial_update.xmlというファイルで保存する）</p>
<pre><code>&lt;add&amp;gt;
&lt;doc&amp;gt;
  &lt;field name=&quot;id&quot;&amp;gt;VS1GB400C3&lt;/field&amp;gt;
  &lt;field name=&quot;_version_&quot;&amp;gt;バージョン番号&lt;/field&amp;gt;
  &lt;field name=&quot;cat&quot; update=&quot;add&quot;&amp;gt;cats_and_dogs&lt;/field&amp;gt;
  &lt;field name=&quot;popularity&quot; update=&quot;inc&quot;&amp;gt;10&lt;/field&amp;gt;
  &lt;!-- set empty for SOLR-3502 bug --&amp;gt;
  &lt;field name=&quot;price_c&quot; update=&quot;set&quot;&amp;gt;0.0,USD&lt;/field&amp;gt;
&lt;/doc&amp;gt;
&lt;/add&amp;gt;
</code></pre><p>上記サンプルのうち、<b>バージョン番号</b>の部分は、現在Solrに登録してある値を指定します。（Solrの管理画面で検索すれば表示されます。）
上記ファイルを「SOLR_HOME/example/exampledocs」に保存し、同フォルダにてつぎのコマンドを実行すると、部分更新されるのがわかります。
Solrに更新であるというフィールドがわかるように、fieldタグにupdateという属性を指定してあります。</p>
<pre><code>
java -Durl=http://localhost:8983/solr/update?versions=on -Dout=yes -jar post.jar partial_update.xml
</code></pre><p>ちなみに、上記post.jarのオプションで、「-Durl」「-Dout」を追加してあります。
「-Durl」はverions=onというパラメータを追加したいためです。
「-Dout」はPOSTした結果をターミナルに表示するために追加しています。
これらのオプションを指定すると、データ更新後のバージョンが取得できるようになります。</p>
<p>####更新に利用できるコマンド？
部分更新にはつぎの3つのコマンド？（正式名は不明）が用意されています。fieldタグのupdate属性に指定します。</p>
<table class="list_view">
  <thead>
    <tr>
      <th>コマンド？</th>
      <th>説明</th>
    </tr> 
  </thead>
<tbody>
<tr>
  <td>add</td>
  <td>値を追加します。multiValuedのフィールドでない場合はエラーが出ます。</td>
</tr>
<tr>
  <td>set</td>
  <td>値を新規に登録しなおします。現在入っているデータは無くなります</td>
</tr>
<tr>
<td>inc</td>
<td>指定された数値を加算（数値形式のみ）</td>
</tr>
</tbody>
</table>
以上が、部分更新の機能になります。
ちなみに、登録されているバージョンと更新データに入っているバージョンが異なる場合はエラーが発生する仕組みになっているようです。
<p>それとは別に、この機能を調べていて、copyFieldのバグにぶつかってしまいました。。。
multiValuedでない、copyFieldを利用しているしている場合には注意が必要です。</p>
<p>###copyFieldのバグ（SOLR-3502）</p>
<hr>
<p>4.0-ALPHA（3.6.0でも再現しました。）のexampleのデータで部分更新の機能を確認できると言いました。
ただし、「price_c」というフィールドのせいで、2回部分更新を行うと2回目にエラーが発生します。
根本的な問題は、部分更新ではなく<a href="https://issues.apache.org/jira/browse/SOLR-3502">copyFieldのバグ</a>のようです。（部分更新の処理にも問題は有るような気がしますが。。。）</p>
<p>バグの内容はつぎのとおりです。</p>
<ul>
<li>multiValued=&quot;false&quot;のフィールドをdestに指定</li>
<li>srcに指定されたフィールドに値を設定（exampleのpriceフィールドに「1」を指定）</li>
<li>destに指定されたフィールドに値を設定（exampleのprice_cフィールドに「2,USD」を指定）</li>
</ul>
<p>上記のように設定した場合、「price_c」フィールドに、指定された値＋「price」の値がcopyにより追加されます。
通常は「price_c」フィールドはmultiValued=&quot;false&quot;なのでエラーが出るはずなのですが、エラーが発生せず2つの値が登録されてしまいます。</p>
<p>このバグのため、exampleのデータを利用して部分更新を行うとつぎのような状態が発生します。
更新を行う対象のデータはprice、price_cフィールド以外のフィールドとします。</p>
<ul>
<li>1回目の登録後：priceフィールド「&ldquo;185.0&rdquo;」、price_cフィールド「&ldquo;185.0,USD&rdquo;」</li>
<li>2回目の登録後：priceフィールド「&ldquo;185.0&rdquo;」、price_cフィールド「[&ldquo;185.0,USD&rdquo;,&ldquo;185.0,USD&rdquo;]」</li>
<li>3回目の登録：エラーが発生</li>
</ul>
<p>部分更新の処理で、すでに登録済みのデータをSolrが自動で取り出すため、2回目の登録処理にて「price_c」の登録済みの値がSolrから取り出され、さらにcopyField設定により、「price」の値が追加されます。
本当は2回目の登録でエラーが発生すべきなのですが、バグのためエラーが発生せずに登録できてしまいます。
部分更新の処理としては、copyフィールドのdestに指定されているフィールドの値を取り出さないほうがいいような気もしますが、きちんと考えてないのでなんとも言えないです。（制約事項とする形のほうがいいかもしれません）</p>
</content:encoded>
    </item>
    
    <item>
      <title>autoGeneratePhraseQueriesのデフォルト値について(Jugemより移植)</title>
      <link>https://blog.johtani.info/blog/2012/06/14/autogeneratephrasequeries%E3%81%AE%E3%83%87%E3%83%95%E3%82%A9%E3%83%AB%E3%83%88%E5%80%A4%E3%81%AB%E3%81%A4%E3%81%84%E3%81%A6/</link>
      <pubDate>Thu, 14 Jun 2012 01:09:00 +0900</pubDate>
      
      <guid>https://blog.johtani.info/blog/2012/06/14/autogeneratephrasequeries%E3%81%AE%E3%83%87%E3%83%95%E3%82%A9%E3%83%AB%E3%83%88%E5%80%A4%E3%81%AB%E3%81%A4%E3%81%84%E3%81%A6/</guid>
      <description>久々にSolrの話です。 といっても、結構前からの話でして。。。 schema.xmlのfieldTypeの設定に「autoGeneratePh</description>
      <content:encoded><p>久々にSolrの話です。
といっても、結構前からの話でして。。。</p>
<p>schema.xmlのfieldTypeの設定に「autoGeneratePhraseQueries」という属性があります。
Solr3.1で導入されました。動作に関しては<a href="http://lucene.jugem.jp/?eid=403">関口さんのブログ</a>で説明されています。
Solr 1.4までは、Analyzerがトークンを複数返してくる場合（例：lucene-gosenで「Solr入門」という文字列を入れた場合など）にフレーズクエリとして処理していました。
Lucene 3.1.0から、この処理がデフォルトfalse（つまり、フレーズクエリにならない）という挙動になりました。（詳しくは<a href="http://lucene.jugem.jp/?eid=403">関口さんのブログ</a>で。）
ただ、Solr 3.1.0では、下位互換性を考慮して、autoGeneratePhraseQueriesの設定値はデフォルトが「true」でした。</p>
<p>このデフォルト値がSolr 3.3以降で提供されているschemaのバージョン（1.4以上）からデフォルト値が「false」に変更されています。
schemaのバージョンを1.3以前のものから1.4以上に移行する場合は注意が必要です。</p>
<p>とまぁ、偉そうに書きましたが、私もちゃんと追えてませんでした。
Solr勉強会第６回で、<a href="http://www.slideshare.net/KojiSekiguchi/lu-solr32-3420110912">関口さんの発表</a>できちんと説明されていて、参加してたのに聞けてなかったですし。（<a href="http://johtani.jugem.jp/?eid=26">メモ取ってるのに、書いてない。</a>）</p>
<p>ということで、Solr入門のサンプルschemaも少し修正しました。
<a href="http://johtani.jugem.jp/?eid=76">こちら</a>と<a href="http://johtani.jugem.jp/?eid=76">こちら</a>の記事に追記してありますので、参考にしてください。</p>
</content:encoded>
    </item>
    
    <item>
      <title>Solr 3.6.0のCJKの設定とSynonymFilterFactoryの気になる点(Jugemより移植)</title>
      <link>https://blog.johtani.info/blog/2012/04/17/solr-3-6-0%E3%81%AEcjk%E3%81%AE%E8%A8%AD%E5%AE%9A%E3%81%A8synonymfilterfactory%E3%81%AE%E6%B0%97%E3%81%AB%E3%81%AA%E3%82%8B%E7%82%B9/</link>
      <pubDate>Tue, 17 Apr 2012 01:16:11 +0900</pubDate>
      
      <guid>https://blog.johtani.info/blog/2012/04/17/solr-3-6-0%E3%81%AEcjk%E3%81%AE%E8%A8%AD%E5%AE%9A%E3%81%A8synonymfilterfactory%E3%81%AE%E6%B0%97%E3%81%AB%E3%81%AA%E3%82%8B%E7%82%B9/</guid>
      <description>先日、Solr入門のサンプルschema.xmlの3.6.0対応版の作成をしていて、気になったことがあったので、 メモとして残しておきます。 S</description>
      <content:encoded><p>先日、Solr入門のサンプルschema.xmlの3.6.0対応版の作成をしていて、気になったことがあったので、
メモとして残しておきます。</p>
<p>SynonymFilterFactoryの属性「<span style="color:#FF0000">tokenizerFactory</span>」に関連する話です。
（<a href="http://www.amazon.co.jp/exec/obidos/ASIN/4774141755/johtani-22/ref=nosim/">「Apache Solr入門」</a>の36-37ページに記載があります。）</p>
<p>SynonymFilterFactoryでは、類義語設定ファイルを読み込む際に利用するTokenizerFactoryを「tokenizerFactory」という属性で指定できます。（以下は書籍の記述を抜粋）</p>
<pre><code>
  &lt;filter class=&quot;sold.SynonymFilterFactory&quot; synonyms=&quot;synonyms.txt&quot; ... tokenizerFactory=&quot;solrbook.analysis.SenTokenizerFactory&quot;/&gt;
</code></pre><p>このように、TokenizerFactoryが指定できます。</p>
<p>ただ、<a href="http://johtani.jugem.jp/?eid=76">こちらの記事</a>で書いたように、
Solr 3.6.0のexampleのschema.xmlではCJKのフィールドは次のように設定されています。</p>
<pre><code>
    &lt;!-- CJK bigram (see text_ja for a Japanese configuration using morphological analysis) --&gt;
    &lt;fieldType name=&quot;text_cjk&quot; class=&quot;solr.TextField&quot; positionIncrementGap=&quot;100&quot;&gt;
      &lt;analyzer&gt;
        &lt;tokenizer class=&quot;solr.StandardTokenizerFactory&quot;/&gt;
        &lt;!-- normalize width before bigram, as e.g. half-width dakuten combine  --&gt;
        &lt;filter class=&quot;solr.CJKWidthFilterFactory&quot;/&gt;
        &lt;!-- for any non-CJK --&gt;
        &lt;filter class=&quot;solr.LowerCaseFilterFactory&quot;/&gt;
        &lt;filter class=&quot;solr.CJKBigramFilterFactory&quot;/&gt;
      &lt;/analyzer&gt;
    &lt;/fieldType&gt;
</code></pre><p>3.6.0以前は、solr.CJKTokenizerFactoryを利用していましたが、3.6.0からはCJKTokenizerFactoryがdeprecatedになってしまい、代わりにStandardTokenizerFactory＋CJKBigramFilterFactoryの組み合わせになっています。
exampleのCJKのフィールドタイプ設定を利用して、かつ、そのフィールドにSynonymFilterを利用する場合に、
StandardTokenizerFactoryを指定してしまうと、類義語が展開できなくなってしまうので注意が必要です。</p>
<p>CJKのフィールドでSynonymFilterを利用する場合は、類義語の設定ファイル内の記述を自力でCJKTokenizerが分割する形で記述する（まぁ、やらないでしょうが）か、deprecatedですが、CJKTokenizerFactoryを利用するのが現時点での対応でしょうか。</p>
<p>なお、これに絡んで、<a href="https://issues.apache.org/jira/browse/SOLR-3359">このようなチケット</a>もできています。</p>
<h5 id="syntaxhighlighterを導入してみました">SyntaxHighlighterを導入してみました。</h5>
<h5 id="ちょっとはみやすくなってますかね">ちょっとはみやすくなってますかね？</h5>
<h5 id="まだsyntaxhighlighterの設定を調べながら使っているのでコロコロ変わるかもしれないですが気にしないでください">まだ、SyntaxHighlighterの設定を調べながら使っているので、コロコロ変わるかもしれないですが、気にしないでください。</h5>
</content:encoded>
    </item>
    
    <item>
      <title>「Apache Solr入門」のサンプルのKuromojiとlucene-gosen対応（2章～4章）(Jugemより移植)</title>
      <link>https://blog.johtani.info/blog/2012/04/14/apache-solr%E5%85%A5%E9%96%80%E3%81%AE%E3%82%B5%E3%83%B3%E3%83%97%E3%83%AB%E3%81%AEkuromoji%E3%81%A8lucene-gosen%E5%AF%BE%E5%BF%9C2%E7%AB%A04%E7%AB%A0/</link>
      <pubDate>Sat, 14 Apr 2012 02:58:00 +0900</pubDate>
      
      <guid>https://blog.johtani.info/blog/2012/04/14/apache-solr%E5%85%A5%E9%96%80%E3%81%AE%E3%82%B5%E3%83%B3%E3%83%97%E3%83%AB%E3%81%AEkuromoji%E3%81%A8lucene-gosen%E5%AF%BE%E5%BF%9C2%E7%AB%A04%E7%AB%A0/</guid>
      <description>先日の続きです。「Apache Solr入門」の2章から4章の説明について、Solr3.6.0で動作させる時の変更点を以下に書いていきます。 な</description>
      <content:encoded><p>先日の続きです。「Apache Solr入門」の2章から4章の説明について、Solr3.6.0で動作させる時の変更点を以下に書いていきます。
なお、前回も説明しましたが、3.6.0からKuromojiという形態素解析器がSolrに同梱されるようになりました。
これから説明する2章の変更点の手順ですが、Kuromojiとlucene-gosenそれぞれの利用方法について説明します。
添付のschema.xmlについては、基本的にKuromojiを利用する形に変更してあります。
それに加えて、lucene-gosen用のフィールドを別途追加で定義しました。
これらのフィールド名については、次の表の用になります。
適宜、書籍のフィールド名と置き換えながら読み進めたり、試したりしてください。</p>
<table class="list_view">
  <thead>
    <tr>
      <th>Kuromojiフィールド</th>
      <th>lucene-gosenフィールド</th>
    </tr> 
  </thead>
<tbody>
<tr>
  <td>title</td>
  <td>title_gosen</td>
</tr>
<tr>
  <td>author</td>
  <td>auther_gosen</td>
</tr>
<tr>
  <td>summary</td>
  <td>summary_gosen</td>
</tr>
<tr>
  <td>intended_reader</td>
  <td>intended_reader_gosen</td>
</tr>
<tr>
  <td>from_author</td>
  <td>from_author_gosen</td>
</tr>
<tr>
  <td>toc</td>
  <td>toc_gosen</td>
</tr>
</tbody>
</table>
<h2 id="2章">2章</h2>
<h3 id="213-schemaxmlのバージョン27ページ">2.1.3 schema.xmlのバージョン（27ページ）</h3>
<p>Solr3.xではschema.xmlのファイルの最新バージョンは<strong>1.<span style="color:#FF0000">5</span></strong>になっています。</p>
<h3 id="223-代表的なトークナイザ35ページ">2.2.3 代表的なトークナイザ（35ページ）</h3>
<p>solrbook.analysis.SenTokenizerFactoryは必要ありません。
<span style="color:#FF0000">Solr 3.6.0からはKuromojiと呼ばれる形態素解析器が用意されています。
solr.JapaneseTokenizerFactoryがそれに該当します。
</span>
これとは別に、lucene-gosenを利用する場合、Solr向けのトークナイザが用意されています。
solr.<span style="color:#FF0000">Gosen</span>TokenizerFactoryがそれに該当します。</p>
<h3 id="224-代表的なトークンフィルタ37ページ">2.2.4 代表的なトークンフィルタ（37ページ）</h3>
<p>以下の2つについては<span style="color:#FF0000">Kuromojiが同等のトークンフィルタを提供しています。</span>
また、lucene-gosenを利用する場合は、lucene-gosenに同等のトークンフィルタが存在します。</p>
<ul>
<li>solrbook.analysis.KatakanaStemFilterFactory</li>
<li>solrbook.analysis.POSFilterFactory</li>
</ul>
<p><span style="color:#FF0000">次のものがSolr 3.6.0に用意されているので、こちらを利用します。</span></p>
<ul>
<li>solr.JapaneseKatakanaStemFilterFactory</li>
<li>solr.JapanesePartOfSpeechStopFilterFactory</li>
</ul>
<p>それぞれ、次のものがlucene-gosenにあるので、こちらを利用します。</p>
<ul>
<li>solr.<span style="color:#FF0000">Gosen</span>KatakanaStemFilterFactory</li>
<li>solr.<span style="color:#FF0000">Gosen</span>PartOfSpeechStopFilterFactory</li>
</ul>
<p>2章向けの<a href="https://bitbucket.org/johtani/solrbook-lucene-gosen-3.x/raw/48834b2d0465/schema/schema.xml">schema.xmlはこちら</a>です。その他のtxtファイルについては、特に変更はありません。</p>
<p>3,4章は特に変更はありません。Solrの起動の仕方にだけ注意してください。（-Dsen.homeは必要ありません）</p>
<p>以上が4章までの修正点になります。</p>
<p>昨日に引き続き、眠い目をこすりながら修正したので、おかしいかも。
動かない、意味がわからないなどあれば、コメントorツイートいただければと思います。</p>
<p><span style="color:#FF0000">2012/06/14提供しているschema.xmlに関して修正を加えました。</span><a href="http://johtani.jugem.jp/?eid=92">こちらの記事</a>で説明しているautoGeneratePhraseQueriesの値をtext_gosen、text_cjkのフィールドに対してtrueを設定する記述を追記しました。</p>
</content:encoded>
    </item>
    
    <item>
      <title>Lucene/Solr 3.6.0リリース / 「Apache Solr入門」のサンプルのKuromojiとlucene-gosen対応（1章）(Jugemより移植)</title>
      <link>https://blog.johtani.info/blog/2012/04/14/lucene-solr-3-6-0%E3%83%AA%E3%83%AA%E3%83%BC%E3%82%B9-apache-solr%E5%85%A5%E9%96%80%E3%81%AE%E3%82%B5%E3%83%B3%E3%83%97%E3%83%AB%E3%81%AEkuromoji%E3%81%A8lucene-gosen%E5%AF%BE%E5%BF%9C1%E7%AB%A0/</link>
      <pubDate>Sat, 14 Apr 2012 02:45:00 +0900</pubDate>
      
      <guid>https://blog.johtani.info/blog/2012/04/14/lucene-solr-3-6-0%E3%83%AA%E3%83%AA%E3%83%BC%E3%82%B9-apache-solr%E5%85%A5%E9%96%80%E3%81%AE%E3%82%B5%E3%83%B3%E3%83%97%E3%83%AB%E3%81%AEkuromoji%E3%81%A8lucene-gosen%E5%AF%BE%E5%BF%9C1%E7%AB%A0/</guid>
      <description>以前より、アナウンスしていた、Kuromojiという日本語形態素解析が含まれるLucene/Solr 3.6.0がリリースされました。 以下、各</description>
      <content:encoded><p>以前より、アナウンスしていた、Kuromojiという日本語形態素解析が含まれるLucene/Solr 3.6.0がリリースされました。</p>
<p>以下、各リリース内容について簡単に説明されているページへのリンクです。</p>
<p><a href="http://lucene.apache.org/solr/solrnews.html">Solrリリースのお知らせ</a></p>
<p><a href="http://lucene.apache.org/core/corenews.html">Luceneリリースのお知らせ</a></p>
<p>Solr 3.6.0の変更の目玉は各言語のAnalyzer/Tokenizerの設定がexampleのschema.xmlに含まれるようになったことです。
Kuromojiという日本語用の形態素解析器もexampleを起動すればすぐに利用できる形になっています。
Kuromojiを利用する場合は、exampleのschema.xmlが参考になるでしょう。</p>
<p>あと、大きな変更は、Ivyに対応した点です。ソースをダウンロードするとわかりますが、依存するjarファイルが含まれない形に変更されています。
SVNからチェックアウトした場合も同様です。ビルドにはネットワークに接続している環境が必要になりました。</p>
<p>また、このリリースに合わせて、以前書いた「Apache Solr入門」のサンプルについての記事も変更が必要かと思い、
前回の記事をベースに以下に変更した記事を書いたので、参考にしてください。
今回は、Kuromojiという日本語形態素解析がデフォルトで含まれるようになったので、
Kuromojiの利用方法とあわせて、lucene-gosenの利用方法も記載します。
サンプルのschema.xmlについては、Kuromoji、lucene-gosenが同時に利用できる形のものを用意しました。</p>
<hr>
<p>サンプルのschema.xmlを最新版（Solr 3.6 + lucene-gosen-2.0.0-ipadic）のものを用意しました。
なお、あくまでも、3.xでlucene-gosenを利用する場合の「Apache Solr入門」のサンプルプログラムの変更点（とりあえず、4章まで）の違いについて記述します。
申し訳ございませんが、1.4と3.xの違いについての説明はここでは行いません。</p>
<p>以下では、各章でschema.xmlに関連する記載のある部分を抜粋して、変更点と変更したschema.xmlのリンクを用意しました。参考にしてもらえればと思います。</p>
<h2 id="1章">1章</h2>
<h3 id="161-n-gram17ページ">1.6.1 N-gram（17ページ）</h3>
<p>1.6.1の手順に変更はありません。
サンプルプログラムが入っているZip「solrbook.zip」のintroduction/ngram/schema.xmlファイルの代わりに
<a href="https://bitbucket.org/johtani/solrbook-lucene-gosen-3.x/raw/48834b2d0465/introduction/ngram/schema.xml">こちらのschema.xml</a>を利用してください。
<span style="color:#FF0000">※なお、Solr 3.6.0から、SOLR_HOME/example/solr/conf/schema.xmlにデフォルトでN-gramで利用しているCJKTokenizerの設定が入るようになっています。
（実際にはCJKTokenizerではなく、CJKBigramFilterとCJKWidthFilterに変更されています。）</span></p>
<h3 id="162-形態素解析18ページ20ページ中盤まで">1.6.2 形態素解析（18ページ～20ページ中盤まで）</h3>
<p><span style="color:#FF0000">CJKと同様、exampleにKuromojiを利用した設定がすでに記述されています。text_jaというフィールドタイプになります。書籍の21ページ1行目に記載のある、
「Field」のテキストボックスに入力する文字列を「text_ja」とすると、Kuromojiを利用した形態素解析結果が表示されます。exampleですでに幾つかのフィルタも設定されているため、書籍の出力結果とは異なる表示となるはずです。</span></p>
<p>lucene-gosenを利用する場合は手順が大きく変わります。
Senを利用する場合、Senの辞書のビルド、Senのjarファイルの配置、Senを利用するためのTokenizerクラスを含んだサンプルjarの配置という作業があります。
lucene-gosenではコンパイル済みの辞書がjarファイルに含まれています。
また、Solr向けのTokenizerもlucene-gosenのjarファイルに含まれています。
lucene-gosenを利用して形態素解析を体験するための手順は次の流れになります。
なお、schema.xmlについては上記N-gramでダウンロードしたschema.xmlに形態素解析の設定もあわせて記載してあります。</p>
<p>jarファイル（<a href="http://lucene-gosen.googlecode.com/files/lucene-gosen-2.0.0-ipadic.jar">lucene-gosen-2.0.0-ipadic.jar</a>）をダウンロードして、$SOLR/example/solr/lib（libディレクトリがない場合は作成）にコピーします。
コピーが終わりましたら、次のように$SOLR/exampleディレクトリでSolrを起動します。
（-Dsen.homeは必要なし）</p>
<pre><code>
$ java -jar start.jar
</code></pre><p>あとは、書籍の記述にしたがって管理画面のAnalysis画面で動作を確認します。
ほぼ、図1-6と同じ結果になっていると思います。
（lucene-gosenで出力される情報には本書のサンプルよりも多くの情報が含まれています。また、サンプルでは、形態素解析の後の単語に基本形を採用しているため、「な」が「だ」として出力されています。基本形を出力する場合は後述するこちらで紹介したTokenFilterを利用すれば可能です。）</p>
<p>2章については後日説明することにします（眠くなってきた。。。）</p>
<p>動作しないなどあれば、コメントください。</p>
<p><span style="color:#FF0000">2012/06/14追記提供しているschema.xmlに関して修正を加えました。</span><a href="http://johtani.jugem.jp/?eid=92">こちらの記事</a>で説明しているautoGeneratePhraseQueriesの値をtext_gosen、text_cjkのフィールドに対してtrueを設定する記述を追記しました。</p>
</content:encoded>
    </item>
    
    <item>
      <title>Lucene Eurocon 2011 Barcelona のスライド読みました(Jugemより移植)</title>
      <link>https://blog.johtani.info/blog/2011/11/08/lucene-eurocon-2011-barcelona-%E3%81%AE%E3%82%B9%E3%83%A9%E3%82%A4%E3%83%89%E8%AA%AD%E3%81%BF%E3%81%BE%E3%81%97%E3%81%9F/</link>
      <pubDate>Tue, 08 Nov 2011 13:02:00 +0900</pubDate>
      
      <guid>https://blog.johtani.info/blog/2011/11/08/lucene-eurocon-2011-barcelona-%E3%81%AE%E3%82%B9%E3%83%A9%E3%82%A4%E3%83%89%E8%AA%AD%E3%81%BF%E3%81%BE%E3%81%97%E3%81%9F/</guid>
      <description>最近忘れやすいので、記録しておこうかと。 読んだスライドの簡単な内容と感想です。 ちなみに、スライドの一覧はこちらです。 ※スライドへのリンクはす</description>
      <content:encoded><p>最近忘れやすいので、記録しておこうかと。
読んだスライドの簡単な内容と感想です。
ちなみに、スライドの一覧はこちらです。
<span style="color:#FF0000">※スライドへのリンクはすべてPDFへのリンクになっていますので、注意が必要です。</span></p>
<hr>
<p><a href="http://www.lucidimagination.com/sites/default/files/file/Eurocon2011/miller_solr4highlights2_eurocon2011.pdf"><em>**Solr 4 Highlights（PDF）**</em></a></p>
<p>Solrの次期バージョン4.0で採用される機能の紹介でした。
紹介されているのは次の機能。各機能について、JIRAの番号も記載があるので便利ですね。</p>
<ul>
<li>DirectSolrSpellChecker</li>
<li>NRT (<a href="http://wiki.apache.org/solr/NearRealtimeSearch">Near RealTime search</a>)</li>
<li>Realtime Get</li>
<li>SolrCloud - search side</li>
<li>SolrCloud - indexing side (WIP)</li>
</ul>
<p>これまでと異なるSpellChecker、Commit前のデータが検索できるNRT（なんでNRSじゃないんだろう？）、Commit前の登録済みデータを取得することが出来るRealtime Getなどの簡単な紹介です。
あと、個人的に興味のあるSolrCloud周りが絵付きで紹介されてます。ZooKeeperもちょっと出てきます。
まだ、ちゃんとまとめてないですが、NewSolrCloudDesignの翻訳したものも参考までに。（<a href="http://johtani.jugem.jp/?eid=31">その１</a>、<a href="http://johtani.jugem.jp/?eid=32">その２</a>）</p>
<hr>
<p><strong><em><a href="http://www.lucidimagination.com/sites/default/files/file/Eurocon2011/Binns_archiveit_eurocon2011.pdf">Archive-It: Scaling Beyond a Billion Archival Web-pages</a></em></strong></p>
<p>InternetArchiveの事例紹介。1996年からWebページのアーカイブを行なっているサイトですね。
その一部でSolrが利用されています。
「1,375,473,187 unique documents」との記述もあり、データ量が巨大です。
データ量が多いのに、ここでFieldCollapsing/Groupingも利用しているようで、インデックス作成、検索両方に対してカスタマイズしたものをgithubで公開している模様です。</p>
<hr>
[<em>**Scaling search at Trovit with Solr and Hadoop**</em>](http://www.lucidimagination.com/sites/default/files/file/Eurocon2011/MarcSturlese_scalingsearchTrovit_eurocon2011.pdf)
<p>次は、Trovitという会社のSolr＋Hadoopの事例紹介です。
最初はLuceneをベースに検索サーバ作ってたけど、Solrが出てきたので、Solrを使うようになったようで。
データ保存先として最初はMySQLを利用してDataImportHandlerでSolrにデータ登録してたけど、
データ量が増加するが、MySQLのShardingが面倒なので、Hadoop（Hive）でデータをパイプライン処理してSolrのインデックスを作成しましょうという流れになったようです。
私が以前、<a href="http://www.slideshare.net/nabeta/ss-8118052">Solr勉強会で紹介したSOLR-1301</a>のパッチをベースにMap/Reduceの処理を2段階にして性能をアップさせたという話が記載されてました。
ただ、これで早くなるのかはよくわからないんですが。。。
一応、資料では、いきなり大きなSolrのインデックスを作らずに、最初のM/Rで小さなインデックスを作成し（TaskTrackerの数＞＞Solrのshardサーバ数だから小さくしたほうが速い？）、
2段目のM/Rでインデックスをマージしてshardサーバ数のインデックスに集約する？という形みたいです。
（英語力のなさが。。。）
あとは、テキスト処理を幾つかHadoopでやってますよという紹介でした。
SOLR-1301の利用者が他にもいて、違うアプローチをとっていたのが印象的。
毎回全データインデックス生成するときは、SOLR-1301を利用してshard数が増えてもすぐに対応が可能になるので、
かなり便利ですよ。</p>
<hr>
<p><a href="http://www.lucidimagination.com/sites/default/files/file/Eurocon2011/Gio_Kincade-Solr_Etsy_eurocon2011.pdf"><em><strong>Solr @ Etsy</strong></em></a></p>
<p>Etsyは個人の作家（編み物とかシールとか）の方が出店するためのショッピングモールのようなサイトです。
実は、最近、MacBookAirのステッカーを購入したのがここでした。
で、検索にSolrを使っています。
面白いのが、検索サーバとWebアプリ（PHPで書かれている）の間のデータのやり取りにThriftを利用していること。
Solrの前にThriftを話すサーバを別途用意しているようです。ネットワークのデータ量を減らすことが目的らしいです。
そのあとは、少しThriftのサーバでのLoadBalancingの話が続きます。
次にレプリケーションの性能問題のはなし。定期的にレプリケーションに異様に時間がかかるのが問題になったようで、
Multicast-Rsyncを試してみたけどダメでしたというはなし。
Bit Torrent + Solrという組み合わせで回避したらしいのですが、いまいち仕組みがわからなかったです。。。
こちらもgithubに公開されている模様。
あとは、QParser、Stemmerをカスタマイズしたものの話です。</p>
<hr>
<p><a href="http://www.lucidimagination.com/sites/default/files/file/Eurocon2011/Baldeschwieler_HortonWorks_LuceneEurocon20111018.pdf"><strong><em>Architecting the Future of Big Data and Search</em></strong></a></p>
<p>LuceneのカンファレンスにHortonworksが出てきてびっくりしました。
まぁ、Luceneの生みの親＝Hadoopの生みの親ですから、問題ないのかもしれないですが。
大半が予想通り、Hadoopに関する話でした。
知らないApacheのプロジェクト「<a href="http://incubator.apache.org/ambari/">Ambari</a>」というのが出てきました。これは、HadoopConferenceJapan2011 Fallでの発表にもチラッと出てきたようです。
「Ambari is a monitoring, administration and lifecycle management project for Apache Hadoop clusters.」ということで、Hadoopクラスタの統合管理のツールになるんでしょうか？
最後の2枚くらいにLuceneが出てきます。絡めてみたって感じですかね。</p>
<hr>
<p><a href="http://www.lucidimagination.com/sites/default/files/file/Eurocon2011/scholten_Configuring_Mahout_Clustering_Jobs_Eurocon2011.pdf"><em><strong>Configuring mahout Clustering Jobs</strong></em></a></p>
<p>今度はMahoutが出てきました。はやりのものが満載です。
まぁ、MahoutもLuceneのインデックスを利用するという話もありますので。
スライドはクラスタリングとはどういうものか、Mahoutの説明とテキストクラスタリング処理のお話、最後はstuckoverflowでのMahoutとSolrの活用の仕方について。</p>
<hr>
<p>ということで、英語力がない中、かなり流し読みな感じですが、あとで思い出すために書きだして見ました。
何かの役に立てれば幸いです。</p>
<p>他に、こんなスライドが面白かったとか、このスライドについても書いてほしいなどあれば、コメントください。</p>
</content:encoded>
    </item>
    
    <item>
      <title>Solrの新しい管理画面（Solr4.x trunk系）(Jugemより移植)</title>
      <link>https://blog.johtani.info/blog/2011/10/05/solr%E3%81%AE%E6%96%B0%E3%81%97%E3%81%84%E7%AE%A1%E7%90%86%E7%94%BB%E9%9D%A2solr4-x-trunk%E7%B3%BB/</link>
      <pubDate>Wed, 05 Oct 2011 19:43:00 +0900</pubDate>
      
      <guid>https://blog.johtani.info/blog/2011/10/05/solr%E3%81%AE%E6%96%B0%E3%81%97%E3%81%84%E7%AE%A1%E7%90%86%E7%94%BB%E9%9D%A2solr4-x-trunk%E7%B3%BB/</guid>
      <description>Lucene/SolrのMLでSolrの管理画面を新しくするというチケットが流れていたのでちょっと触って見ました。 ほんとにちょっと触っただけ</description>
      <content:encoded><p>Lucene/SolrのMLでSolrの管理画面を新しくするというチケットが流れていたのでちょっと触って見ました。
ほんとにちょっと触っただけですが、いくつかキャプチャ撮ってみたので、アップしときます。
※以下ではサムネイル画像に元画像（100Kくらいの画像）へのリンクが設定されています。携帯などでは見づらいかもしれませんが、ご容赦を。</p>
<p>URLは旧管理画面とことなり、http://localhost:8983/solr/になります。</p>
<hr>

<link rel="stylesheet" href="/css/hugo-easy-gallery.css" />
<div class="box" >
  <figure  itemprop="associatedMedia" itemscope itemtype="http://schema.org/ImageObject">
    <div class="img">
      <img itemprop="thumbnail" src="/images/entries/20111005/20111005_2075207.jpg" alt="新管理画面：トップ画面"/>
    </div>
    <a href="/images/entries/20111005/20111005_2075207.jpg" itemprop="contentUrl"></a>
  </figure>
</div>
まずはトップ画面
ダッシュボードと呼ばれるトップ画面。メモリの利用率や起動してからの時間、Luceneなどのバージョンが表示されます。<br style="clear:both" />
<br style="clear">
<hr>


<div class="box" >
  <figure  itemprop="associatedMedia" itemscope itemtype="http://schema.org/ImageObject">
    <div class="img">
      <img itemprop="thumbnail" src="/images/entries/20111005/20111005_2075141.png" alt="新管理画面：クエリ実行結果"/>
    </div>
    <a href="/images/entries/20111005/20111005_2075141.png" itemprop="contentUrl"></a>
  </figure>
</div>
次は検索画面すっきりしてます。facetが指定できるようになったのは大きいかな。ただし、facet.fieldを複数指定などができないが。結果についてはとくに指定がなければXMLで帰ってきます。ただ、パラメータの追加ができなくなってる気がするなぁ<br style="clear:both" />
<br style="clear"/>
<hr>


<div class="box" >
  <figure  itemprop="associatedMedia" itemscope itemtype="http://schema.org/ImageObject">
    <div class="img">
      <img itemprop="thumbnail" src="/images/entries/20111005/20111005_2075230.png" alt="新管理画面：クエリ接続エラー"/>
    </div>
    <a href="/images/entries/20111005/20111005_2075230.png" itemprop="contentUrl"></a>
  </figure>
</div>
ちなみに、Solrを止めて検索したらこんな感じの画面になりました。クエリの実行ならこのようにエラーがわかったのですが、停止後に左のメニューにあるSchemaなどをクリックしても白い画面が出るだけで、エラーかどうかがわかりにくいです。<br style="clear:both" />
<br style="clear"/>
<hr>


<div class="box" >
  <figure  itemprop="associatedMedia" itemscope itemtype="http://schema.org/ImageObject">
    <div class="img">
      <img itemprop="thumbnail" src="/images/entries/20111005/20111005_2075122.png" alt="新管理画面：Analysisのサンプル（lucene-gosen）"/>
    </div>
    <a href="/images/entries/20111005/20111005_2075122.png" itemprop="contentUrl"></a>
  </figure>
</div>
Analysis画面。入力画面がシンプルになりました。フィールド名はリストで表示されるので選択するだけです。あとは、これまでどおり。サンプルはlucene-gosenの解析結果です。ハイライトもきちんと表示されます。ただし、長い文章の場合は結果部分だけがスクロールできる形になり、ちょっとわかりにくかったです。<br style="clear:both" />
<br style="clear"/>
<hr>


<div class="box" >
  <figure  itemprop="associatedMedia" itemscope itemtype="http://schema.org/ImageObject">
    <div class="img">
      <img itemprop="thumbnail" src="/images/entries/20111005/20111005_2075142.png" alt="新管理画面：Analysis失敗"/>
    </div>
    <a href="/images/entries/20111005/20111005_2075142.png" itemprop="contentUrl"></a>
  </figure>
</div>
Analysisの入力画面を表示したあとにSolrを停止して解析してみたらこんなエラー画面が出ました。ちなみに、その後、画面を切り替えずにSolrを起動して解析したら、赤い帯のエラーは出たままでした。一度別画面にすれば、元に戻りますが。<br style="clear:both" />
<br style="clear"/>
<hr>


<div class="box" >
  <figure  itemprop="associatedMedia" itemscope itemtype="http://schema.org/ImageObject">
    <div class="img">
      <img itemprop="thumbnail" src="/images/entries/20111005/20111005_2075140.png" alt="新管理画面：キャッシュの状態確認"/>
    </div>
    <a href="/images/entries/20111005/20111005_2075140.png" itemprop="contentUrl"></a>
  </figure>
</div>
Pluginsの画面（旧管理画面のstatisticsに相当）。
キャッシュの状態が確認できます。今まであった画面と情報的には一緒かと。一段カテゴリ（CACHEとかCOREとか）の選択ができるようになり、見やすくなりました。
<br style="clear:both" />
<br style="clear"/>
<hr>


<div class="box" >
  <figure  itemprop="associatedMedia" itemscope itemtype="http://schema.org/ImageObject">
    <div class="img">
      <img itemprop="thumbnail" src="/images/entries/20111005/20111005_2075143.png" alt="新管理画面：updatehandlerの状態。ドキュメント数とか"/>
    </div>
    <a href="/images/entries/20111005/20111005_2075143.png" itemprop="contentUrl"></a>
  </figure>
</div>
同じくPluginsの画面。
こちらはupdateHandlerについての情報です。commit数やoptimizeの回数、updateして、commitする前の状態のドキュメント数などが表示されます。前より表示される項目が多くなってるかな？<br style="clear:both" />
<br style="clear"/>
<hr>


<div class="box" >
  <figure  itemprop="associatedMedia" itemscope itemtype="http://schema.org/ImageObject">
    <div class="img">
      <img itemprop="thumbnail" src="/images/entries/20111005/20111005_2075208.jpg" alt="新管理画面：スキーマブラウザ"/>
    </div>
    <a href="/images/entries/20111005/20111005_2075208.jpg" itemprop="contentUrl"></a>
  </figure>
</div>
最後はスキーマブラウザこの画面が一番良くなっています。旧管理画面では、フィールド名がすべて大文字で表示され、しかもソートがされていない状態だったため、ダイナミックフィールドを利用しているとフィールドを探すのが一苦労でした。
今回は、プルダウンでフィールドやフィールドタイプのリストが表示され、辞書順で並んでいます。Filterなどもわかりやすい表示になっているかと。
<br style="clear:both" />
<br style="clear"/>
<hr>
おまけ


<div class="box" >
  <figure  itemprop="associatedMedia" itemscope itemtype="http://schema.org/ImageObject">
    <div class="img">
      <img itemprop="thumbnail" src="/images/entries/20111005/20111005_2075181.png" alt="Solritasと呼ばれるサンプル画面"/>
    </div>
    <a href="/images/entries/20111005/20111005_2075181.png" itemprop="contentUrl"></a>
  </figure>
</div>
Solritasと呼ばれるVelocityを使った、3.x系で入ってきた新しいサンプル画面です。URLはhttp://localhost:8983/solr/browseです。ファセットなどを使った簡単なサンプル画面なので、検索結果画面でこんなことができるというデモにも使えるかと。ただ、これも旧管理画面よりはましですが、デザインが。。。<br style="clear:both" />
<p>とまぁ、簡単ですが、4.x系の管理画面をいくつか触ってみて、キャプチャをとって見ました。
デザインは前よりもすっきりしています。ただ、クエリについてはパラメータの追加ができなくなっているので、もう少し改良されるといいかなぁ（自分でやれよと言われそうですが。。。）</p>
</content:encoded>
    </item>
    
    <item>
      <title>New SolrCloud Designの翻訳（その2）(Jugemより移植)</title>
      <link>https://blog.johtani.info/blog/2011/10/04/new-solrcloud-design%E3%81%AE%E7%BF%BB%E8%A8%B3%E3%81%9D%E3%81%AE2/</link>
      <pubDate>Tue, 04 Oct 2011 18:32:00 +0900</pubDate>
      
      <guid>https://blog.johtani.info/blog/2011/10/04/new-solrcloud-design%E3%81%AE%E7%BF%BB%E8%A8%B3%E3%81%9D%E3%81%AE2/</guid>
      <description>遅くなりましたが、続きです。 さらに英語力のなさを痛感して凹んでいるところですが、何かの役に立てばと恥を晒すところです。。。 一応、訳してみたの</description>
      <content:encoded><p>遅くなりましたが、続きです。
さらに英語力のなさを痛感して凹んでいるところですが、何かの役に立てばと恥を晒すところです。。。</p>
<p>一応、訳してみたのですが、訳すのに必死になってしまい、つながりがわかっていない点もちらほら。
このあと一旦見直しつつ、再度理解する「理解編」をアップしようかと思います。
できれば、シーケンス図とかも交えつつ。（そうしないと理解ができない可能性が。。。）
前回同様、原文は最後に付加しておきます。</p>
<h3 id="boot-strapping">Boot Strapping</h3>
<h4 id="cluster-startupクラスタの起動">Cluster Startup（クラスタの起動）</h4>
<p>ノードはZookeeperのホストとポートを指定することから始めます。
クラスタの最初のノードはクラスタのschema/configとクラスタの設定を指定するとこから開始します。
最初のノードはZookeeperに設定をアップロードしてクラスタをブートします。
クラスタは「ブートストラップ」状態です。
この状態ではノード-&gt;パーティションマッピングは計算されず、クラスタはクラスタ管理コマンド以外のどんなread/writeリクエストも受け付けません。</p>
<p>クラスタの最初のノード集合が起動した後、クラスタ管理コマンド（TBD記述？？？）が管理者によって発行されます。このコマンドは整数「partitions」パラメータを受け取り、次のステップを実行します。</p>
<ol>
<li>Cluster Lockを取得</li>
<li>「partitions」をパーティション数として割り当て</li>
<li>各パーティションのためのノードを取得</li>
<li>ZooKeeperのノード-&gt;パーティションマッピングを更新</li>
<li>Cluster Lockをリリース</li>
<li>全ノードに対して最新版のノード-&gt;パーティションマッピングをZooKeeper経由で更新させる</li>
</ol>
<h4 id="node-startup"><strong>Node Startup</strong></h4>
<p>ノードが起動すると、自分がすでに存在するシャードの一部かどうかZooKeeperでチェックします。
もし、ZooKeeperがノードのレコードを持っていない、またはどのシャードの一部でもないと判断したら、
ノードは後述の「New Node」のステップを実行します。すでに存在するノードの場合は後述の「Node Restart」のステップを実行します。</p>
<p><strong>New Node</strong></p>
<p>新しいノードはクラスタの一部ではなく、クラスタのキャパシティを増強するためのものです。</p>
<p>「auto_add_new_nodes」クラスタプロパティが「false」の場合、新しいノードはZooKeeperに「idle」として登録され、他のノードが参加してくれと言うまで待機します。
そうでない場合（auto_add_new_nods=true）は次のステップを実行します。</p>
<ol>
<li>Cluster Lockを取得します。</li>
<li>適切なnode-&gt;partitionエントリを選び出します。</li>
<li>利用可能なパーティションのリストをスキャンして「replication_factor」のノード数以下のパーティションのエントリを探します。複数ある場合はノード数が最小のエントリを選びます。それも一緒ならランダムに選びます。</li>
<li>全パーティションが「replication_factor」以上のノードを持っている場合、ノードはパーティションが最も多いものをスキャンします。複数ある場合はパーティション内のドキュメント数が最大のエントリを選びます。ドキュメント数が同一なら任意のエントリを選びます。</li>
<li>もし、選んだノード-&gt;パーティションエントリを現在のノードに移動させることでがクラスタのパーティション：ノード比率の最大値を小さくするなら、現在のエントリを返します。。それ以外の場合選ばれたエントリがないので、アルゴリズムは終了です。。</li>
<li>ZooKeeper内のノード-&gt;パーティションマッピングを更新します</li>
</ol>
</li>
<li>ZooKeeper内のノードステータスを「リカバリ」状態にします</li>
<li>Cluster Lockをリリースします</li>
<li>「リカバリ」はパーティションのリーダーから開始します。</li>
<li>リカバリが終了したら、再度、Cluster Lockを取得します。</li>
<li>元のエントリはZooKeeperのノード-&gt;パーティションマッピングから削除されます。</li>
<li>Cluster Lockをリリースします</li>
<li>元のノードはZooKeeperからノード-&gt;パーティションマッピングを更新させられます</li>
<li>ステップ1に戻ります。</li>
</ol>
<h4 id="node-restart"><strong>Node Restart</strong></h4>
<p>ノードの再起動とは次のいずれかを意味しています。</p>
<ul>
<li>JVMがクラッシュし、手動または自動でのリスタート</li>
<li>ノードが一時的にネットワークから切り離された。もしくは、ZooKeeperに接続できなかった（死んでいると思われた）。または、ある一定期間、リーダーからの更新を受信できなかった。</li>
<li>このシナリオが表す書き込み処理のライフサイクルの間にネットワークから分断された</li>
<li>ハード故障もしくはメンテナンスウインドウによりクラスタからノードが分断され、ノードをクラスタにrejoinさせるために起動した。</li>
</ul>
<p>ノードが各パーティションに対してメンバーであるパーティションのリストを読み、パーティションのリーダーがリカバリプロセスを実行する。その時、ノードは「auto_add_new_nods」プロパティをチェックして、「New Node」処理のステップを実行する。
これはクラスタが。。。（元の文章が切れてて意味が不明）</p>
<p>クライアントは標準的なSolrの更新形式を利用して書き込みできます。
書き込み処理はクラスタの任意のノードに送信されます。
ノードはハッシュ関数を利用して、どのパーティションに所属するか決めるためにrange-パーティションマッピングを使います。
ZooKeeperはシャードのリーダーを識別して、書き込み処理をそこに送ります。
SolrJはリーダーに対して書き込みを直接送信するための拡張がされています。</p>
<p>リーダーはPartitionバージョンの操作を割り当て、そのトランザクションログの操作を書き込み、シャードに属する他のノードにドキュメントバージョンハッシュを転送します。
ノードはインデックスにドキュメントハッシュを書き込み、トランザクションログに操作を記録します。
リーダーは、min_writesの最小数のノード以上のノードが「OK」とレスポンスを返したら「OK」とレスポンスを返します。
クラスタプロパティのmin_writesは書き込みリクエスト時に指定することで、異なる値を指定できます。</p>
<p>クラウドモードはコミット/ロールバック操作を明示的には行いません。
コミットは特定の間隔で（commit_within）リーダーによりオートコミットにより管理されます。
また、シャードの全メンバーのコミットはトリガーにより管理されます。
ノードが利用可能な最新バージョンはコミットの時点で記録されます。</p>
<h3 id="transaction-log"><strong>Transaction Log</strong></h3>
<ul>
<li>トランザクションログは2つのコミットの間にインデックスに対して実行された操作全てを記録したもの</li>
<li>コミットはそれ以前に実行された操作の耐久性を保証するために、新しいトランザクションログを開始します。</li>
<li>同期は調整が可能です。例えば、flush vs fsynです。fsyncがデフォルトで、JVMクラッシュに対して保証できるが、電源異常の場合には保証できないが、速度的には早いです。</li>
</ul>
<h3 id="recovery">Recovery</h3>
<p>次のトリガーにより復旧が可能です。</p>
<ul>
<li>Bootstrap</li>
<li>パーティション分割</li>
<li>クラスタの再構築</li>
</ul>
<p>ノードは自身に「recovering」というステータスを設定して復旧を開始します。
このフェーズの間、ノードは読み込みリクエストを受けることができませんが、トランザくkションログに書きこまれるすべての新しい書き込みリクエストを受け取ります。
ノードは自身が持つインデックスのバージョンを調べて、パーティションの最新バージョンのリーダーに問い合わせます。
リーダーはシャード内の残りのノードと同期する前に実行されるべき操作の集合を返します（？？？）。</p>
<p>最初にインデックスをコピーし、最新のノードにあるトランザクションログをリプレイします。
もし、インデックスのコピーが必要ならば、インデックスファイルをローカルにまずコピーし、その後トランザクションログをリプレイします。
トランザクションログのリプレイは通常の書き込みリクエストの流れと同じです。
この時、ノードは新しい書き込みを受け付けるかもしれません。その書き込みはインデックスに再生されるべきです。
ある時点でノードは最新のコミットポイントに追いつき、自身のステータスを「ready」にします。
この時点で、このノードは読み込みリクエストを処理できます。</p>
<h4 id="handling-node-failures">Handling Node Failures</h4>
<p>一時的にネットワークが分断され、幾つかのノードとZooKeeperの間の通信が遮断されるかもしれません。
クラスタはデータの再構築（リバランシング）の前にしばらく待ちが発生します。</p>
<p><strong>Leader failure</strong></p>
<p>ノードが故障し、もしそれがシャードのリーダだった場合、他のメンバーがリーダー選出のプロセスを開始します。
新しいリーダーが選出されるまで、このパーティションへの書き込みは受け付けられません。
この時、これはリーダー以外の故障ステップを処理します。（？？？）</p>
<p><strong>Leader failure</strong></p>
<p>シャードの一部に新しいノードが割り当てられる前にリーダーはmin_reaction_timeの間待ちます。
リーダーはCluster Lockを取得し、シャードの新規メンバーとしてノードを割り当てるためのノード-シャード割り当てアルゴリズムを使用します。
ZooKeeperのノード-&gt;パーティションマッピングが更新され、Cluster Lockがリリースされます。
新しいノードはZooKeeperからノード-&gt;パーティションマッピングを強制的にリロードされます。</p>
<h3 id="splitting-partitions">Splitting partitions</h3>
<p>明示的なクラスタ管理コマンドもしくはSolrによる自動的な分割戦略（ストラテジ）はパーティションを分割することができます。
明示的な分割コマンド（split command）は対象となるパーティションを分割するために実行されます。</p>
<p>パーティションXが100から199のハッシュの範囲を持つものとし、X（100から149）、Y（150～199）に分割するとします。
Xのリーダーは、XとYの新しい値の範囲をZooKeeperに分割アクションを記録します。
ノードはこの分割アクションもしくは新しいパーティションの存在については通知を受けません。（？？？）</p>
<ol>
<li>XのリーダはCluster Lockを取得し、パーティションY（アルゴリズムはto be determined）を割り当てるノードを決定し、新しいパーティションを知らせ、パーティション-&gt;ノードマッピングを更新します。Xのリーダはノードのレスポンスを街、新しいパーティションがコマンドを受付可能な状態になったら次の処理を実行します。</li>
<li>Xのリーダーは分割が完了するまですべてのコミットを停止します。</li>
<li>Xのリーダーは最新のコミットポイント（バージョンVとする）のIndexReaderをオープンし、同じバージョンのIndexReaderもオープンするように命じます</li>
<li>XのリーダーはYのリーダーに対してバージョンV以降のトランザクションログのうちハッシュ値の範囲が150から199のものを流します。</li>
<li>Yのリーダーはトランザクションログの#2（#3の間違い？）で送られたリクエストだけを記録します？？？</li>
<li>Xのリーダーはステップ#2で開いたIndexReaderに対してインデックスの分割を開始します。</li>
<li>#5で作成されたインデックスはYのリーダーに送られ、登録されます。</li>
<li>Yのリーダーは「recovery」プロセスを開始するように（シャードの）他のノード命令し、インデックスのトランザクションログを再生し始めます。</li>
<li>パーティションYのすべてのノードがバージョンVに到達したならば</li>
<li>YのリーダーはXのリーダーに#2で作成されたReaderの上に、ハッシュの範囲が100から149だけに属しているドキュメントを抽出するようにするFilteredIndexReaderを準備するように頼みます。</li>
<li>Xのリーダーは#8aのリクエストが完了したのを検知したら、YのリーダーがCluster Lockを取得し、クラスタ全体の検索/登録リクエストの受信を開始するためにレンジ-&gt;パーティションマッピングを変更します。</li>
<li>YのリーダーはXのリーダーに検索リクエストのために#8aで作成されたFilteredIndexReaderの利用開始を頼みます</li>
<li>YのリーダーはXのリーダーに、ZooKeeperからレンジ-&gt;パーティションマッピングを矯正リフレッシュするように頼みます。この時点で#3で開始されたトランザクションログの流しこみが停止されるのが保証されます。</li>
</ol>
</li>
<li>Xのリーダーは自身のパーティションに存在するべきでないハッシュ値をもつドキュメントを削除し、最新のコミットポイントのsearcherを再度開きます。</li>
<li>この時点で分割は完全に終了し、Xのリーダーはcommit_withinパラメータによるコミットをレジュームします（？？？）</li>
</ol>
<p>Notes:</p>
<ul>
<li>分割操作が完了するまで、commit_withinパラメータによるパーティションの分割は実行されない</li>
<li>#8b開始から#8c終了までの間の分散検索は一貫しない検索結果を帰す場合がある（例えば：検索結果が異なる）</li>
</ul>
<h3 id="cluster-re-balancing">Cluster Re-balancing</h3>
<p>クラスタは明示的なクラスタ管理コマンドにより再構築（リバランシング）できる。</p>
<p>TBD
（to be determined）</p>
<h3 id="cluster-re-balancing-1">Cluster Re-balancing</h3>
<p>TBD
（to be determined）</p>
<h3 id="configuration">Configuration</h3>
<h4 id="solr_clusterproperties"><strong>solr_cluster.properties</strong></h4>
<p>これはクラスタ内の全ノードにわたって適用される一般的なSolr設定ファイルとは別のプロパティファイルの集合である。</p>
<ul>
<li>replication_factor：クラスタによって管理されるドキュメントのレプリカの数</li>
<li>min_writes：書き込み操作が成功になる前の最小の書き込み？？？？。これは書き込みごとに上書き設定可能</li>
<li>commit_within：検索に現れるまでの書き込み操作の最大回数</li>
<li>hash_function：ドキュメントのハッシュ値を計算するための関数の実装</li>
<li>max_hash_value：ハッシュ関数が出力することができる最大値。理論的には、この値はクラスタが保持できるパーティションの最大数でもある</li>
<li>min_reaction_time：起動、停止の後に再配分/分割にかかる時間（？？）</li>
<li>min_replica_for_reaction：レプリカノード数がこの値以下になったら、min_reaction_timeにならなくても分割が実行される。</li>
<li>auto_add_new_nodes：booleanフラグ。もしtrueなら新しいノードは自動的にパーティションからレプリカを読み込む。そうでない場合は新しいノードはクラスタに「idle」状態で登録される</li>
</ul>
<h3 id="cluster-admin-commands"><strong>Cluster Admin Commands</strong></h3>
<p>すべてのクラスタ管理コマンドはすべてのノードでパス（/cluster_admin）を与えることで実行できます。
全ノードは同じコマンドを受け付けることができ、振る舞いも同じものになるでしょう。
以下のコマンドはユーザが利用できるパブリックなコマンドです。</p>
<ul>
<li>init_cluster：（パラメータ：パーティション）このコマンドはノードの集合の初期化後に実施されます。このコマンドが実行されるまで、クラスタは読み込み/書き込みコマンドを受け付けません。</li>
<li>split_partition：（パラメータ：パーティション（任意））パーティションを2つに分割します。もしパーティションパラメータが指定されない場合は、ドキュメント数が最大の</li>
<li>add_idle_nodes：このコマンドはauto_add_new_nodes=falseの場合に利用できます。このコマンドはクラスタに対して「idle」状態のすべてのノードを追加するトリガーとなります。</li>
<li>move_partition：（パラメータ：パーティション、from、to）fromのノードからtoの別のノードに引数で指定されたパーティションを移動します。</li>
<li>command_status：（パラメータ：completion_id（任意））上記コマンドはすべて非同期で実行され、completion_idを返します。このコマンドは特定の実行中のコマンドもしくは全ての実行中のコマンドの状態を表示するために利用できます。</li>
<li>status：（パラメータ：パーティション（任意））パーティションのリストを表示し各パーティションの次の情報を表示します。</li>
<li>リーダーノード</li>
<li>ノードのリスト</li>
<li>ドキュメント数</li>
<li>平均読み込み回数（reads/sec）</li>
<li>平均書き込み回数（writes/sec）</li>
<li>平均読み込み時間（time/read）</li>
<li>平均書き込み時間（time/write）</li>
</ul>
</li>
</ul>
<h3 id="migrating-from-solr-to-solrcloud">Migrating from Solr to SolrCloud</h3>
<p>クラウドに移行するときに幾つかの特徴は不要かもしれないし、サポートされないかもしれません。
既存の（クラウドでない）バージョンでのすべての特徴をSolrCloudでサポートし続けなければなりません。</p>
<ul>
<li>レプリケーション：これは必要ありません。</li>
<li>CoreAdminコマンド：明示的なコアの操作は許可されません。内部にコアがあるかもしれないが、暗黙的に管理されるでしょう</li>
<li>複数スキーマのサポート？：単純化のため、ver1.0ではサポートしないかもしれない</li>
<li>solr.xml：SolrCloudでほんとに必要？</li>
</ul>
<h3 id="alternative-to-a-cluster-lock">Alternative to a Cluster Lock</h3>
<p>リーダーを選出する常設の調停ノード（masterはインデックスレプリケーションで利用している用語なので、「調停」とする）を持つほうが単純かもしれません。
「truth」状態をZookeeperの状態としてみなすような次のパターンでは、将来の柔軟性（クラスタを制御するためのZookeeperの状態を直接変更するような外部管理ツールのような）を考慮に入れることができます。
（毎回ロックを取得するよりも）調停ノードを持つことにより、よりスケーラブルになるかもしれません。
特定条件下でのみCluster Lockを利用するハイブリッドも意味があるでしょう。</p>
<h3 id="single-node-simplest-use-case">Single Node Simplest Use Case</h3>
<p>単一ノードでスタートして、ドキュメントをインデックス登録できないといけません。
また、あとで、クラスタに2番目のノードを追加できないと行けません。</p>
<ul>
<li>1つのノードから開始し、最初にZookeeperに設定ファイルをアップロードし、shard1にノードを作成＋登録します。</li>
<li>他の情報がない状態で設定が作成され、1つのシャードのシステムとなります。</li>
</ul>
</li>
<li>いくつかのドキュメントをインデックスします</li>
<li>他のノードが起動し、「まだ割り当てられていない場合、レプリカの最小の数をもつshardに割り当てられ、「recovery」プロセスを開始します」というパラメータを受け取ります。
* 出来れば、同一ホスト上に同じシャードはコピーしない
* この時点の後で、ノードが停止したら、再起動し、同じ役割が再開されるべきです。（Zookeeperでそれ自身であると判別されれば）
</li>
</ol>
<p>原文はこちらからです。</p>
<h3 id="boot-strapping-1">Boot Strapping</h3>
<h4 id="cluster-startup">Cluster Startup</h4>
<p>A node is started pointing to a Zookeeper host and port. The first node in the cluster may be started with cluster configuration properties and the schema/config files for the cluster. The first node would upload the configuration into zookeeper and bootstrap the cluster. The cluster is deemed to be in the “bootstrap” state. In this state, the node -&gt; partition mapping is not computed and the cluster does not accept any read/write requests except for clusteradmin commands.</p>
<p>After the initial set of nodes in the cluster have started up, a clusteradmin command (TBD description) is issued by the administrator. This command accepts an integer “partitions” parameter and it performs the following steps:</p>
<ol>
<li>Acquire the Cluster Lock</li>
<li>Allocate the “partitions” number of partitions</li>
<li>Acquires nodes for each partition</li>
<li>Updates the node -&gt; partition mapping in ZooKeeper</li>
<li>Release the Cluster Lock</li>
<li>Informs all nodes to force update their own node -&gt; partition mapping from ZooKeeper</li>
<li>The Cluster Lock is acquired</li>
<li>A suitable source (node, partition) tuple is chosen:</li>
<li>The list of available partitions are scanned to find partitions which has less then “replication_factor” number of nodes. In case of tie, the partition with the least number of nodes is selected. In case of another tie, a random partition is chosen.</li>
<li>If all partitions have enough replicas, the nodes are scanned to find one which has most number of partitions. In case of tie, of all the partitions in such nodes, the one which has the most number of documents is chosen. In case of tie, a random partition on a random node is chosen.</li>
<li>If moving the chosen (node, partition) tuple to the current node will decrease the maximum number of partition:node ratio of the cluster, the chosen tuple is returned.Otherwise, no (node, partition) is chosen and the algorithm terminates</li>
<li>The node -&gt; partition mapping is updated in ZooKeeper</li>
</ol>
<li>The node status in ZooKeeper is updated to “recovery” state</li>
<li>The Cluster Lock is released</li>
<li>A “recovery” is initiated against the leader of the chosen partition</li>
<li>After the recovery is complete, the Cluster Lock is acquired again</li>
<li>The source (node, partition) is removed from the node -&gt; partition map in ZooKeeper</li>
<li>The Cluster Lock is released</li>
<li>The source node is instructed to force refresh the node -&gt; partition map from ZooKeeper</li>
<li>Goto step #1</li>
</ol>
<h4 id="node-restart-1"><strong>Node Restart</strong></h4>
<p>A node restart can mean one of the following things:</p>
<ul>
<li>The JVM crashed and was manually or automatically restarted</li>
<li>The node was in a temporary network partition and either could not reach ZooKeeper (and was supposed to be dead) or could not receive updates from the leader for a period of time. A node restart ine node failure.</li>
<li>Lifecycle of a Write Operation this scenario signifies the removal of the network partition.</li>
<li>A hardware failure or maintenance window caused the removal of the node from the cluster and the node has been started again to rejoin the cluster.</li>
</ul>
<p>The node reads the list of partitions for which it is a member and for each partition, starts a recovery process from each partition’s leader respectively. Then, the node follows the steps in the New Node section without checking for the auto_add_new_nodes property. This ensures that the cluster recovers from the imbalance created by th</p>
<p>Writes are performed by clients using the standard Solr update formats. A write operation can be sent to any node in the cluster. The node uses the hash_function , and the Range-Partition mapping to identify the partition where the doc belongs to. A zookeeper lookup is performed to identify the leader of the shard and the operation is forwarded there. A SolrJ enhancement may enable it to send the write directly to the leader</p>
<p>The leader assigns the operation a Partition Version and writes the operation to its transaction log and forwards the document + version + hash to other nodes belonging to the shard. The nodes write the document + hash to the index and record the operation in the transaction log. The leader responds with an ‘OK’ if at least min_writes number of nodes respond with ‘OK’. The min_writes in the cluster properties can be overridden by specifying it in the write request.</p>
<p>The cloud mode would not offer any explicit commit/rollback operations. The commits are managed by auto-commits at intervals (commit_within) by the leader and triggers a commit on all members on the shard. The latest version available to a node is recorded with the commit point.</p>
<h3 id="transaction-log-1"><strong>Transaction Log</strong></h3>
<ul>
<li>A transaction log records all operations performed on an Index between two commits</li>
<li>Each commit starts a new transaction log because a commit guarantees durability of operations performed before it</li>
<li>The sync can be tunable e.g. flush vs fsync by default can protect against JVM crashes but not against power failure and can be much faster</li>
</ul>
<h3 id="recovery-1">Recovery</h3>
<p>A recovery can be triggered during:</p>
<ul>
<li>Bootstrap</li>
<li>Partition splits</li>
<li>Cluster re-balancing</li>
</ul>
<p>The node starts by setting its status as ‘recovering’. During this phase, the node will not receive any read requests but it will receive all new write requests which shall be written to a separate transaction log. The node looks up the version of index it has and queries the ‘leader’ for the latest version of the partition. The leader responds with the set of operations to be performed before the node can be in sync with the rest of the nodes in the shard.</p>
<p>This may involve copying the index first and replaying the transaction log depending on where the node is w.r.t the state of the art. If an index copy is required, the index files are replicated first to the local index and then the transaction logs are replayed. The replay of transaction log is nothing but a stream of regular write requests. During this time, the node may have accumulated new writes, which should then be played back on the index. The moment the node catches up with the latest commit point, it marks itself as “ready”. At this point, read requests can be handled by the node.</p>
<h4 id="handling-node-failures-1">Handling Node Failures</h4>
<p>There may be temporary network partitions between some nodes or between a node and ZooKeeper. The cluster should wait for some time before re-balancing data.</p>
<p><strong>Leader failure</strong></p>
<p>If node fails and if it is a leader of any of the shards, the other members will initiate a leader election process. Writes to this partition are not accepted until the new leader is elected. Then it follows the steps in non-leader failure</p>
<p><strong>Non-Leader failure</strong></p>
<p>The leader would wait for the min_reaction_time before identifying a new node to be a part of the shard. The leader acquires the Cluster Lock and uses the node-shard assignment algorithm to identify a node as the new member of the shard. The node -&gt; partition mapping is updated in ZooKeeper and the cluster lock is released. The new node is then instructed to force reload the node -&gt; partition mapping from ZooKeeper.</p>
<h3 id="splitting-partitions-1">Splitting partitions</h3>
<p>A partition can be split either by an explicit cluster admin command or automatically by splitting strategies provided by Solr. An explicit split command may give specify target partition(s) for split.</p>
<p>Assume the partition ‘X’ with hash range 100 - 199 is identified to be split into X (100 - 149) and a new partition Y (150 - 199). The leader of X records the split action in ZooKeeper with the new desired range values of X as well as Y. No nodes are notified of this split action or the existence of the new partition.</p>
<ol>
<li>The leader of X, acquires the Cluster Lock and identifies nodes which can be assigned to partition Y (algorithm TBD) and informs them of the new partition and updates the partition -&gt; node mapping. The leader of X waits for the nodes to respond and once it determines that the new partition is ready to accept commands, it proceeds as follows:</li>
<li>The leader of X suspends all commits until the split is complete.</li>
<li>The leader of X opens an IndexReader on the latest commit point (say version V) and instructs its peers to do the same.</li>
<li>The leader of X starts streaming the transaction log after version V for the hash range 150 - 199 to the leader of Y.</li>
<li>The leader of Y records the requests sent in #2 in its transaction log only i.e. it is not played on the index.</li>
<li>The leader of X initiates an index split on the IndexReader opened in step #2.</li>
<li>The index created in #5 is sent to the leader of Y and is installed.</li>
<li>The leader of Y instructs its peers to start recovery process. At the same time, it starts playing its transaction log on the index.</li>
<li>Once all peers of partition Y have reached at least version V:</li>
<li>The leader of Y asks the leader of X to prepare a FilteredIndexReader on top of the reader created in step #2 which will have documents belonging to hash range 100 - 149 only.</li>
<li>Once the leader of X acknowledges the completion of request in #8a, the leader of Y acquires the Cluster Lock and modifies the range -&gt; partition mapping to start receiving regular search/write requests from the whole cluster.</li>
<li>The leader of Y asks leader of X to start using the FilteredIndexReader created in #8a for search requests.</li>
<li>The leader of Y asks leader of X to force refresh the range -&gt; partition mapping from ZooKeeper. At this point, it is guaranteed that the transaction log streaming which started in #3 will be stopped.</li>
</ol>
</li>
<li>The leader of X will delete all documents with hash values not belonging to its partitions, commits and re-opens the searcher on the latest commit point.</li>
<li>At this point, the split is considered complete and leader of X resumes commits according to the commit_within parameters.</li>
</ol>
<p>Notes:</p>
<ul>
<li>The partition being split does not honor commit_within parameter until the split operation completes</li>
<li>Any distributed search operation performed starting at the time of #8b and till the end of #8c can return inconsistent results i.e. the number of search results may be wrong.</li>
</ul>
<h3 id="cluster-re-balancing-2">Cluster Re-balancing</h3>
<p>The cluster can be rebalanced by an explicit cluster admin command.</p>
<p>TBD</p>
<h3 id="monitoring">Monitoring</h3>
<p>TBD</p>
<h3 id="configuration-1">Configuration</h3>
<h4 id="solr_clusterproperties-1"><strong>solr_cluster.properties</strong></h4>
<p>This are the set of properties which are outside of the regular Solr configuration and is applicable across all nodes in the cluster:</p>
<ul>
<li><strong>replication_factor</strong> : The number of replicas of a doc maintained by the cluster</li>
<li><strong>min_writes</strong> : Minimum no:of successful writes before the write operation is signaled as successful . This may me overridden on a per write basis</li>
<li><strong>commit_within</strong> : This is the max time within which write operation is visible in a search</li>
<li><strong>hash_function</strong> : The implementation which computes the hash of a given doc</li>
<li><strong>max_hash_value</strong> : The maximum value that a hash_function can output. Theoretically, this is also the maximum number of partitions the cluster can ever have</li>
<li>min_reaction_time : The time before any reallocation/splitting is done after a node comes up or goes down (in secs)</li>
<li><strong>min_replica_for_reaction</strong> : If the number of replica nodes go below this threshold the splitting is triggered even if the min_reaction_time is not met</li>
<li><strong>auto_add_new_nodes</strong> : A Boolean flag. If true, new nodes are automatically used as read replicas to existing partitions, otherwise, new nodes sit idle until the cluster needs them.</li>
</ul>
<h3 id="cluster-admin-commands-1"><strong>Cluster Admin Commands</strong></h3>
<p>All cluster admin commands run on all nodes at a given path (say /cluster_admin). All nodes are capable of accepting the same commands and the behavior would be same. These are the public commands which a user can use to manage a cluster:</p>
<ul>
<li><strong>init_cluster</strong> : (params : partition) This command is issued after the initial set of nodes are started. Till this command is issued, the cluster would not accept any read/write commands</li>
<li><strong>split_partition</strong> : (params : partitionoptional). The partition is split into two halves. If the partition parameter is not supplied, the partition with the largest number of documents is identified as the candidate.</li>
<li><strong>add_idle_nodes</strong> : This can be used if auto_add_new_nodes=false. This command triggers the addition of all ‘idle’ nodes to the cluster.</li>
<li><strong>move_partition</strong> : (params : partition, from, to). Move the given partition from a given node from to another node</li>
<li><strong>command_status</strong> :(params : completion_idoptional) . All the above commands are asynchronous and returns with a completion_id . This command can be used to know the status of a particular running command or all the current running commands</li>
<li><strong>status</strong> : (params : partitionoptional) Shows the list of partitions and for each partition, the following info is provided</li>
<li>leader node</li>
<li>nodes list</li>
<li>doc count</li>
<li>average reads/sec</li>
<li>average writes/sec</li>
<li>average time/read</li>
<li>average time/write</li>
</ul>
</li>
</ul>
<h3 id="migrating-from-solr-to-solrcloud-1">Migrating from Solr to SolrCloud</h3>
<p>A few features may be redundant or not supported when we move to cloud such as. We should continue to support the non cloud version which supports all the existing features</p>
<ul>
<li>Replication. This feature is not required anymore</li>
<li>CoreAdmin commands. Explicit manipulation of cores will not be allowed. Though cores may exist internally and they meay be managed implicitly</li>
<li>Multiple schema support ? Should we just remove it from ver 1.0 for simplicity?</li>
<li>solr.xml . Is there a need at all for this in the cloud mode?</li>
</ul>
<h3 id="alternative-to-a-cluster-lock-1">Alternative to a Cluster Lock</h3>
<p>It may be simpler to have a coordinator node (we avoid the term master since that is associated with traditional index replication) that is established via leader election. Following a pattern of treating the zookeeper state as the &ldquo;truth&rdquo; and having nodes react to changes in that state allow for more future flexibility (such as allowing an external management tool directly change the zookeeper state to control the cluster). Having a coordinator (as opposed to grabbing a lock every time) can be more scalable too. A hybrid model where a cluster lock is used only in certain circumstances can also make sense.</p>
<h3 id="single-node-simplest-use-case-1">Single Node Simplest Use Case</h3>
<p>We should be able to easily start up a single node and start indexing documents. At a later point in time, we should be able to start up a second node and have it join the cluster.</p>
<p>start up a single node, upload it&rsquo;s configuration (the first time) to zookeeper, and create+assign the node to shard1.
in the absence of other information when the config is created, a single shard system is assumed
index some documents
start up another node and pass it a parameter that says &ldquo;if you are not already assigned, assign yourself to any shard that has the lowest number of replicas and start recovery process&rdquo;
avoid replicating a shard on the same host if possible
after this point, one should be able to kill the node and start it up again and have it resume the same role (since it should see itself in zookeeper)</p>
</content:encoded>
    </item>
    
    <item>
      <title>New SolrCloud Designの翻訳（その１）(Jugemより移植)</title>
      <link>https://blog.johtani.info/blog/2011/09/28/new-solrcloud-design%E3%81%AE%E7%BF%BB%E8%A8%B3%E3%81%9D%E3%81%AE%EF%BC%91/</link>
      <pubDate>Wed, 28 Sep 2011 20:45:00 +0900</pubDate>
      
      <guid>https://blog.johtani.info/blog/2011/09/28/new-solrcloud-design%E3%81%AE%E7%BF%BB%E8%A8%B3%E3%81%9D%E3%81%AE%EF%BC%91/</guid>
      <description>ちょっと興味があるので、訳してみました。（Wikiのページはこちら） 更新されているようなので、もとの文章も残しておきます。（ページ下部の続き</description>
      <content:encoded><p>ちょっと興味があるので、訳してみました。（Wikiのページは<a href="http://wiki.apache.org/solr/NewSolrCloudDesign">こちら</a>）
更新されているようなので、もとの文章も残しておきます。（ページ下部の続きはこちら部分以降）
全部訳そうと思ったのですが、終わらなかったので、まずは前半部分です。まだ、訳しただけで理解できてない。。。
（英語力のなさをさらけ出してしまうのですが、これも修行です。。。おかしいところはツッコミを。）</p>
<h3 id="what-is-solrcloud">What is SolrCloud?</h3>
<p>Solrクラウドはクラウドでの検索サービスとしてのSolrを管理、運用するための既存のSolrを拡張するものです。</p>
<h3 id="用語集">用語集</h3>
<ul>
<li>Cluster：クラスタは1単位として管理されるSolrノードの集合です。クラスタ全体で単一のschema、solrconfigをもたないといけません。</li>
<li>Node：ひとつのJVMインスタンスで起動しているSolrのこと</li>
<li>Partition：パーティションはドキュメント集合全体のサブセット（部分集合）のことです。パーティションは部分集合のドキュメントが単一のインデックスに含まれるような形で作られます。</li>
<li>Shard：パーティションはn（＝replication factor）個のノードに保存される必要があります。このn個のノードすべてでひとつのshardです。1つのノードはいくつかのshardの一部にで有る場合があります。</li>
<li>Leader：各Shardは1つのリーダとなるノードを持っています。パーティションに登録されたドキュメントリーダーからコピーされます</li>
<li>Replication Factor：クラスタによって保持されるレプリカの最小限の数</li>
<li>Transaction Log：各ノードによって保持される書き込み処理の追記ログ</li>
<li>Partition version：これは各shardのリーダーが持っているカウンターで、書き込み処理ごとに増加し、レプリカに送られます。</li>
<li>Cluster Lock：これはrange（※後述されているハッシュ値の範囲のことか？）-&gt;パーティションもしくはパーティション-&gt;ノードのマッピングを変更するために取得しなければいけないグローバルなロックのことです。</li>
</ul>
<p>※用語だけだと関係がわかりづらかったので、図を書いてみました。</p>
<p>
<link rel="stylesheet" href="/css/hugo-easy-gallery.css" />
<div class="box" >
  <figure  itemprop="associatedMedia" itemscope itemtype="http://schema.org/ImageObject">
    <div class="img">
      <img itemprop="thumbnail" src="/images/entries/20110928/20110928_2063185.png" alt="SolrCloudのパーティションについて"/>
    </div>
    <a href="/images/entries/20110928/20110928_2063185.png" itemprop="contentUrl"></a>
  </figure>
</div>

ドキュメントの集合とパーティションについての考え方</p>
<p>

<div class="box" >
  <figure  itemprop="associatedMedia" itemscope itemtype="http://schema.org/ImageObject">
    <div class="img">
      <img itemprop="thumbnail" src="/images/entries/20110928/20110928_2063186.png" alt="SolrCloudのクラスターについて"/>
    </div>
    <a href="/images/entries/20110928/20110928_2063186.png" itemprop="contentUrl"></a>
  </figure>
</div>

クラスタ、ノード、シャードの考え方。</p>
<h3 id="処理原則"><strong>処理原則</strong></h3>
<ul>
<li>任意の処理はクラスタにある任意のノードに実行可能です。</li>
<li>リカバリできないSPOFはありません。</li>
<li>クラスタは伸縮自在（elastic）でなければならない</li>
<li>書き込みが失われないこと（耐久性）を保証する</li>
<li>書き込み順序が保証されなければならない</li>
<li>2つのクライアントが2つの「A」というドキュメントを同時に送信してきた場合、すべてのレプリカで一貫してどちらか一方が保存されなければならない。</li>
<li>クラスタの設定は中央管理されなければならない。また、クラスタのどのノードからもクラスタ設定が更新できます。</li>
<li>読み込み（検索）の自動的なフェイルオーバー</li>
<li>書き込み（インデクシング）の自動的なフェイルオーバー</li>
<li>ノードの故障が発生しても自動的にrepcation factorの数は守られます。（故障したら動的にレプリカを再配置？）</li>
</ul>
<h3 id="zookeeper"><strong>Zookeeper</strong></h3>
<p>ZooKeeperクラスタは次のために使用されます。</p>
<ul>
<li>クラスタ設定の集中管理</li>
<li>分散同期に必要な操作のコーディネータ</li>
<li>クラスタ構成を保存するためのシステム</li>
</ul>
<h3 id="partitioning"><strong>Partitioning</strong></h3>
<p>クラスタは固定されたmax_hash_value＝「N」が設定されます。
max_hash_valueは1000のような大きな値が設定されます。</p>
<pre><code>
hash = hash_function(doc.getKey()) % N
</code></pre><p>ハッシュ値の範囲がパーティションに割り当てられ、ZooKeeperに保存されます。
次の例のような形で、パーティションに対して範囲が設定されます。</p>
<pre><code>
range  : partition
------  ----------
0 - 99 : 1
100-199: 2
200-299: 3
</code></pre><p>ハッシュはドキュメントにインデックスフィールドとして追加され、変更されない値です。
これは、インデックスを分割するときにも利用します。</p>
<p>ハッシュ関数はプラガブルです。これはドキュメントを受け取り、一貫した正整数ハッシュ値を返します。デフォルトのハッシュ関数として、必須でかつ変更されないフィールド（デフォルトはユニークキーフィールド）からハッシュ値を計算する関数が提供されます。</p>
<h4 id="using-full-hash-range"><strong>Using full hash range</strong></h4>
<p>max_hash_valueは必ずしも必要ではありません。各shardはいずれにしろハッシュ値の範囲持っているので、完全な32 bitsハッシュを使うこともできます。
設定可能なmax_hash_valueを利用しないで、クライアントからの値をもとにハッシュ値を作ることができます。
例えば、電子メールの検索アプリでは次のようにハッシュ関数を作ることができます。</p>
<pre><code>
(hash(user_id)&lt;&lt;24) | (hash(message_id)&gt;&gt;&gt;8)
</code></pre><p>ユーザIDから8bitのハッシュコードの先頭8ビットを利用することで、任意のユーザのメールがクラスタの同じ256番目（のノード？）にあるのを保証します。検索時はこの情報をもとにクラスタのその部分への問い合わせだけで情報が得られます。</p>
<p>おそらく、私たちは最大値から最小値をカバーする範囲を表現するのにハッシュ空間を輪（固定のハッシュではなく）とみなしたいです。（？？？円状のハッシュ空間とすることで、クラスタ内のノード数の増減に耐えられるようにするよということかな？）</p>
<h4 id="shard-naming"><strong>shard naming</strong></h4>
<p>シャードからハッシュ値の範囲へのマッピングを別々に管理するよりも、ハッシュコードによりパーティションを構成するときに実際にはハッシュの範囲をシャード名にします。
（シャード「1-1000」は1から1000の間のハッシュコードを持つドキュメントが含まれるという形）</p>
<p>現時点では（コレクション1つに対してシングルコアの1Solrサーバと仮定して）solrコア名はコレクション名をつけるようになっています。
同一コレクションのためのマルチコアに対してのいい命名規則をつけるという課題が残っています。
（※コレクションに対する説明がここまでないかな？）</p>
<h3 id="shard-assignment">Shard Assignment</h3>
<p>ノード-&gt;パーティションのマッピングはZooKeeperにあるCluster Lockを取得したノードによってのみ変更が可能です。
ノードの追加時に、まず、Cluster Lockを取得し、次にそれがどのパーティションを取得できるかを識別します。</p>
<h4 id="node-to-a-shard-assignment">Node to a shard assignment</h4>
<p>新しいノードを探しているノードはまずCluster Lockを取得しないといけません。
第一に、リーダーはシャードを決めます。
シャードが持つ、すべての利用可能なノード数で最小の値を持つノードが選び出されます。
もし、同値ならランダムにノードを選びます。</p>
<p>原文はこちらからです。</p>
<h3 id="new-solrcloud-design"><strong>New SolrCloud Design</strong></h3>
<p>(Work in progress)</p>
<h3 id="what-is-solrcloud-1">What is SolrCloud?</h3>
<p>SolrCloud is an enhancement to the existing Solr to manage and operate Solr as a search service in a cloud.</p>
<h3 id="glossary">Glossary</h3>
<ul>
<li>Cluster : Cluster is a set of Solr nodes managed as a single unit. The entire cluster must have a single schema and solrconfig</li>
<li>Node : A JVM instance running Solr</li>
<li>Partition : A partition is a subset of the entire document collection. A partition is created in such a way that all its documents can be contained in a single index.</li>
<li>Shard : A Partition needs to be stored in multiple nodes as specified by the replication factor. All these nodes collectively form a shard. A node may be a part of multiple shards</li>
<li>Leader : Each Shard has one node identified as its leader. All the writes for documents belonging to a partition should be routed through the leader.</li>
<li>Replication Factor : Minimum number of copies of a document maintained by the cluster</li>
<li>Transaction Log : An append-only log of write operations maintained by each node</li>
<li>Partition version : This is a counter maintained with the leader of each shard and incremented on each write operation and sent to the peers</li>
<li>Cluster Lock : This is a global lock which must be acquired in order to change the range -&gt; partition or the partition -&gt; node mappings.</li>
</ul>
<h3 id="guiding-principles"><strong>Guiding Principles</strong></h3>
<ul>
<li>Any operation can be invoked on any node in the cluster.</li>
<li>No non-recoverable single point of failures</li>
<li>Cluster should be elastic</li>
<li>Writes must never be lost i.e. durability is guaranteed</li>
<li>Order of writes should be preserved</li>
<li>If two clients send document &ldquo;A&rdquo; to two different replicas at the same time, one should consistently &ldquo;win&rdquo; on all replicas.</li>
<li>Cluster configuration should be managed centrally and can be updated through any node in the cluster. No per node configuration other than local values such as the port, index/logs storage locations should be required</li>
<li>Automatic failover of reads</li>
<li>Automatic failover of writes</li>
<li>Automatically honour the replication factor in the event of a node failure</li>
</ul>
<h3 id="zookeeper-1"><strong>Zookeeper</strong></h3>
<p>A ZooKeeper cluster is used as:</p>
<ul>
<li>The central configuration store for the cluster</li>
<li>A co-ordinator for operations requiring distributed synchronization</li>
<li>The system-of-record for cluster topology</li>
</ul>
<h3 id="partitioning-1"><strong>Partitioning</strong></h3>
<p>The cluster is configured with a fixed max_hash_value (which is set to a fairly large value, say 1000) ‘N’. Each document’s hash is calculated as:</p>
<pre><code>
hash = hash_function(doc.getKey()) % N
</code></pre><p>Ranges of hash values are assigned to partitions and stored in Zookeeper. For example we may have a
range to partition mapping as follows</p>
<pre><code>
range  : partition
------  ----------
0 - 99 : 1
100-199: 2
200-299: 3
</code></pre><p>The hash is added as an indexed field in the doc and it is immutable. This may also be used during an index split</p>
<p>The hash function is pluggable. It can accept a document and return a consistent &amp; positive integer hash value. The system provides a default hash function which uses the content of a configured, required &amp; immutable field (default is unique_key field) to calculate hash values.</p>
<h4 id="using-full-hash-range-1"><strong>Using full hash range</strong></h4>
<p>Alternatively, there need not be any max_hash_value - the full 32 bits of the hash can be used since each shard will have a range of hash values anyway. Avoiding a configurable max_hash_value makes things easier on clients wanting related hash values next to each other. For example, in an email search application, one could construct a hashcode as follows:</p>
<pre><code>
(hash(user_id)&lt;&lt;24) | (hash(message_id)&gt;&gt;&gt;8)
</code></pre><p>By deriving the top 8 bits of the hashcode from the user_id, it guarantees that any users emails are in the same 256th portion of the cluster. At search time, this information can be used to only query that portion of the cluster.</p>
<p>We probably also want to view the hash space as a ring (as is done with consistent hashing) in order to express ranges that wrap (cross from the maximum value to the minimum value).</p>
<h4 id="shard-naming-1"><strong>shard naming</strong></h4>
<p>When partitioning is by hash code, rather than maintaining a separate mapping from shard to hash range, the shard name could actually be the hash range (i.e. shard &ldquo;1-1000&rdquo; would contain docs with a hashcode between 1 and 1000).</p>
<p>The current convention for solr-core naming is that it match the collection name (assuming a single core in a solr server for the collection). We still need a good naming scheme for when there are multiple cores for the same collection.</p>
<h3 id="shard-assignment-1">Shard Assignment</h3>
<p>The node -&gt; partition mapping can only be changed by a node which has acquired the Cluster Lock in ZooKeeper. So when a node comes up, it first attempts to acquire the cluster lock, waits for it to be acquired and then identifies the partition to which it can subscribe to.</p>
<h4 id="node-to-a-shard-assignment-1">Node to a shard assignment</h4>
<p>The node which is trying to find a new node should acquire the cluster lock first. First of all the leader is identified for the shard. Out of the all the available nodes, the node with the least number of shards is selected. If there is a tie, the node which is a leader to the least number of shard is chosen. If there is a tie, a random node is chosen.</p>
</content:encoded>
    </item>
    
    <item>
      <title>Lucene/Solr 3.4リリース（速報）(Jugemより移植)</title>
      <link>https://blog.johtani.info/blog/2011/09/15/lucene-solr-3-4%E3%83%AA%E3%83%AA%E3%83%BC%E3%82%B9%E9%80%9F%E5%A0%B1/</link>
      <pubDate>Thu, 15 Sep 2011 09:31:00 +0900</pubDate>
      
      <guid>https://blog.johtani.info/blog/2011/09/15/lucene-solr-3-4%E3%83%AA%E3%83%AA%E3%83%BC%E3%82%B9%E9%80%9F%E5%A0%B1/</guid>
      <description>Solr/Lucene 3.4がリリースされました。（速報） 以下、各サイトへのリンクです。 Solrリリースのお知らせ Luceneリリースのお知らせ ちなみに、先日の</description>
      <content:encoded><p>Solr/Lucene 3.4がリリースされました。（速報）</p>
<p>以下、各サイトへのリンクです。</p>
<p><a href="http://lucene.apache.org/solr/#14+September+2011+-+Solr+3.4.0+Released">Solrリリースのお知らせ</a></p>
<p><a href="http://lucene.apache.org/#14+September+2011+-+Lucene+Core+3.4.0+and+Solr+3.4.0+Available">Luceneリリースのお知らせ</a></p>
<p>ちなみに、先日のSolr勉強会で関口さんが話されていた<a href="https://issues.apache.org/jira/browse/LUCENE-3418">インデックスが壊れるバグ</a>ですが、
先日のアメリカのハリケーン（Irene）で実際に電源が落ちて見つかったみたいです。</p>
<p>ということで、3.4がリリースされたので、3.1~3.3は利用しないほうがいいようです。</p>
<p><span style="color:#FF0000">追記：</span>
<a href="http://www.lucidimagination.jp/2011/09/lucene-3-4solr-3-4-%E3%81%8C%E3%83%AA%E3%83%AA%E3%83%BC%E3%82%B9/">lucidimagination.jpのサイトに日本語のリリースノートが公開されていた</a>ので、リンクを記載しておきます。</p>
</content:encoded>
    </item>
    
    <item>
      <title>Lucene/Solr 3.3リリース（速報）(Jugemより移植)</title>
      <link>https://blog.johtani.info/blog/2011/07/01/lucene-solr-3-3%E3%83%AA%E3%83%AA%E3%83%BC%E3%82%B9%E9%80%9F%E5%A0%B1/</link>
      <pubDate>Fri, 01 Jul 2011 15:29:39 +0900</pubDate>
      
      <guid>https://blog.johtani.info/blog/2011/07/01/lucene-solr-3-3%E3%83%AA%E3%83%AA%E3%83%BC%E3%82%B9%E9%80%9F%E5%A0%B1/</guid>
      <description>Solr/Lucene 3.3がリリースされました。（速報） 以下、各サイトへのリンクです。 Solrリリースのお知らせ Luceneリリースのお知らせ リリースのタイミ</description>
      <content:encoded><p>Solr/Lucene 3.3がリリースされました。（速報）<br />
<br />
以下、各サイトへのリンクです。<br />
<br />
<a href="http://lucene.apache.org/solr/#July+2011+-+Solr+3.3+Released">Solrリリースのお知らせ</a><br />
<br />
<a href="http://lucene.apache.org/#1+July+2011+-+Lucene+Core+3.3+and+Solr+3.3+Available">Luceneリリースのお知らせ</a><br />
<br />
リリースのタイミングがどんどん早くなってる。。。</p>
</content:encoded>
    </item>
    
  </channel>
</rss>
