<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>読書 on @johtaniの日記 3rd</title>
    <link>https://blog.johtani.info/tags/%E8%AA%AD%E6%9B%B8/</link>
    <description>Recent content in 読書 on @johtaniの日記 3rd</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja</language>
    <lastBuildDate>Thu, 09 Jul 2020 18:59:38 +0900</lastBuildDate><atom:link href="https://blog.johtani.info/tags/%E8%AA%AD%E6%9B%B8/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Rust the book - 第15章</title>
      <link>https://blog.johtani.info/blog/2020/07/09/hap15-rust-the-book/</link>
      <pubDate>Thu, 09 Jul 2020 18:59:38 +0900</pubDate>
      
      <guid>https://blog.johtani.info/blog/2020/07/09/hap15-rust-the-book/</guid>
      <description>前回の記事はこちら。自分用のメモなので、読みにくいかもです。 Rust the Bookを読み始めた Rust the book - 第4章 Rust the book - 第5章 Rust the book - 第6章 Rust the book - 第8章</description>
      <content:encoded><p>前回の記事はこちら。自分用のメモなので、読みにくいかもです。</p>
<ul>
<li><a href="/blog/2020/03/23/start-reading-rust-the-book/">Rust the Bookを読み始めた</a></li>
<li><a href="/blog/2020/03/26/chap4-rust-the-book/">Rust the book - 第4章</a></li>
<li><a href="/blog/2020/04/02/chap5-rust-the-book/">Rust the book - 第5章</a></li>
<li><a href="/blog/2020/04/07/chap6-rust-the-book/">Rust the book - 第6章</a></li>
<li><a href="/blog/2020/04/16/chap8-rust-the-book/">Rust the book - 第8章</a></li>
<li><a href="/blog/2020/05/14/chap9-rust-the-book/">Rust the book - 第9章</a></li>
<li><a href="/blog/2020/05/28/chap10-rust-the-book/">Rust the book - 第10章</a></li>
<li><a href="/blog/2020/06/04/chap13-rust-the-book/">Rust the book - 第13章</a></li>
</ul>
<p>14章は飛ばして、15章です(Cargoはまた別途調べればいいかな?と思って)。</p>
<h2 id="第15章-スマートポインタ">第15章 スマートポインタ</h2>
<p>たぶん、これを理解すれば、参照とベクタや構造体とかの組み合わせがもう少し効率よく使えるようになるのかなぁ?</p>
<ul>
<li>ポインタの強い版?
<ul>
<li>参照カウント方式のスマートポインタ型 - Luceneとかで実装されてた気がするなぁ
<ul>
<li>複数の所有者!?</li>
</ul>
</li>
</ul>
</li>
<li>DerefとDropトレイトを実装している構造体</li>
</ul>
<h3 id="ヒープのデータを指すboxtを使用する">ヒープのデータを指すBox<T>を使用する</h3>
<p>これはコンパイルエラー。<code>let y</code>のタイミングで借用してるので、書き換えでエラーになる。</p>
<pre><code>fn main() {
    let mut x = 5;
    let y = &amp;x;

    assert_eq!(5, x);
    assert_eq!(5, *y);
    x = 6;
    assert_eq!(6, x);
    assert_eq!(6, *y);
}
</code></pre><p>こっちはOK。</p>
<pre><code>fn main() {
    let mut x = 5; // in stack
    let y = Box::new(x); // in heap

    assert_eq!(5, x);
    assert_eq!(5, *y);
    x = 6;
    assert_eq!(6, x);
    assert_eq!(6, *y);
}
</code></pre><p>余談:コンパイラが変なワーニングを出してくれた。</p>
<pre><code>use std::ops::Deref;

impl&lt;T, Z&gt; Deref for MyBox&lt;T, Z&gt; {
    type Target = T;

    fn deref(&amp;self) -&gt; &amp;T {
        &amp;self.0
    }
}

struct MyBox&lt;T, Z&gt;(T, Z);

impl&lt;T, Z&gt; MyBox&lt;T, Z&gt; {
    fn new(x: T, y: Z) -&gt; MyBox&lt;T, Z&gt; {
        MyBox(x, y)
    }
}

fn main() {
    let x = 5;
    let z = &quot;10&quot;;
    let y = MyBox::new(x, z);

    assert_eq!(5, x);
    assert_eq!(5, *y);
}

</code></pre><h3 id="derefトレイトでスマートポインタを普通の参照のように扱う">Derefトレイトでスマートポインタを普通の参照のように扱う</h3>
<ul>
<li><code>参照外し型強制</code> : 日本語ムズカシイネ</li>
<li>Derefを自分で実装しないといけない場面がちょっと想像できてない。たぶん、Boxとかの説明に必要なので出てきたって感じなんだろうけど。</li>
</ul>
<h3 id="dropトレイトで片付け時にコードを走らせる">Dropトレイトで片付け時にコードを走らせる</h3>
<ul>
<li>こっちは、リソース開放とかでいい感じにできそうだってのはわかった。</li>
<li>Dropはどんなときに実装するんだろう?Tantivyだとオブジェクトプールとかで使ってた。</li>
</ul>
<h3 id="rctは参照カウント方式のスマートポインタ">Rc<T>は、参照カウント方式のスマートポインタ</h3>
<ul>
<li>これ、ここで作ったConsのリストを追っかけるためのサンプルも書いてほしい。</li>
</ul>
<pre><code>#[derive(Debug)]
enum List {
    Cons(i32, Rc&lt;List&gt;),
    Nil,
}

fn print_typename&lt;T&gt;(_: T) {
    println!(&quot;{}&quot;, std::any::type_name::&lt;T&gt;());
}

use List::{Cons, Nil};
use std::rc::Rc;
use std::borrow::Borrow;

fn main() {
    let z = Cons(5, Rc::new(Cons(10, Rc::new(Nil))));
    let a = Rc::new(z);
    let _b = Cons(3, Rc::clone(&amp;a));
    let _c = Cons(4, Rc::clone(&amp;a));
    match &amp;(*a) {
        Cons(v1, v2) =&gt; {
            print_typename(v2);
            println!(&quot;{}, {:?}&quot;, v1, v2);
        },
        Nil =&gt; println!(&quot;Nil!!&quot;)
    };
}
</code></pre><h3 id="refcelltと内部可変性パターン">RefCell<T>と内部可変性パターン</h3>
<ul>
<li></li>
</ul>
<h3 id="循環参照はメモリをリークすることもある">循環参照は、メモリをリークすることもある</h3>
</content:encoded>
    </item>
    
    <item>
      <title>Rust the book - 第13章</title>
      <link>https://blog.johtani.info/blog/2020/06/04/chap13-rust-the-book/</link>
      <pubDate>Thu, 04 Jun 2020 17:37:29 +0900</pubDate>
      
      <guid>https://blog.johtani.info/blog/2020/06/04/chap13-rust-the-book/</guid>
      <description>前回の記事はこちら。自分用のメモなので、読みにくいかもです。 Rust the Bookを読み始めた Rust the book - 第4章 Rust the book - 第5章 Rust the book - 第6章 Rust the book - 第8章</description>
      <content:encoded><p>前回の記事はこちら。自分用のメモなので、読みにくいかもです。</p>
<ul>
<li><a href="/blog/2020/03/23/start-reading-rust-the-book/">Rust the Bookを読み始めた</a></li>
<li><a href="/blog/2020/03/26/chap4-rust-the-book/">Rust the book - 第4章</a></li>
<li><a href="/blog/2020/04/02/chap5-rust-the-book/">Rust the book - 第5章</a></li>
<li><a href="/blog/2020/04/07/chap6-rust-the-book/">Rust the book - 第6章</a></li>
<li><a href="/blog/2020/04/16/chap8-rust-the-book/">Rust the book - 第8章</a></li>
<li><a href="/blog/2020/05/14/chap9-rust-the-book/">Rust the book - 第9章</a></li>
<li><a href="/blog/2020/05/28/chap10-rust-the-book/">Rust the book - 第10章</a></li>
</ul>
<p>11章、12章はちょっと飛ばして、13章です。</p>
<h2 id="第13章">第13章</h2>
<p>イテレータ、クロージャです。
12章の話もちょっと出てくるのか。</p>
<h3 id="クロージャ">クロージャ</h3>
<p>基本的に、「変数には値が束縛されている」という固定観念がずっと頭にこびりついたままなので、クロージャに慣れないんだろうなぁ。そろそろこの固定概念をどうにかしないと。</p>
<ul>
<li>匿名関数で、変数に保存したり引数に渡せる</li>
<li>ちょっと面白い話(ワークアウト)で実際に考えられる手法の説明がいくつか行われる</li>
</ul>
<ol>
<li>関数でリファクタリング
<ul>
<li>これが自分がよくやるパターンかなぁ。クロージャになれてないので。。。</li>
</ul>
</li>
<li>クロージャーを変数に束縛
<ul>
<li>呼び出しは関数みたいな感じ(ここで少し混乱)</li>
<li>これだと、結局呼び出されたタイミングが複数回あるよね? -&gt; あはりそうだった</li>
</ul>
</li>
</ol>
<p>ここで、閑話休題で、クロージャの型推論とか注釈の話。
クロージャは狭い文脈だし、外に公開しているものでもないので、戻り値なども定義してなくてもいいよねとのこと。書くことも可能?なので、書いてわかりやすくするのもありなんだろうな。</p>
<p>推論についてはこれまで通りで、2回異なる型の変数で呼び出すと、2回目で怒られていた。</p>
<ol start="3">
<li>遅延評価(クロージャを保持する構造体!?)
<ul>
<li><code>Fn</code>トレイト</li>
<li>トレイトとMatchの組み合わせだからこのへんで説明する形になるのか。</li>
<li>これを真似すれば、いくつか処理を簡素化できるかもしれないなぁ、たしかに。</li>
<li>なければ実行するみたいな処理を書きたいことがよくあるし。Javaだとnullで定義しといて、nullだったらみたいなのがあるから。</li>
</ul>
</li>
</ol>
<ul>
<li>
<p><code>Cacher</code>はサンプルだからこの名前でいいけど、自分だと、どんな名前にするかなぁ?</p>
</li>
<li>
<p>振る舞いは難しくなるのか。<code>Cacher実装の限界</code>を読むと。</p>
</li>
<li>
<p>関数にするとスコープが変わるのでアクセスできなくなると。。。コンパイラが教えてくれるのは便利だな。</p>
</li>
<li>
<p>環境から値をキャプチャする3つの方法</p>
<ul>
<li>多分この話が一番クロージャに意味がある話なんだと思う。</li>
</ul>
</li>
</ul>
<h3 id="イテレータ">イテレータ</h3>
<p>回しましょう。</p>
<ul>
<li>便利。ただ、こういう書き方に自分が慣れてないので、そっちを補正しないとなぁ。</li>
<li>どれがイテレータ?っていうのを判別するのがちょっとむずかしい(慣れの問題かなぁ)</li>
<li>イテレータアダプタ便利。どんなのがあるのか?とかがやっとわかってきた。</li>
<li>パフォーマンスに関しては、うーん、どうなんだろう?という感想だった。</li>
</ul>
</content:encoded>
    </item>
    
    <item>
      <title>Rust the book - 第10章</title>
      <link>https://blog.johtani.info/blog/2020/05/28/chap10-rust-the-book/</link>
      <pubDate>Thu, 28 May 2020 18:06:55 +0900</pubDate>
      
      <guid>https://blog.johtani.info/blog/2020/05/28/chap10-rust-the-book/</guid>
      <description>前回の記事はこちら。自分用のメモなので、読みにくいかもです。 Rust the Bookを読み始めた Rust the book - 第4章 Rust the book - 第5章 Rust the book - 第6章 Rust the book - 第8章</description>
      <content:encoded><p>前回の記事はこちら。自分用のメモなので、読みにくいかもです。</p>
<ul>
<li><a href="/blog/2020/03/23/start-reading-rust-the-book/">Rust the Bookを読み始めた</a></li>
<li><a href="/blog/2020/03/26/chap4-rust-the-book/">Rust the book - 第4章</a></li>
<li><a href="/blog/2020/04/02/chap5-rust-the-book/">Rust the book - 第5章</a></li>
<li><a href="/blog/2020/04/07/chap6-rust-the-book/">Rust the book - 第6章</a></li>
<li><a href="/blog/2020/04/16/chap8-rust-the-book/">Rust the book - 第8章</a></li>
<li><a href="/blog/2020/05/14/chap9-rust-the-book/">Rust the book - 第9章</a></li>
</ul>
<h2 id="第10章">第10章</h2>
<p>ジェネリック、トレイト、ライフタイムです。
手強そう。</p>
<p>いきなり関数の切り出し方みたいな話が始まって面食らいました。</p>
<h3 id="ジェネリックなデータ型">ジェネリックなデータ型</h3>
<p>ジェネリックはJavaにもあるので、それほど理解に苦しむことはなかったです。
また、OptionやResultですでに経験済みでしたし。</p>
<p>ただ、<code>impl&lt;T&gt; Point&lt;T&gt;{</code>、このメソッド定義は少し最初は戸惑いました。
言われてみれば、なるほどなんですけど。</p>
<p>コンパイル時にコンパイラが単相化を行うことにより、必要最低限なコードを生成してくるというのは理にかなっているなぁと。</p>
<h3 id="トレイト-共通の振る舞いを定義する">トレイト: 共通の振る舞いを定義する</h3>
<p>出だしにもありますが、「インターフェイス」という機能に類似していると考えると割とすんなりと理解が進みました。
ただ、Javaだと、インターフェースはクラスとセットなため、トレイとの実装に関する記述方法は少し戸惑いが。</p>
<p>デフォルト実装との組み合わせはAbstractに似た処理になるなと考えながら読みすすめました。</p>
<p>「トレイト境界」という日本語には少し違和感を覚えましたが、線引をして、制限をかけるという理解でいいのかな?</p>
<p>実際には<code>#[derive()]</code>などで、トレイトを自分で実装する必要がないなどの、便利機能も用意されており、このあたりのコードの追い方がまだ少し慣れていないかもなぁと。便利なんですけど。。。</p>
<p>少しだけ気になったので、動作確認したのは次の実装です。</p>
<p>トレイトで宣言されている関数と構造体が独自に実装する関数の名前がかぶるとどうなるのかという実験です。
構造体独自のメソッドが優先される感じになりそう。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Tweet</span> {
    <span style="color:#66d9ef">pub</span> username: String,
    <span style="color:#66d9ef">pub</span> content: String,
    <span style="color:#66d9ef">pub</span> reply: <span style="color:#66d9ef">bool</span>,
    <span style="color:#66d9ef">pub</span> retweet: <span style="color:#66d9ef">bool</span>,
}
<span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">trait</span> Summary {
    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">summarize_author</span>(<span style="color:#f92672">&amp;</span>self) -&gt; String;
    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">summarize</span>(<span style="color:#f92672">&amp;</span>self) -&gt; String {
        <span style="color:#75715e">// {}さんからもっと読む
</span><span style="color:#75715e"></span>        format<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;(Read more from {}...)&#34;</span>, self.summarize_author())
    }
}
<span style="color:#66d9ef">impl</span> Tweet {
    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">summarize_author</span>(<span style="color:#f92672">&amp;</span>self) -&gt; String {
        format<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;hoge {}&#34;</span>, self.username)
    }
    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">to_string</span>(<span style="color:#f92672">&amp;</span>self) -&gt; String {
        format<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;fuga&#34;</span>)
    }
}
<span style="color:#66d9ef">impl</span> Summary <span style="color:#66d9ef">for</span> Tweet {
    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">summarize_author</span>(<span style="color:#f92672">&amp;</span>self) -&gt; String {
        format<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;@{}&#34;</span>, self.username)
    }
}
<span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">summary</span><span style="color:#f92672">&lt;</span>T: <span style="color:#a6e22e">Summary</span><span style="color:#f92672">&gt;</span>(hoge: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">T</span>) {
    println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;{}&#34;</span>, hoge.summarize_author());
}
<span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">let</span> tweet <span style="color:#f92672">=</span> Tweet {
        username: String::from(<span style="color:#e6db74">&#34;horse_ebooks&#34;</span>),
        content: String::from(<span style="color:#e6db74">&#34;of course, as you probably already know, people&#34;</span>),
        reply: <span style="color:#a6e22e">false</span>,
        retweet: <span style="color:#a6e22e">false</span>,
    };
    println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;{}&#34;</span>, tweet.summarize_author());
    summary(<span style="color:#f92672">&amp;</span>tweet);
    println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;{}&#34;</span>, Summary::summarize_author(<span style="color:#f92672">&amp;</span>tweet));
}
</code></pre></div><h3 id="ライフタイムで参照を有効化する">ライフタイムで参照を有効化する</h3>
<p>言われてみればそうですが、プログラマが色々考えないとまぁ、行けないんですねという感想。</p>
<p>ただ、借用チェッカーが賢くやってくれるおかげで、全てにライフタイム注釈をつけなくて良くなっているというのがわかりました。
逆に言うと、なんとなくRustを書き始めてしまったので、それを知らずに書いたせいで、コンパイラに怒られてても「?」となっていたのかと。。。</p>
<p>疑問点がいくつかあって、</p>
<ul>
<li>通常はどんなライフタイム注釈をみんな書いてるんだろう?<code>'a</code>とかざっくりしすぎてる?</li>
<li>1つのメソッド、関数にライフタイム注釈が大量に出てくるような書き方をした場合は設計がおかしいのでは?って考えたほうがいいのかも?</li>
<li>ジェネリックな型とライフタイム引数の順序を入れ替えてみても動くだろ?とおもって入れ替えてみたら怒られた。</li>
</ul>
<p>あとは、構造体+ジェネリックが絡んできたら少しこんがらがってきそうっという感じです。
まぁ、これから先は実際に書いてみないことにはわからないんだろうなと。</p>
<h2 id="まとめ">まとめ</h2>
<p>読みました。
実際にはプログラムを書きながら慣れていく感じだろうなぁと。
まだまだ、あれ?ジェネリックってどう書くんだっけ?とか、ライフタイム注釈どうやって付けて、使うときはどうすんだ?みたいになりながら、
出てくるサンプルを少し変えてみてはどうやって動くんだろうこの場合?みたいなことをやってました。
次は、11章、12章を少しだけ自習しつつ、13章に入る予定です(知り合いと一緒に読みすすめてる)。</p>
</content:encoded>
    </item>
    
    <item>
      <title>Rust the book - 第9章</title>
      <link>https://blog.johtani.info/blog/2020/05/14/chap9-rust-the-book/</link>
      <pubDate>Thu, 14 May 2020 18:43:26 +0900</pubDate>
      
      <guid>https://blog.johtani.info/blog/2020/05/14/chap9-rust-the-book/</guid>
      <description>前回の記事はこちら。自分用のメモなので、読みにくいかもです。 Rust the Bookを読み始めた Rust the book - 第4章 Rust the book - 第5章 Rust the book - 第6章 Rust the book - 第8章</description>
      <content:encoded><p>前回の記事はこちら。自分用のメモなので、読みにくいかもです。</p>
<ul>
<li><a href="/blog/2020/03/23/start-reading-rust-the-book/">Rust the Bookを読み始めた</a></li>
<li><a href="/blog/2020/03/26/chap4-rust-the-book/">Rust the book - 第4章</a></li>
<li><a href="/blog/2020/04/02/chap5-rust-the-book/">Rust the book - 第5章</a></li>
<li><a href="/blog/2020/04/07/chap6-rust-the-book/">Rust the book - 第6章</a></li>
<li><a href="/blog/2020/04/16/chap8-rust-the-book/">Rust the book - 第8章</a></li>
</ul>
<h2 id="第9章">第9章</h2>
<p>エラー処理です。
NLP100とか、いくつかのプログラムを書いていて、なんとなくは扱っていますが、きちんと勉強しないと。</p>
<p>とりあえず、「Rustには例外は存在しません。」が一番知っておくことかな。</p>
<h3 id="panicで回復不能なエラー">panic!で回復不能なエラー</h3>
<ul>
<li><code>panic!</code>マクロでスタックを巻き戻して掃除をして終了。
<ul>
<li>異常終了(<code>panic = 'abort'</code>)にもできる。</li>
</ul>
</li>
<li>「<code>RUST_BACKTRACE</code>を0以外の変数にセットして実行」
*</li>
</ul>
<h3 id="resultで回復可能なエラー">Resultで回復可能なエラー</h3>
<ul>
<li><code>expect()</code>は気持ち悪い名前じゃないかなぁ?</li>
<li><a href="https://doc.rust-jp.rs/book/second-edition/ch09-02-recoverable-errors-with-result.html#a%E3%82%A8%E3%83%A9%E3%83%BC%E3%82%92%E5%A7%94%E8%AD%B2%E3%81%99%E3%82%8B">ここ</a>で<code>io::Error</code>ではないものもエラーが発生する場合には</li>
</ul>
<h3 id="panicすべきかするまいか">panic!すべきかするまいか</h3>
<h2 id="まとめ">まとめ</h2>
<p>「Rustには例外は存在しない」ので、回復不能か可能かを考えつつ処理を書こうと。</p>
</content:encoded>
    </item>
    
    <item>
      <title>Rust the book - 第8章</title>
      <link>https://blog.johtani.info/blog/2020/04/16/chap8-rust-the-book/</link>
      <pubDate>Thu, 16 Apr 2020 18:17:30 +0900</pubDate>
      
      <guid>https://blog.johtani.info/blog/2020/04/16/chap8-rust-the-book/</guid>
      <description>前回の記事はこちら。自分用のメモなので、読みにくいかもです。 Rust the Bookを読み始めた Rust the book - 第4章 Rust the book - 第5章 Rust the book - 第6章 第8章 7章はパ</description>
      <content:encoded><p>前回の記事はこちら。自分用のメモなので、読みにくいかもです。</p>
<ul>
<li><a href="/blog/2020/03/23/start-reading-rust-the-book/">Rust the Bookを読み始めた</a></li>
<li><a href="/blog/2020/03/26/chap4-rust-the-book/">Rust the book - 第4章</a></li>
<li><a href="/blog/2020/04/02/chap5-rust-the-book/">Rust the book - 第5章</a></li>
<li><a href="/blog/2020/04/07/chap6-rust-the-book/">Rust the book - 第6章</a></li>
</ul>
<h2 id="第8章">第8章</h2>
<p>7章はパッケージなので後回しにして、8章に入ります。
8章はコレクションです。</p>
<h3 id="ベクタ型">ベクタ型</h3>
<ul>
<li>ベクタは同じ型の値だけ保持可能。
<ul>
<li>ジェネリクスで型を指定可能 - <code>Vec&lt;i32&gt;</code>とか。</li>
</ul>
</li>
<li><code>vec!</code>マクロで初期値とか設定すると便利。</li>
<li>ベクタに値を追加するのは<code>push</code>。もちろん値が変わるので元のベクタには<code>mut</code>が必要</li>
<li>ベクタのスコープ(ライフサイクル)は要素に対する参照があるのとないので話が変わってくる
<ul>
<li>メモリの確保などの影響で、ベクタ全体に対して借用の規則が矯正されると。</li>
</ul>
</li>
<li>ベクタの値を読むのはいくつか方法あり
<ul>
<li><code>get</code>メソッドはOptionを返す</li>
<li><code>&amp;v[2]</code>の添字記法の場合はパニックの可能性あり</li>
</ul>
</li>
<li>走査(唐突に参照外しが出てきた)
<ul>
<li>単純に値を取り出す場合は<code>for - in &amp;v</code></li>
</ul>
</li>
<li>Enumをベクタにいれることで、異なる型も保持可能(まぁ、Enumの型では固定されるけど)。
<ul>
<li>これだけのためにEnumを使うことってあるのかな?</li>
<li>トレイとオブジェクトに関する文章はちょっとわかりにくい。。。</li>
</ul>
</li>
</ul>
<p>説明以外のメソッドなどについてはAPIドキュメント見ましょうと(リンクも張ってくれてると嬉しいなぁと思ったり。まぁ、バージョンとかの絡みがあるから難しいか)。</p>
<h3 id="文字列型">文字列型</h3>
<ul>
<li>
<p>文字列はUTF-8でエンコードされた文字を扱うための型。</p>
</li>
<li>
<p><code>str</code>は文字列データへの参照。</p>
</li>
<li>
<p><code>String</code>型は言語のコアではなく、標準ライブラリに入っている文字列型。</p>
<ul>
<li>他にもあるのか。。。<code>OsString</code>とか。。。</li>
</ul>
</li>
<li>
<p>文字リテラルはDisplayトレイトを実装していると。</p>
</li>
<li>
<p><code>.to_string()</code> = <code>String::from</code></p>
</li>
<li>
<p>Stringはコレクションだから追加とかが可能なのか、なるほど。</p>
</li>
<li>
<p><code>push_str</code>と<code>push</code></p>
</li>
<li>
<p><a href="https://doc.rust-jp.rs/book/second-edition/ch08-02-strings.html#a%E6%BC%94%E7%AE%97%E5%AD%90%E3%81%BE%E3%81%9F%E3%81%AFformat%E3%83%9E%E3%82%AF%E3%83%AD%E3%81%A7%E9%80%A3%E7%B5%90"><code>+</code>演算子での参照</a>。</p>
<ul>
<li><code>&amp;String</code>は<code>&amp;str</code>に型強制(キャスト?)してくれる。してくれる場合としてくれない場合もあるのかな?<code>s2</code>の所有権は奪わない形で扱うので<code>s2</code>はこのあとも使えていると。</li>
<li>ここでは、<code>s1</code>を変更したあとに所有権が<code>s3</code>に持っていかれてる?</li>
<li><code>format!</code>を使うとどの所有権も奪わないので、これを使うほうが考え方は簡単そう。ただし、効率がいいかはわからん。</li>
</ul>
</li>
<li>
<p>添字記法でのアクセスを<code>String</code>は許容していない</p>
<ul>
<li>文字の境界が必ずしも1バイトとは限らないから。</li>
<li>スライスも同様。</li>
</ul>
</li>
<li>
<p>基本的には<code>.chars()</code>で文字としてアクセスするのが良い。</p>
</li>
<li>
<p>逆にバイト表現を得る方法はどうするんだろう?</p>
<ul>
<li><a href="https://github.com/johtani/nlp100-rust/blob/master/src/chapter01/answer.rs#L155">NLP100本ノックでは<code>encode_utf8</code>メソッド使ったけど。</a></li>
</ul>
</li>
</ul>
<h3 id="ハッシュマップ">ハッシュマップ</h3>
<ul>
<li>いろんな呼び方あるよね。Rustではハッシュマップだよ。</li>
<li>ハッシュマップは<code>use</code>しないと使えない</li>
<li>キーは1つの型、値も1つの型</li>
<li>タプルのベクタから<code>collect</code>で生成。なるほど。
<ul>
<li>タプルのベクタだと、タプルの中身は同じものであることが言える?
<ul>
<li>-&gt; 言える。エレメント数が異なるとコンパイルエラーになった</li>
</ul>
</li>
</ul>
</li>
<li><a href="https://doc.rust-jp.rs/book/second-edition/ch08-03-hash-maps.html#a%E3%83%8F%E3%83%83%E3%82%B7%E3%83%A5%E3%83%9E%E3%83%83%E3%83%97%E3%81%A8%E6%89%80%E6%9C%89%E6%A8%A9">所有権周りの話。</a>
<ul>
<li>これ、ベクタのときに話してほしい感じがした。</li>
<li>値を渡すか参照を渡すかによって話が変わってくる。詳しくは10章</li>
<li>このあたりが自分が混乱していた元だ。</li>
</ul>
</li>
<li><code>entry</code>と<code>insert</code>の違い
<ul>
<li><code>entry</code>の戻り値は<code>Entry</code>というenumで<code>or_insert</code>というメソッドがありそれを使うと存在しない場合だけinsertが呼ばれる。
<ul>
<li>これ便利だ。毎回<code>exist</code>あたりで存在チェックしてた気がする。</li>
</ul>
</li>
</ul>
</li>
<li><code>or_insert</code>は可変参照<code>&amp;mut V</code>を返す。
<ul>
<li>これを<code>let count</code>で束縛するときに、中身が可変かどうかをcountには指定しないのか。。。</li>
</ul>
</li>
</ul>
<h2 id="まとめ">まとめ</h2>
<p>一応、大学などで習ってた(はず)ですが、
スタックとヒープを意識して考えないといけないなぁというのを何度か意識させられた感じです。</p>
<p>あと、これはRustに限らずですが、それぞれがどんな関数を持っているか、どんなメソッドを持っているか、どんなマクロが存在するかなどを探すときにみんなどうしてるんだろう?
人に教えてもらっているのか、APIリファレンスを探すのか、そういったところをみんながどういう感じにプログラミング言語を勉強しているか、業務で書いているのかと言うのが気になりました。</p>
</content:encoded>
    </item>
    
    <item>
      <title>Rust the book - 第6章</title>
      <link>https://blog.johtani.info/blog/2020/04/07/chap6-rust-the-book/</link>
      <pubDate>Tue, 07 Apr 2020 19:27:11 +0900</pubDate>
      
      <guid>https://blog.johtani.info/blog/2020/04/07/chap6-rust-the-book/</guid>
      <description>前回の記事はこちら。自分用のメモなので、読みにくいかもです。 Rust the Bookを読み始めた Rust the book - 第4章 Rust the book - 第5章 第6章 Enumです。matc</description>
      <content:encoded><p>前回の記事はこちら。自分用のメモなので、読みにくいかもです。</p>
<ul>
<li><a href="/blog/2020/03/23/start-reading-rust-the-book/">Rust the Bookを読み始めた</a></li>
<li><a href="/blog/2020/03/26/chap4-rust-the-book/">Rust the book - 第4章</a></li>
<li><a href="/blog/2020/04/02/chap5-rust-the-book/">Rust the book - 第5章</a></li>
</ul>
<h2 id="第6章">第6章</h2>
<p>Enumです。<code>match</code>式に大活躍</p>
<h3 id="enumを定義する">Enumを定義する</h3>
<ul>
<li>列挙型は取りうる値をすべて<em>列挙</em>できる。これが名前の由来</li>
<li>列挙型と列挙子
<ul>
<li>2連コロン(<code>::</code>)で列挙子を指定可能</li>
</ul>
</li>
<li>列挙子にデータ(構造体も)が格納可能。
<ul>
<li><a href="https://doc.rust-lang.org/stable/std/net/enum.IpAddr.html">標準ライブラリに実装例あり。</a></li>
</ul>
</li>
<li>疑問:<code>Write(String)</code>とかはタプルの表現になるのかな?
<ul>
<li>と思ったが、タプルでは1つだけの変数を持つものは定義(正確には定義できるが、内部で普通の変数にもどされてるっぽい)できなかった。</li>
</ul>
</li>
<li>メソッド定義も可能
<ul>
<li>関連関数もできる? -&gt; できる</li>
</ul>
</li>
</ul>
<h4 id="optionの紹介">Optionの紹介</h4>
<ul>
<li>Rustに<code>null</code>はない。代わりにOptionがある</li>
<li>Noneを指定する場合に型が必要。Someの場合はすでに値が入るから推測可能なため。</li>
</ul>
<h3 id="match制御フロー演算子">match制御フロー演算子</h3>
<ul>
<li>アーム -&gt; matchしたときの処理のこと
<ul>
<li>短い場合は波括弧は不要</li>
</ul>
</li>
<li>returnなしでmatchが書いてあるだけだと、慣れない場合に値を返していることに気づかないかも(実際気づけてないかも)</li>
<li>Enumが値を持っているときに、値の束縛がmatch式で可能</li>
<li>すべての列挙子を網羅していないことをコンパイラが検知してくれるのはすごく助かる。
<ul>
<li>ただし、<code>_</code>を利用していなければだけど</li>
</ul>
</li>
</ul>
<h3 id="if-letで簡潔な制御フロー">if letで簡潔な制御フロー</h3>
<ul>
<li>enumで1つのパターンのときに処理をしたい場合に使えるmatchの糖衣構文</li>
<li>elseもかけるよ。</li>
</ul>
<h2 id="まとめ">まとめ</h2>
<p>enumに慣れていないので、値や構造体を持つenumを利用するという想像ができないことがありそうだなぁと読みながら思いました。
それになれると、色々とプログラムがシンプルに書ける部分が多くなりそうかな。</p>
</content:encoded>
    </item>
    
    <item>
      <title>Rust the book - 第5章</title>
      <link>https://blog.johtani.info/blog/2020/04/02/chap5-rust-the-book/</link>
      <pubDate>Thu, 02 Apr 2020 15:09:18 +0900</pubDate>
      
      <guid>https://blog.johtani.info/blog/2020/04/02/chap5-rust-the-book/</guid>
      <description>前回の記事はこちら。自分用のメモなので、読みにくいかもです。 Rust the Bookを読み始めた Rust the book - 第4章 第5章 構造体です。勝手知ったるなんとやら?</description>
      <content:encoded><p>前回の記事はこちら。自分用のメモなので、読みにくいかもです。</p>
<ul>
<li><a href="/blog/2020/03/23/start-reading-rust-the-book/">Rust the Bookを読み始めた</a></li>
<li><a href="/blog/2020/03/26/chap4-rust-the-book/">Rust the book - 第4章</a></li>
</ul>
<h2 id="第5章">第5章</h2>
<p>構造体です。勝手知ったるなんとやら?オブジェクト指向的な部分は問題ないかなぁと。</p>
<h3 id="定義とインスタンス化">定義とインスタンス化</h3>
<ul>
<li><code>struct</code>で定義</li>
<li>インスタンスの生成は引数は順不同でOK</li>
<li>構造体のインスタンスを可変にするとフィールドの値も変更可能
<ul>
<li>特定のフィールドのみ可変にすることは不可能</li>
</ul>
</li>
<li>インスタンス化する関数の最後でreturnなしでインスタンスの返却を暗黙にできる(return書いてほしいな。。。)</li>
<li>インスタンス化時にフィールド初期化省略記法が可能(これはちょっと便利?)</li>
<li>構造体更新記法<code>..user1</code>のように、明示的に設定されていない他のフィールドをコピーしてくれる機能あり</li>
</ul>
<h4 id="タプル構造体">タプル構造体</h4>
<ul>
<li>タプル構造体!? <code>struct Color(i32, i32, i32);</code>
<ul>
<li>いつ使うんだろう?</li>
</ul>
</li>
</ul>
<h4 id="ユニット様構造体">ユニット様構造体</h4>
<ul>
<li>ユニット様構造体 = フィールドのない構造体。トレイトを実装したいけどインスタンスで持つ値はない場合に利用</li>
</ul>
<h4 id="ライフタイム">ライフタイム</h4>
<ul>
<li>構造体が参照を持つときにライフタイムという話が出てくる。なるほど。
<ul>
<li>ライフタイム指定子が必要になる -&gt; 10章での話</li>
</ul>
</li>
</ul>
<h3 id="プログラム例">プログラム例</h3>
<ul>
<li>タプルを引数かぁ。タプルは慣れないので構造体作りそう</li>
<li>Debugトレイトと<code>{:?}</code>という書き方
<ul>
<li><code>derive(Debug)</code>でデバッグ用のトレイトを自動で実装=継承してくれる</li>
<li><code>{:#?}</code>だとpretty printになる(改行とか入る)</li>
</ul>
</li>
</ul>
<p>この辺の便利なトレイとは<a href="https://doc.rust-jp.rs/book/second-edition/appendix-03-derivable-traits.html">付録C</a>にあるらしい。この辺はやりながら覚えるしかないか。</p>
<h3 id="メソッド記法">メソッド記法</h3>
<ul>
<li>最初の引数は必ず<code>self</code></li>
<li><code>impl</code>は構造体とは別の場所に書く = Javaのクラスとは違う</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Rectangle</span> {
    width: <span style="color:#66d9ef">u32</span>,
    height: <span style="color:#66d9ef">u32</span>,
}

<span style="color:#66d9ef">impl</span> Rectangle {
    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">area</span>(<span style="color:#f92672">&amp;</span>self) -&gt; <span style="color:#66d9ef">u32</span> {
        self.width <span style="color:#f92672">*</span> self.height
    }
}
</code></pre></div><ul>
<li>参照じゃない<code>self</code>も使えるらしい。どういうときに使うんだろう?</li>
</ul>
<h4 id="関連関数">関連関数</h4>
<ul>
<li><code>self</code>なしの関数をimplにかける。Javaのスタティックメソッドみたいな感じ</li>
</ul>
<h4 id="その他">その他</h4>
<ul>
<li><code>impl</code>ブロックがあちこちにかける。これはつらいな。。。</li>
<li>2つにわかれた<code>impl</code>ブロックに同じメソッドを書いてみたら、CLionのプラグインではエラーを検知してもらえなかった。
<ul>
<li>cargo buildではきちんとエラーが表示された。</li>
</ul>
</li>
<li>
<blockquote>
<p>複数のimplブロックが有用になるケースは第10章で見ますが、そこではジェネリック型と、トレイトについて議論します。</p>
</blockquote>
<ul>
<li>人の構造体に自分のトレイトを適用したりもできる。</li>
</ul>
</li>
</ul>
<h4 id="実験">実験</h4>
<p>スコープとかどうなりそう?って実験もしてみた。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">trait</span> Hoge {
        <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">trim</span>(<span style="color:#f92672">&amp;</span>self);
    }

    <span style="color:#66d9ef">impl</span> Hoge <span style="color:#66d9ef">for</span> String {
        <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">trim</span>(<span style="color:#f92672">&amp;</span>self) {
            println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;hogehoge {}&#34;</span>, <span style="color:#f92672">&amp;</span>self);
        }
    }
    <span style="color:#66d9ef">let</span> c <span style="color:#f92672">=</span> String::from(<span style="color:#e6db74">&#34;hoge&#34;</span>);
    c.trim();
    println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;{}&#34;</span>, fuga(<span style="color:#f92672">&amp;</span>c));
}

<span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">fuga</span>(d: <span style="color:#66d9ef">&amp;</span>String) -&gt; <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">str</span> {
    d.trim()
}
</code></pre></div><p>出力はこんな感じ</p>
<pre><code>hogehoge hoge
hoge
</code></pre><h2 id="まとめ">まとめ</h2>
<p>気になったのは以下の点。そのうち分かるようになってくるのかな。</p>
<ul>
<li>構造体更新記法はどういったときに使うのを想定して作ったんだろう?とか</li>
<li>可変長引数はマクロじゃないとだめ</li>
</ul>
</content:encoded>
    </item>
    
    <item>
      <title>Rust the book - 第4章</title>
      <link>https://blog.johtani.info/blog/2020/03/26/chap4-rust-the-book/</link>
      <pubDate>Thu, 26 Mar 2020 17:12:11 +0900</pubDate>
      
      <guid>https://blog.johtani.info/blog/2020/03/26/chap4-rust-the-book/</guid>
      <description>前回の記事はこちら。自分用のメモなので、読みにくいかもです。 Rust the Bookを読み始めた 第4章 第4章です。たぶん、これがいちばん大事な概念だと思</description>
      <content:encoded><p>前回の記事はこちら。自分用のメモなので、読みにくいかもです。</p>
<ul>
<li><a href="https://blog.johtani.info/blog/2020/03/23/start-reading-rust-the-book/">Rust the Bookを読み始めた</a></li>
</ul>
<h2 id="第4章">第4章</h2>
<p>第4章です。たぶん、これがいちばん大事な概念だと思います、Rustの。
そして、つまみ食いしながらRust書いてましたが、ここがきちんと理解できないまま書いてたってのもあります。。。</p>
<h3 id="所有権とは">所有権とは?</h3>
<ul>
<li><code>drop</code>関数ってのがあって、明示的に呼ぶことも可能。次のような感じで。2つ目の<code>println!</code>はエラーになる。sがもう無いのに借用しようとしてるから。</li>
</ul>
<pre><code>fn main() {
    let mut s = String::from(&quot;hello&quot;);
    s.push_str(&quot;, world!&quot;);
    println!(&quot;{}&quot;, s);
    drop(s);
    println!(&quot;{}&quot;, s);
}
</code></pre><ul>
<li>ムーブ - shallow copyではない。以下の2行目がムーブ。</li>
</ul>
<pre><code>let s1 = String::from(&quot;hello&quot;);
let s2 = s1;

println!(&quot;{}, world!&quot;, s1);
</code></pre><p>スタックとヒープの話が絡んでくる。あんまり意識すること無いよなぁ。
スタック = 固定長のデータを入れる場所。ポインタ、数値など
ヒープ = 可変長のデータが入る場所。可変の文字列とか。</p>
<ul>
<li>クローン - ヒープのデータをコピーすること。</li>
<li>コピー - スタックに収まるデータの場合はクローンが必要なくコピーで事足りる。
<ul>
<li>CopyトレイととDropトレイとは同居できない。</li>
<li>タプルのコピーはややこしそう</li>
</ul>
</li>
<li><a href="https://doc.rust-jp.rs/book/second-edition/ch04-01-what-is-ownership.html#a%E6%89%80%E6%9C%89%E6%A8%A9%E3%81%A8%E9%96%A2%E6%95%B0">所有権と関数</a>でまた、スタックに入れられるような変数と可変のオブジェクトの違いが出てくる。
<ul>
<li><code>takes_ownership(s: String)</code>が参照を受け取れば問題なく、このあとも使える。</li>
<li>戻り値でもムーブが発生</li>
</ul>
</li>
</ul>
<h3 id="参照と借用">参照と借用</h3>
<ul>
<li>借用 - 関数の引数に参照を取ること</li>
<li>可変な参照<code>&amp;mut</code>は1つ(不変な参照も含めて1つ)しか許さない
<ul>
<li>データの競合を防ぐため。</li>
<li>不変な参照を複数用いるのはOK</li>
<li>実際に変更が実行されるタイミングでエラーと判定される場合もある。</li>
</ul>
</li>
</ul>
<pre><code>let mut s = String::from(&quot;hello&quot;);

{
    let r1 = &amp;mut s;

} // r1はここでスコープを抜けるので、問題なく新しい参照を作ることができる

let r2 = &amp;mut s;
</code></pre><ul>
<li>ダングリング参照はテスト書くときとかにやってるかも。。。</li>
</ul>
<pre><code>fn dangle() -&gt; &amp;String { // dangleはStringへの参照を返す

    let s = String::from(&quot;hello&quot;); // sは新しいString

    &amp;s // String sへの参照を返す
} // ここで、sはスコープを抜け、ドロップされる。そのメモリは消される。
  // 危険だ
</code></pre><h3 id="スライス型">スライス型</h3>
<ul>
<li>部分的な参照。開始位置+長さで構成されているっぽい</li>
<li><code>&amp;str</code>の説明がよくわからなかった。</li>
</ul>
<p><a href="https://doc.rust-jp.rs/book/second-edition/ch04-03-slices.html#a%E5%BC%95%E6%95%B0%E3%81%A8%E3%81%97%E3%81%A6%E3%81%AE%E6%96%87%E5%AD%97%E5%88%97%E3%82%B9%E3%83%A9%E3%82%A4%E3%82%B9">引数としての文字列スライス</a>のテクニックは色々と使いまわせそう。</p>
<h2 id="まとめ">まとめ</h2>
<p>所有権、これまで特に難しいと思ってたのは、固定長の変数と、可変長の変数の違いを意識してなかったのが原因っぽい。
まぁ、Vecとかがどうなるのかとか、他にもいくつか気になるところはあるので、もうちょっとやらないといけないなと思いました。</p>
</content:encoded>
    </item>
    
    <item>
      <title>Rust the Bookを読み始めた</title>
      <link>https://blog.johtani.info/blog/2020/03/23/start-reading-rust-the-book/</link>
      <pubDate>Mon, 23 Mar 2020 10:57:22 +0900</pubDate>
      
      <guid>https://blog.johtani.info/blog/2020/03/23/start-reading-rust-the-book/</guid>
      <description>自転車本を読み始めましたが、その前にRust the bookを読んだほうが良いかも?と知り合いと話をしていてなったので、先にRust the bookを読</description>
      <content:encoded><p>自転車本を読み始めましたが、その前にRust the bookを読んだほうが良いかも?と知り合いと話をしていてなったので、先にRust the bookを読み始めてます。
コツコツ読むってのが苦手なので、知り合いと小規模オンライン読書会しながら読むことになりました(基本的になにか書きながら、使い方を調べるので、存在そのものを知らない記述や使用法などがあったりする)。</p>
<ul>
<li><a href="https://doc.rust-jp.rs/book/second-edition/">日本語版Rust the book</a></li>
<li><a href="https://doc.rust-lang.org/book/title-page.html">Rust the book</a></li>
</ul>
<p>基本は日本語版を読んでいます。まずは1章から3章あたり。</p>
<p>気になった点などを。自分用のメモなので、読みやすさとかは考えてないです(あとで自分が死ぬパターン?)。</p>
<h2 id="1章">1章</h2>
<ul>
<li>
<p>rustfmt便利。</p>
<ul>
<li>CLionのRustプラグインでは、保存時にrustfmtするというオプションがある。デフォルトはオフ。&ldquo;Run rustfmt on Save&rdquo;</li>
</ul>
</li>
<li>
<p>cargoの<code>--bin</code>オプション。意識してつけたことなかった=デフォルトだった。</p>
<ul>
<li>ライブラリにするときは<code>--lib</code></li>
</ul>
</li>
</ul>
<h2 id="2章">2章</h2>
<ul>
<li>「変数を値に束縛」という言い回しにまだ慣れない。
<ul>
<li>「代入」という言い方に慣れているから?</li>
<li>ただ、エラーにはassignってあるな。&ldquo;error[E0384]: cannot assign twice to immutable variable <code>x</code>&rdquo;</li>
</ul>
</li>
<li>preludeというのがデフォルトで読み込まれる型が存在する場所。</li>
<li><code>.expect()</code>により、Resultが評価済みになる</li>
<li>マクロがまだ慣れない</li>
<li><code>extern crate rand;</code>が<a href="https://doc.rust-lang.org/book/ch02-00-guessing-game-tutorial.html#generating-a-random-number">最新版だと要らなくなっている</a>。</li>
<li><code>rand::Rng</code>は<code>gen_range</code>のためにuseしている。CLionだとかってにuseを推測して追加してくれた。</li>
<li><code>match</code>はswitch文みたいな感じ。けど、defaultが必ず実行されるって感じではないな。
<ul>
<li>ただし、全て網羅しないと怒られるのが便利。</li>
<li>アームという呼び方が新鮮</li>
<li>単一の式のときは{}が省略できる</li>
<li>ブロック{}のときは、終わりにカンマを入力するとrustfmtが除去する(最後の条件かどうかは関係ない)。</li>
</ul>
</li>
<li>シャドーイングは面白い。
<ul>
<li>よく、<code>hoge_str</code>や<code>hoge_int</code>のような変数を書くので、ありがたい。</li>
<li>ただし、コードを読むときに少し混乱しそう?</li>
</ul>
</li>
<li><code>let ... match</code>で変数への束縛でmatchが使えるのは便利(これまで知らなかったので、変数宣言して条件つけて束縛する処理書いてた)。</li>
</ul>
<h3 id="シャドーイング">シャドーイング?</h3>
<pre><code>fn main() {
    let x = 5;

    let x = x + 1;

    let x = x * 2;

    println!(&quot;The value of x is: {}&quot;, x);
}
</code></pre><p>とか</p>
<pre><code>let spaces = &quot;   &quot;;
let spaces = spaces.len();
</code></pre><p>みたいに、同一変数名を使い回せること。再代入ではない</p>
<h2 id="3章">3章</h2>
<ul>
<li>constは型注釈が必須</li>
<li><code>100_000</code>のような記述が便利(<a href="https://docs.oracle.com/javase/jp/8/docs/technotes/guides/language/underscores-literals.html">Javaもできるって言われてびっくりしたw</a>)</li>
<li>タプルの中身を一部だけ書き換え可能。(mutを指定すれば)
<ul>
<li><code>tup.0 = 20;</code>のような感じで。</li>
</ul>
</li>
<li>配列は固定長でかつ、同一の型のものだけが入る</li>
<li>文末にセミコロンがない場合に四季になるというのはちょっと射にくいので辛いのでは。。。
<ul>
<li>自分は明示的に<code>return</code>を書きたくなる。が、returnだと動かない場合もある。。。</li>
</ul>
</li>
<li><code>let ... if</code>のような記述もできる。</li>
<li><code>(1..4)</code>はRange型</li>
</ul>
<h3 id="おまけ">おまけ</h3>
<p>フィボナッチ数列計算してみろというのがまとめにあったので。こんな感じでいいのかな?</p>
<pre><code>fn calc_fibonacci(n: usize) -&gt; usize {
    if n == 0 {
        return 0;
    } else if n==1 {
        return 1;
    } else {
        return calc_fibonacci(n-1) + calc_fibonacci(n-2);
    }
}
</code></pre><h2 id="その他">その他</h2>
<p>知り合いと読みすすめると、人が不思議に思ったところが、自分が理解が曖昧だったことなどに気づけて便利です。</p>
</content:encoded>
    </item>
    
    <item>
      <title>実践Rust入門の3章を読み終わった</title>
      <link>https://blog.johtani.info/blog/2020/03/02/finish-bicycle-book-chap3/</link>
      <pubDate>Mon, 02 Mar 2020 18:20:13 +0900</pubDate>
      
      <guid>https://blog.johtani.info/blog/2020/03/02/finish-bicycle-book-chap3/</guid>
      <description>これまで 実践Rust入門はじめました 実践Rust入門の3章を読んでるところ 3章終了 3章の終わりまで読み終えた。 いきなり実践的なプログラムで少</description>
      <content:encoded><p>これまで</p>
<ul>
<li><a href="/blog/2020/01/31/start-reading-bicycle-book">実践Rust入門はじめました</a></li>
<li><a href="/blog/2020/02/23/bicycle-book-chap3">実践Rust入門の3章を読んでるところ</a></li>
</ul>
<h2 id="3章終了">3章終了</h2>
<p>3章の終わりまで読み終えた。</p>
<p>いきなり実践的なプログラムで少し面食らっていたが、ステップを追って所有権周りの話まで来たので、
なんとなくRustのいいところが理解できたような気がする。</p>
<p>ただ、最後の<code>split_at_mut</code>が実際には内部でどういう形に変換することによって、コンパイルエラーにならずに、
借用がうまく行っているのかあたりは、まだきちんと理解できていない。</p>
<p>これは、どの言語にも言えるんだけど、リファレンスをうまく読み解きながら、
自分がやりたい処理ができるかどうかを考えるのって結構むずかしいなぁと思う。</p>
<p><code>benchmark.rs</code>はコピペして実行しただけなので、またあとで読み返してみるかな。</p>
<p>ということで、ここから先は、基本を勉強する感じで4章から読みつつ、なんかプログラムをまた書いてみるか。</p>
</content:encoded>
    </item>
    
    <item>
      <title>実践Rust入門の3章を読んでるところ</title>
      <link>https://blog.johtani.info/blog/2020/02/23/bicycle-book-chap3/</link>
      <pubDate>Sun, 23 Feb 2020 16:37:17 +0900</pubDate>
      
      <guid>https://blog.johtani.info/blog/2020/02/23/bicycle-book-chap3/</guid>
      <description>これまでのはこちら。読書メモなので、本と合わせて読んでいただくのが良いです。 実践Rust入門はじめました 3章のクイックツアーを読んでます。 バ</description>
      <content:encoded><p>これまでのはこちら。読書メモなので、本と合わせて読んでいただくのが良いです。</p>
<ul>
<li><a href="/blog/2020/01/31/start-reading-bicycle-book">実践Rust入門はじめました</a></li>
</ul>
<p>3章のクイックツアーを読んでます。
バイトニックソート自体の理解はちょっとおいておいて、読み進めています。
いくつか疑問に思ったことがあったので、またメモを。
まだ、3.5.7の手前ですが。</p>
<h2 id="疑問点">疑問点</h2>
<ol>
<li>
<p>3.4.1のジェネリクス対応のテストケースの部分で、既存のu32用のテストケースの入力のデータ列に<code>Vec&lt;u32&gt;</code>という型注釈をつけるのですが、
追加した文字列の入力データには注釈をここではつけないのはなんでなんだろう?<em>ちなみに、なくても動いた。バージョンの違いとかあるのかしら?</em></p>
</li>
<li>
<p>3.4.6のmatch文</p>
<ul>
<li><code>match</code>文の引数?が<code>*order</code>になっていたが、<code>order</code>でも実行できた。引数にくるのが参照だから<code>*</code>が付いてるんだとも運だが、なくても動くのはコンパイラがよしなに解釈してくれてるからかな?</li>
</ul>
</li>
</ol>
<h2 id="便利なツール">便利なツール</h2>
<p>Rust標準のツールの説明がいくつか3章で紹介されてて便利だったのでメモ。</p>
<ol>
<li>rustfmt</li>
</ol>
<p>フォーマッター。デフォルトでフォーマット機能が付いてるの便利ですね。言語として決まってると、プロジェクトごとに悩まなくていいってのがありますし。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-zsh" data-lang="zsh">rustfmt ファイル名
</code></pre></div><p>という形で使えるみたい。
プロジェクトごとだと<code>cargo fmt</code>のほうが楽そうかな。</p>
<ol start="2">
<li>標準ライブラリAPIドキュメントをブラウザで閲覧</li>
</ol>
<pre><code>rustup doc --std
</code></pre><p>これでデフォルトブラウザでRustの公式ドキュメントが開きます。
しかもローカルファイルだからサクサク。検索バーもついてて便利です。</p>
<ol start="3">
<li>エラーのドキュメントを閲覧</li>
</ol>
<pre><code>rustc --explain 308
</code></pre><p>コンパイル時にエラーが出たときに、<code>error[E0308]</code>のようにコンソールに出てきます。
ヒントも出てくるのですが、詳細が上記のコマンドで読めるみたいです。</p>
</content:encoded>
    </item>
    
    <item>
      <title>実践Rust入門はじめました</title>
      <link>https://blog.johtani.info/blog/2020/01/31/start-reading-bicycle-book/</link>
      <pubDate>Fri, 31 Jan 2020 21:58:12 +0900</pubDate>
      
      <guid>https://blog.johtani.info/blog/2020/01/31/start-reading-bicycle-book/</guid>
      <description>実践Rust入門という本を買っていた(去年の7月だ。。。)のですが、積んであったので、時間を作って読み始めようかと。 実践Rust入門[言語仕</description>
      <content:encoded><p>実践Rust入門という本を買っていた(去年の7月だ。。。)のですが、積んであったので、時間を作って読み始めようかと。</p>


<div class="amazon-shortcode-box">
  <div class="amazon-shortcode-image">
    <a style="display: inline-block;" target="_blank" href="https://www.amazon.co.jp/gp/product/4297105594/?tag=johtani-22">
      <img border="0" src="//ws-fe.amazon-adsystem.com/widgets/q?_encoding=UTF8&MarketPlace=JP&ASIN=4297105594&ServiceVersion=20070822&ID=AsinImage&WS=1&Format=_SL160_&tag=johtani-22" >
    </a>
  </div>
  <div class="amazon-shortcode-info">
    <p class="amazon-shortcode-title">
      <a target="_blank" href="https://www.amazon.co.jp/gp/product/4297105594/?tag=johtani-22">
      実践Rust入門[言語仕様から開発手法まで] | κeen, 河野 達也, 小松 礼人 |本 | 通販 | Amazon
      </a>
    </p>
  </div>
</div>
<h2 id="経緯">経緯</h2>
<p>もともとは、<a href="/blog/2018/02/14/start-nlp100-with-rust/#undefined">言語処理100本ノックはじめました(Rust)</a>という感じで、触っていたのですが、場当たり的にやってても時間を持っていかれるだけだなということに気づいたのが最初です。</p>
<p>今年の目標は、覚えられなので、ちょっとずつでもアウトプットしていこうってのもあり、
読書記録をつけつつ、読んでいこうかなぁと。</p>
<h2 id="どこまで読んだ">どこまで読んだ?</h2>
<p>2章の<code>2-2-5</code>までです。
前回、Rustの環境はセットアップしていたのですが、新PCに切り替わったので、<code>rustup</code>からはじめました。</p>
<h3 id="rustup">rustup</h3>
<p><code>rustup</code>ではデフォルト設定のままではなく、<code>PATH</code>変数の書き換えだけはしない形でインストールを行いました。</p>
<p><code>PATH</code>変数は<code>.zshrc</code>ファイルで変更したかったためです(<code>rustup</code>コマンドに変更して貰う場合は<code>.profile</code>などのファイルが変更されそうだったため)。</p>
<p>インストールが終わったあとに<code>.zshrc</code>に以下の行を追加しました。</p>
<pre><code>### For Rust env
source $HOME/.cargo/env
</code></pre><h2 id="疑問点">疑問点</h2>
<p>ここまで読んだ疑問点です。</p>
<ol>
<li><code>cargo new hello</code>したあとに<code>main.rs</code>に以下の<code>main()</code>関数が出来上がっている!?</li>
</ol>
<pre><code>fn main() {
    println!(&quot;Hello, world!&quot;);
}
</code></pre><p>驚きましたが、<code>cargo new hoge</code>ってやっても、おなじ<code>main.rs</code>ができてました。デフォルトで出来上がるんですね。どんな超能力!?と思ってしまいましたw</p>
<ol start="2">
<li><code>cargo new hello</code>して出来上がった<code>Cargo.toml</code>に著者名が入力されていた。</li>
</ol>
<pre><code>authors = [&quot;Jun Ohtani &lt;メアド&gt;&quot;]
</code></pre><p>なんで?と思いました。まだ解明してないです。
本を読んでいけばわかるかな?</p>
<ul>
<li>予想:gitの設定(<code>~/.gitconfig</code>)に氏名とメアドが設定されているので、これを利用しているのかな?</li>
</ul>
</content:encoded>
    </item>
    
    <item>
      <title>ポモドーロ回してます。（ポモドーロテクニック入門読みました）(Jugemより移植)</title>
      <link>https://blog.johtani.info/blog/2013/05/03/%E3%83%9D%E3%83%A2%E3%83%89%E3%83%BC%E3%83%AD%E5%9B%9E%E3%81%97%E3%81%A6%E3%81%BE%E3%81%99%E3%83%9D%E3%83%A2%E3%83%89%E3%83%BC%E3%83%AD%E3%83%86%E3%82%AF%E3%83%8B%E3%83%83%E3%82%AF%E5%85%A5%E9%96%80%E8%AA%AD%E3%81%BF%E3%81%BE%E3%81%97%E3%81%9F/</link>
      <pubDate>Fri, 03 May 2013 23:42:19 +0900</pubDate>
      
      <guid>https://blog.johtani.info/blog/2013/05/03/%E3%83%9D%E3%83%A2%E3%83%89%E3%83%BC%E3%83%AD%E5%9B%9E%E3%81%97%E3%81%A6%E3%81%BE%E3%81%99%E3%83%9D%E3%83%A2%E3%83%89%E3%83%BC%E3%83%AD%E3%83%86%E3%82%AF%E3%83%8B%E3%83%83%E3%82%AF%E5%85%A5%E9%96%80%E8%AA%AD%E3%81%BF%E3%81%BE%E3%81%97%E3%81%9F/</guid>
      <description>アジャイルな時間管理術 ポモドーロテクニック入門 ポモドーロテクニック入門という本を読みました。 きっかけは、Twitter上で何度か「ポモドーロ</description>
      <content:encoded><p>

<div class="amazon-shortcode-box">
  <div class="amazon-shortcode-image">
    <a style="display: inline-block;" target="_blank" href="https://www.amazon.co.jp/gp/product/4048689525/?tag=johtani-22">
      <img border="0" src="//ws-fe.amazon-adsystem.com/widgets/q?_encoding=UTF8&MarketPlace=JP&ASIN=4048689525&ServiceVersion=20070822&ID=AsinImage&WS=1&Format=_SL160_&tag=johtani-22" >
    </a>
  </div>
  <div class="amazon-shortcode-info">
    <p class="amazon-shortcode-title">
      <a target="_blank" href="https://www.amazon.co.jp/gp/product/4048689525/?tag=johtani-22">
      アジャイルな時間管理術 ポモドーロテクニック入門
      </a>
    </p>
  </div>
</div>
ポモドーロテクニック入門という本を読みました。
きっかけは、Twitter上で何度か「ポモドーロ」という単語を何度か見ていたためです。
最初は、なんだろう？というのが発端です。
「ポモドーロ＝トマト」なのですが、実際にはトマト型のキッチンタイマーが元になっているらしいです。
このタイマーを使った時間（タスク）管理術がポモドーロ・テクニックです。</p>
<p>私は、ここ数年、複数の仕事がパラで走ることが時々ありました。
このような場合に、日によって異なる複数のタスクが存在します。
このとき、異なるタスクにスイッチするのに結構な時間を取られます。。。
また、急な割り込みが入った時も同様に、以前のタスクに戻るのになにしてたっけ？となることが多々あります。
普通に自己管理ができている方なら問題ないのでしょうが、私は結構ニガテでした。
そのようなときに、Twitter上で「ポモドーロ」という単語を見かけて、軽くググってみたところ、
タスク管理、時間管理によさそうな本だったので、その点を矯正するのも兼ねて、読んだ次第です。
また、タスクに集中できるという利点もあるそうです。</p>
<p>本については、少し読みにくいところがありました。
ポモドーロテクニックとはどんなものかという全体像や単語に関する説明がないままに、話が進んでいくので。。。
1度読み終わったあとに実践しながらパラパラめくっているような状況です。
実際には、個々人のやり方などを考慮しながら、改善していくべきなのもあり、型を説明してないのかもしれないですが、もうすこし概観がわかる感じのほうが良かったです。</p>
<p>で、4月初旬くらいから実践してみています。
効果が実際にあるかというと、まだわからないです。</p>
<p>私がポモドーロテクニックに利用しているのはキッチンタイマーではなく、<a href="http://code.google.com/p/pomodairo/">pomodairo</a>というAdobeAIR上で動くアプリになります。
ほかにも<a href="http://www.pomodoroapp.com">PomodoroApp</a>というのもあるのですが、Free版だと登録できるタスクの上限があったので、pomodairoを選びました。（今見たら、3.0にバージョンが上がって、Limitがなくなってるかも）
AIRだと、WinでもMacでも動作するのというも決定した要因です。</p>
<p>まだ、1ヶ月経ってませんが、私が実践してきて良かった点、できてない点、うまくいってない点はつぎのような感じです。</p>
<h3 id="良かった点">良かった点</h3>
<hr>
<ul>
<li>目の前のタスクに集中できる。（25分スパンなので、Twitterを意識的に見なくできる。。。）</li>
<li>適度な休憩が挟める。25分に5分の休憩が入るので、適度な没頭になる（没頭し過ぎない）</li>
<li>自宅で作業するときにかなり有効。（5分の休憩時にTwitterやFB以外に漫画をパラパラ読んだりもできるので）</li>
</ul>
<p>ということで、自宅で作業するときには結構いいです。
自宅ですと、pomodairoを使っていてタイマーの音を気兼ねなく出せるので、きちんとポモドーロが回せます。</p>
<h3 id="できてない点">できてない点</h3>
<hr>
<ul>
<li>アクティビティ在庫管理。個人的にJIRAを使っていて、そこで管理しようと思っているのですが、うまくできてないです。pomodairoのアプリにもタスクを登録しているのもあり2重登録などを手間に思ってしまって。。。</li>
<li>レコーディングと今日のTodo作成。</li>
<li>インタラプトの記録</li>
</ul>
<p>アクティビティ在庫管理ができてないのは、レコーディングがきちんと出来てないためでしょう。。。
二重管理になっている＋pomodairoで統計情報が出るが、当日分の統計情報がレコーディングできてないというのが痛いです。
また、このレコーディングが出来てないので、効果が出ているかがわからないという問題かと。。。
きりが悪かったりして、どうしても、仕事時間ギリギリまでタスクをこなしてしまい、レコーディング＋アクティビティ在庫の管理の時間が取れていません。
ここは意識してちゃんとやらないと意味がないよなぁと。今後の大きな課題です。</p>
<h3 id="うまくいってない点">うまくいってない点</h3>
<hr>
<p>できてない（やろうとしてできてない）点とは別に、どうもしっくり来ていないのがつぎのような点です。</p>
<ul>
<li>プログラミングしていると、25分のタイマーで区切りがすごく悪い時がおおい</li>
<li>自宅以外でのタイマー音が出せない</li>
<li>自宅以外での休憩の取り方</li>
</ul>
<p>プログラミングをやっていて、乗ってきたタイミングでタイマーが鳴ってしまったり、
ちょっと頭のなかで整理していたあとの今まさに、頭のなかにある処理の流れをコードに落としている途中でタイマーがなってしまったり。
このような状況だと、休憩に入れなくて、ずるずるとコーディングを続けてしまうということが多々あります。
メモ（ソース上のコメントや手元）を残して休憩すればいいのでしょうが、どうしても今までの癖もありズルズルとやってしまい、すごく時間が経ってることが何度もあります。
ポモドーロテクニック的にはやはりNGなんでしょうが、なかなか治らない＋治したくない気もしています。
また、自宅以外の場合、基本的には自社ではなく客先に出ていることが多いのでどうしても音を出すことができません。
これもまた、切り替えができない要因になっています。
タイマーだけ携帯のアプリを使用しするという手もあるのでしょうが、この場合さらにレコーディングが出来ない状況に陥りそうで。。。
また、スマホだと電池が持たないのも問題点です。（Twitterを見るのに利用してるから電池が持たないという話もあるのですが。。。）
レコーディングに関しては、手描きのメモを使うのがいいのかなぁと。本では＋や◎などの印を付けるだけにしておけば良いとありますが、アプリのタイマーだと自動でそれができるので、悩みどころです。
最後の休憩の取り方も、ネットやTwitterを見るのもありなのですが、画面から離れる休憩を取りたいなぁと思うところもあり。。。
職場だと技術書やWEB+DBのような雑誌はあるのですが、休憩にはあまり向いていないなぁと。</p>
<p>つらつらと書いて来ましたが、本を読んで、1ヶ月実践してきた（できてないとこも多いが）現状をメモしておきます。
こうやってるよ、こうしたら良かったよ、こうしてみれば？などありましたら、コメントいただけると助かります。</p>
<p>来週以降はとりあえず、JIRAできちんとアクティビティ在庫管理をしながら、1日の結果をレコーディングしていくのを意識していこうと思います。</p>
</content:encoded>
    </item>
    
    <item>
      <title>「コード・シンプリシティ」を読みました。（Kindle paperwhiteの使い勝手の確認も兼ねて）(Jugemより移植)</title>
      <link>https://blog.johtani.info/blog/2013/01/09/%E3%82%B3%E3%83%BC%E3%83%89%E3%82%B7%E3%83%B3%E3%83%97%E3%83%AA%E3%82%B7%E3%83%86%E3%82%A3%E3%82%92%E8%AA%AD%E3%81%BF%E3%81%BE%E3%81%97%E3%81%9Fkindle-paperwhite%E3%81%AE%E4%BD%BF%E3%81%84%E5%8B%9D%E6%89%8B%E3%81%AE%E7%A2%BA%E8%AA%8D%E3%82%82%E5%85%BC%E3%81%AD%E3%81%A6/</link>
      <pubDate>Wed, 09 Jan 2013 00:28:00 +0900</pubDate>
      
      <guid>https://blog.johtani.info/blog/2013/01/09/%E3%82%B3%E3%83%BC%E3%83%89%E3%82%B7%E3%83%B3%E3%83%97%E3%83%AA%E3%82%B7%E3%83%86%E3%82%A3%E3%82%92%E8%AA%AD%E3%81%BF%E3%81%BE%E3%81%97%E3%81%9Fkindle-paperwhite%E3%81%AE%E4%BD%BF%E3%81%84%E5%8B%9D%E6%89%8B%E3%81%AE%E7%A2%BA%E8%AA%8D%E3%82%82%E5%85%BC%E3%81%AD%E3%81%A6/</guid>
      <description>年末から年始にかけて、「コード・シンプリシティ」を読みました。 先日の記事にも書きましたが、Kindle paperwhiteを思いかけず入手で</description>
      <content:encoded><p>年末から年始にかけて、「<a href="http://booklog.jp/item/11/9784873115757">コード・シンプリシティ</a>」を読みました。</p>
<p>先日の記事にも書きましたが、Kindle paperwhiteを思いかけず入手できたので、eBookを読みたいなぁと思いまして。
Kindleのお試しも兼ねて読んでみました。</p>
<p><strong>まずは、本の感想。</strong>
短めの書籍＋読み物なので、サクっと読めました。
題名に「コード」と書かれていますが、コードの実例が出てくる書籍ではありません。
「ソフトウェア」を以下にシンプルに保って、管理しやすくするか、機能追加、テストをやりやすくするかといった指針について書かれています。
機能追加に関して検討しないといけないバランス（先読みしすぎずと実装しすぎないとか）の話や定期的なデザインの見直しなどについても書かれています。
ソフトウェアに関しては動くこともだが、デザインが重要であること。（確かに。）
すでにあるソフトウェアについて、どのように簡潔にしていくかという話もありました。
ただ、読んでいて一番重要だと思ったのは、「悪いプログラマーと良いプログラマーの違いは理解力だ」という一文です。
何をしているかを「理解」していないと、根本的な問題点の解決もできないですし、どうすればコードが簡潔になるかといったこともわからないです。
また、やっている作業がどんなもので、何のためにやっているのか、それを行うことで今後にどのような影響があるのかといったことも理解しておく必要があるかと。
ま、ある程度考えながら作業とかしましょうってことですかね。（強引なまとめかも。。。）</p>
<p><strong>で本題です。</strong>
Kindle paperwhiteとiPadの使い分けを検討するのも兼ねて本を読んでました。
iPadを持っているのもあり、Kindleはそもそも眼中になかったのですが、めっけ物でした。
やはり実際に使ってみないとわからないことありますねぇと。
paperwihteはつぎのような利点があるかと。</p>
<ul>
<li>読書に没頭できる。→本を読むというシンプルな目的を達成するものだけが実装されている</li>
<li>目が疲れない→Twitterでも話に上がったのですが、液晶とは異なり字が読みやすいです</li>
<li>軽いし小さい→電車で立っていても楽に持てるし、カバンからの出し入れも楽です（iPadに比べて）</li>
<li>複数の端末のKindleアプリで同期できる。→あまり異なる端末では読まないですが、paperwhiteで読んだところが、iPadでも同期されるのですんなり続きが読めます</li>
<li>電池長持ち</li>
</ul>
<p>ということで、本を読むのに没頭できるし目が疲れないと。
ただ、つぎの点では不満もあります。</p>
<ul>
<li>PDFは読みにくい。→画面のサイズが小さいので大きめの書籍のPDF版は読みにくいです。</li>
<li>PDFは読みにくい。→文字のサイズを変更できないのもキツイです。Kindle専用のmobi形式の書籍が読みやすいです</li>
<li>ページめくりに一定時間がかかる→紙の書籍やiPadで書籍を読むのとは異なり、ページをめくるのに時間がかかります。e-inkの再描画の問題かと。パラパラと書籍を読みたい場合は厳しいです</li>
<li>白黒。カラーの電子書籍は読めないですねぇ</li>
<li>ソースコードなどもキツイ→長めのコードが書いてある本だとコードが頭に入ってこないです。。。</li>
</ul>
<p>という感想でした。
今後は基本Kindle paperwhiteを持ち歩きmobi形式の本を読むようにすると思います。
iPadは自炊本やカラーの本を読むとき、映像、ネットを見るような場合に持ち歩くことになりそうです。
私は基本的にMBAを持ち歩いているというのもあるので、paperwhiteのほうが主流になりそうです。
ネットを見るときなどは最悪、MBAを開くでしょうし。
小説とかをメインに読むのであれば断然、paperwhiteだと思います（最近読んでないなぁ）</p>
</content:encoded>
    </item>
    
    <item>
      <title>「IDの秘密」を読みました。(Jugemより移植)</title>
      <link>https://blog.johtani.info/blog/2012/04/30/id%E3%81%AE%E7%A7%98%E5%AF%86%E3%82%92%E8%AA%AD%E3%81%BF%E3%81%BE%E3%81%97%E3%81%9F/</link>
      <pubDate>Mon, 30 Apr 2012 23:03:55 +0900</pubDate>
      
      <guid>https://blog.johtani.info/blog/2012/04/30/id%E3%81%AE%E7%A7%98%E5%AF%86%E3%82%92%E8%AA%AD%E3%81%BF%E3%81%BE%E3%81%97%E3%81%9F/</guid>
      <description>IDの秘密 (丸善ライブラリー―情報研シリーズ) 非常に面白く読めました。 バーコードの話に始まり、最後はシステムで付与するIDに関する考慮点まで</description>
      <content:encoded><p>

<div class="amazon-shortcode-box">
  <div class="amazon-shortcode-image">
    <a style="display: inline-block;" target="_blank" href="https://www.amazon.co.jp/gp/product/4621053809/?tag=johtani-22">
      <img border="0" src="//ws-fe.amazon-adsystem.com/widgets/q?_encoding=UTF8&MarketPlace=JP&ASIN=4621053809&ServiceVersion=20070822&ID=AsinImage&WS=1&Format=_SL160_&tag=johtani-22" >
    </a>
  </div>
  <div class="amazon-shortcode-info">
    <p class="amazon-shortcode-title">
      <a target="_blank" href="https://www.amazon.co.jp/gp/product/4621053809/?tag=johtani-22">
      IDの秘密 (丸善ライブラリー―情報研シリーズ)
      </a>
    </p>
  </div>
</div>
非常に面白く読めました。
バーコードの話に始まり、最後はシステムで付与するIDに関する考慮点まで幅広くIDについて語られています。</p>
<p>適度に配置されたコラムがまた面白く、ここまで書いてもいいのかな？と思いながらも楽しく読ませて頂きました。
2次元バーコードが汚れに強いのも知らなかったし、チロルチョコの話は知らなかったし、指コレクションとか面白すぎです。
また、JRのSuicaの導入に7年もかけている点などは、やはりすごい技術なのだなぁというため息混じりの感想です。
それほど長い期間のテストや設計は想像がつかないです。</p>
<p>最後の2章（７，８章）については、エンジニアの以外のシステムに関わる方やエンジニアになられたばかりの方たちにぜひ読んで欲しいと思いました。
もちろん、エンジニアの方にも読んでほしい内容です。</p>
<p>いくつか疑問点や気になる点もあったので。</p>
<ul>
<li>「静脈や指紋が人によって異なるって確率はどうやって決めたんだろう？」</li>
<li>Twitterの説明文のあとにFBの画面の図番号が書いてある。</li>
<li>日本語がデコードされたけど、QRコードの文字コードって、この中に含まれてるのかな？それとも規格で決まってるのかな？</li>
</ul>
<p>最後に、<a href="http://yfrog.com/nuepmlrj">書影がNIIに合ったので撮影しました。写真へのリンク</a>です。</p>
</content:encoded>
    </item>
    
    <item>
      <title>「自分の小さな「箱」から脱出する方法」を読みました。(Jugemより移植)</title>
      <link>https://blog.johtani.info/blog/2012/03/20/%E8%87%AA%E5%88%86%E3%81%AE%E5%B0%8F%E3%81%95%E3%81%AA%E7%AE%B1%E3%81%8B%E3%82%89%E8%84%B1%E5%87%BA%E3%81%99%E3%82%8B%E6%96%B9%E6%B3%95%E3%82%92%E8%AA%AD%E3%81%BF%E3%81%BE%E3%81%97%E3%81%9F/</link>
      <pubDate>Tue, 20 Mar 2012 23:32:00 +0900</pubDate>
      
      <guid>https://blog.johtani.info/blog/2012/03/20/%E8%87%AA%E5%88%86%E3%81%AE%E5%B0%8F%E3%81%95%E3%81%AA%E7%AE%B1%E3%81%8B%E3%82%89%E8%84%B1%E5%87%BA%E3%81%99%E3%82%8B%E6%96%B9%E6%B3%95%E3%82%92%E8%AA%AD%E3%81%BF%E3%81%BE%E3%81%97%E3%81%9F/</guid>
      <description>TLで面白いと見かけて、Amazonで買ってしまいました。 SEやってるのに、つい最近Amazonを使い始めた軟弱者です。 それにしてもAmaz</description>
      <content:encoded><p>TLで面白いと見かけて、Amazonで買ってしまいました。
SEやってるのに、つい最近Amazonを使い始めた軟弱者です。
それにしてもAmazon危険です。スマートフォンにAmazonの
Androidアプリを入れたのですが、これがまた、レコメンドに面白そうな本が出てきて危険です。</p>
<p>話がそれてしまいましたが、面白い本でした。
久々に、小説でも技術書でもない本を短期間で読みました。
「箱」と呼ばれる概念の中と外について、とある会社に転職した管理職の人が学んでいくという物語風の作りです。
いくつか、自分の経験にカブるシーンがあったので、サクサク読めました。
今までの自分になかった考えである「箱」という視点が得られたのがよかったです。</p>
<p>ただ、いくつか気になる点もあるので、また少し時間を開けてからサラっと流し読みしたいと思います。</p>
<p>あと、すこしだけ、キリスト教チックな考え方でもあるかなぁと思う部分もありました。（キリスト教をちゃんと勉強してるわけではないので認識が間違ってるかもしれないです）</p>
<p>人によっては共感出来なかったり、読みにくかったりすると思いますが、私は面白いと思った本でした。
なんとなく、人間関係に違和感を感じていることがある場合は目を通してみるといいかもしれません。</p>
<p>Twitterで読み終えたというツイートをしたら、<a href="http://twitter.com/#!/ledsun/status/182100538727473152?PHPSESSID=43e66de98af6cc0a11e1a6953d2619a2">「自分を変える気づきの瞑想法」を読むとまた面白いですという＠ツイート（これがmentionの日本語の正式名称らしい？）</a>を<a href="http://twitter.com/ledsun">@ledsun</a>いただきました。
箱に入る原理が別の視点で書かれているようです。
読んでみたいです。（本会過ぎてる気がするので、図書館で探そうかなぁ。。。）</p>
<hr>
<p>

<div class="amazon-shortcode-box">
  <div class="amazon-shortcode-image">
    <a style="display: inline-block;" target="_blank" href="https://www.amazon.co.jp/gp/product/490450786X/?tag=johtani-22">
      <img border="0" src="//ws-fe.amazon-adsystem.com/widgets/q?_encoding=UTF8&MarketPlace=JP&ASIN=490450786X&ServiceVersion=20070822&ID=AsinImage&WS=1&Format=_SL160_&tag=johtani-22" >
    </a>
  </div>
  <div class="amazon-shortcode-info">
    <p class="amazon-shortcode-title">
      <a target="_blank" href="https://www.amazon.co.jp/gp/product/490450786X/?tag=johtani-22">
      自分を変える気づきの瞑想法【増補改訂版】
      </a>
    </p>
  </div>
</div>


<div class="amazon-shortcode-box">
  <div class="amazon-shortcode-image">
    <a style="display: inline-block;" target="_blank" href="https://www.amazon.co.jp/gp/product/490450786X/?tag=johtani-22">
      <img border="0" src="//ws-fe.amazon-adsystem.com/widgets/q?_encoding=UTF8&MarketPlace=JP&ASIN=490450786X&ServiceVersion=20070822&ID=AsinImage&WS=1&Format=_SL160_&tag=johtani-22" >
    </a>
  </div>
  <div class="amazon-shortcode-info">
    <p class="amazon-shortcode-title">
      <a target="_blank" href="https://www.amazon.co.jp/gp/product/490450786X/?tag=johtani-22">
      自分を変える気づきの瞑想法【増補改訂版】
      </a>
    </p>
  </div>
</div></p>
</content:encoded>
    </item>
    
    <item>
      <title>Clean Coderを読んだ(Jugemより移植)</title>
      <link>https://blog.johtani.info/blog/2012/03/03/clean-coder%E3%82%92%E8%AA%AD%E3%82%93%E3%81%A0/</link>
      <pubDate>Sat, 03 Mar 2012 01:14:00 +0900</pubDate>
      
      <guid>https://blog.johtani.info/blog/2012/03/03/clean-coder%E3%82%92%E8%AA%AD%E3%82%93%E3%81%A0/</guid>
      <description>Clean Coder プロフェッショナルプログラマへの道 Clean Coderを読みました。 理由はTwitterで「Clean Code」がいい本だと流れてきたためです。</description>
      <content:encoded><p>

<div class="amazon-shortcode-box">
  <div class="amazon-shortcode-image">
    <a style="display: inline-block;" target="_blank" href="https://www.amazon.co.jp/gp/product/4048860690/?tag=johtani-22">
      <img border="0" src="//ws-fe.amazon-adsystem.com/widgets/q?_encoding=UTF8&MarketPlace=JP&ASIN=4048860690&ServiceVersion=20070822&ID=AsinImage&WS=1&Format=_SL160_&tag=johtani-22" >
    </a>
  </div>
  <div class="amazon-shortcode-info">
    <p class="amazon-shortcode-title">
      <a target="_blank" href="https://www.amazon.co.jp/gp/product/4048860690/?tag=johtani-22">
      Clean Coder プロフェッショナルプログラマへの道
      </a>
    </p>
  </div>
</div>
Clean Coderを読みました。
理由はTwitterで「Clean Code」がいい本だと流れてきたためです。
「Clean Code」はまだ読んでいないのですが、クリーンなコード（メンテナンスしやすく、修正などもやりやすいコード？）を書くために必要な話が書いてあるのだと思います。（まだ妄想）</p>
<p>そして、何も考えずに、「Clean Code”r”」という本が新しく出ていたので、新しい方に手を出しました。
まぁ、軽い勘違いですｗ（コードの構造の話などは出てこなかったです。）
それほど分厚くなく、軽く読めそうだということで読み進めると軽い衝撃を受けました。
Clean Coderはプロのプログラマとして、どのような意識を持つべきか、立ち居振る舞いをするべきかなどが書かれています。
「～したい」はまず守らない約束だという話、ユニットテストを書くことはプロとして当たり前の行為だ、目的意識を明確に持つことなどなど、耳の痛いことが色々と書かれています。
これは、著者の方（パンチカードのころからコーディングをされている！）の実体験を元に、失敗した経験から導きだされているようです。
ところどころ、古くてよくわからない話やちょっとだけしっくりこない表現（ビジネス、QAといった単語）もありましたが、概ねわかりやすい話でした。</p>
<p>基本的にはアジャイルなスタイルの開発を行うプログラマ（設計書に基づいてコーディングするだけの人ではない）について書かれています。
この本を読んでいて、昨年、仕事をご一緒させていただいたRubyistの方たちの開発スタイルを思い出しました。
私よりもこの本に書かれているプロに近いなぁと。
ペアプロやったり、実装方法について相談していたりと。</p>
<p>勘違いでしたが、良い本に出会えて本当によかったです。
私もこの本に書かれているようなチームでのプログラミングをやりたい、またなにかコーディングをしたいという気にさせてくれました。（「～したい」じゃダメって書いてあったのに。。。）
自分を戒めるためにも、定期的に読み返したい本です。
プログラマでいたい方、ある程度プログラミングができるようになってきた方にはぜひ読んでいただきたい本です。
（この流れで、アジャイルサムライやClean Codeを読んだら理解が深まりそうだなぁ）</p>
<hr>
<p>参考URL：
<a href="http://d.hatena.ne.jp/ledsun/touch/20120128/1327759675">35歳定年説をブチ破れ！「Clean Coder プロフェッショナルプログラマへの道 Robert C. Martin」 - ledsunの日記 </a></p>
</content:encoded>
    </item>
    
    <item>
      <title>親子で楽しめる 絵本で英語をはじめる本(Jugemより移植)</title>
      <link>https://blog.johtani.info/blog/2012/02/26/%E8%A6%AA%E5%AD%90%E3%81%A7%E6%A5%BD%E3%81%97%E3%82%81%E3%82%8B-%E7%B5%B5%E6%9C%AC%E3%81%A7%E8%8B%B1%E8%AA%9E%E3%82%92%E3%81%AF%E3%81%98%E3%82%81%E3%82%8B%E6%9C%AC/</link>
      <pubDate>Sun, 26 Feb 2012 01:20:00 +0900</pubDate>
      
      <guid>https://blog.johtani.info/blog/2012/02/26/%E8%A6%AA%E5%AD%90%E3%81%A7%E6%A5%BD%E3%81%97%E3%82%81%E3%82%8B-%E7%B5%B5%E6%9C%AC%E3%81%A7%E8%8B%B1%E8%AA%9E%E3%82%92%E3%81%AF%E3%81%98%E3%82%81%E3%82%8B%E6%9C%AC/</guid>
      <description>親子で楽しめる 絵本で英語をはじめる本 Twitterでこの本について書かれたブログ記事が流れてきて、購入しました。 最近、英語を身につけておいた</description>
      <content:encoded><p>

<div class="amazon-shortcode-box">
  <div class="amazon-shortcode-image">
    <a style="display: inline-block;" target="_blank" href="https://www.amazon.co.jp/gp/product/479931131X/?tag=johtani-22">
      <img border="0" src="//ws-fe.amazon-adsystem.com/widgets/q?_encoding=UTF8&MarketPlace=JP&ASIN=479931131X&ServiceVersion=20070822&ID=AsinImage&WS=1&Format=_SL160_&tag=johtani-22" >
    </a>
  </div>
  <div class="amazon-shortcode-info">
    <p class="amazon-shortcode-title">
      <a target="_blank" href="https://www.amazon.co.jp/gp/product/479931131X/?tag=johtani-22">
      親子で楽しめる 絵本で英語をはじめる本
      </a>
    </p>
  </div>
</div>
Twitterでこの本について書かれたブログ記事が流れてきて、購入しました。</p>
<p>最近、英語を身につけておいたほうがいいなと思うことが多々あり、子供にも英語を勉強してもらいたいなと思っていたところでした。
あとは、私自身が英語が苦手というのもあり、子供をダシにして勉強したいというのもありまして。。。
サラっと読んでみましたが、参考になりました。
特に「多読」というキーワードが面白かったです。<a href="http://www.seg.co.jp/sss/">こちら</a>が元のようですが。
多読とは、文章を分析しないで大意を把握する読書法だそうです。</p>
<ul>
<li>辞書を引かずに楽しめるものを読む</li>
<li>わかるところをつなげて読む</li>
<li>自分が面白いと思う本を選んで読む</li>
</ul>
<p>という原則があるようで、確かにいいなと思いました。
絵本だと絵が書かれているので、辞書を引かなくても想像できそうですし、楽しめそうだなぁと。
また、多読は<a href="http://johtani.jugem.jp/?eid=46">先日読んだ、速読の本に書かれていた本の読み方</a>にも通じるものがあるなと。（まだ、実践できてないんですけどね）</p>
<p>どうしても英語を勉強させたい！、勉強しないと！と思ってしまいがちですが、この本にも書いてあるように楽に楽しんでやったほうがやっぱいいなぁと。
楽しくないと続かないですからねぇ（実際、何度も挫折してるし、押し付けられるとヤル気がなくなるので。。。）</p>
<p>ということで、実践してみようと思います。（平日は子供が寝てしまってから帰宅なので、まずは土日から）子供のためというよりは、自分の英語の勉強のために。
まずは、簡単な絵本を購入して。
この本の後半半分は、著者の方の感想や説明がついた、オススメの絵本50冊が書かれています。
英語の絵本を入手するのは、結構大変（実際に売ってる店もなかなかないし、手にとって見る機会も少ない）だと思うのですごく参考になりそうです。
いくつかピックアップして、あわよくば本屋で手にとってみようかと。なければ、Amazonで購入しようかなぁと思ってる所です。</p>
</content:encoded>
    </item>
    
    <item>
      <title>「どんな本でも大量に読める「速読」の本」を読みました(Jugemより移植)</title>
      <link>https://blog.johtani.info/blog/2011/11/29/%E3%81%A9%E3%82%93%E3%81%AA%E6%9C%AC%E3%81%A7%E3%82%82%E5%A4%A7%E9%87%8F%E3%81%AB%E8%AA%AD%E3%82%81%E3%82%8B%E9%80%9F%E8%AA%AD%E3%81%AE%E6%9C%AC%E3%82%92%E8%AA%AD%E3%81%BF%E3%81%BE%E3%81%97%E3%81%9F/</link>
      <pubDate>Tue, 29 Nov 2011 13:57:00 +0900</pubDate>
      
      <guid>https://blog.johtani.info/blog/2011/11/29/%E3%81%A9%E3%82%93%E3%81%AA%E6%9C%AC%E3%81%A7%E3%82%82%E5%A4%A7%E9%87%8F%E3%81%AB%E8%AA%AD%E3%82%81%E3%82%8B%E9%80%9F%E8%AA%AD%E3%81%AE%E6%9C%AC%E3%82%92%E8%AA%AD%E3%81%BF%E3%81%BE%E3%81%97%E3%81%9F/</guid>
      <description>どんな本でも大量に読める「速読」の本 Twitterで知り合った方がこの本について書かれていたブログ記事を読んで興味を持ち、読みました。 書籍（</description>
      <content:encoded><p>

<div class="amazon-shortcode-box">
  <div class="amazon-shortcode-image">
    <a style="display: inline-block;" target="_blank" href="https://www.amazon.co.jp/gp/product/4479793313/?tag=johtani-22">
      <img border="0" src="//ws-fe.amazon-adsystem.com/widgets/q?_encoding=UTF8&MarketPlace=JP&ASIN=4479793313&ServiceVersion=20070822&ID=AsinImage&WS=1&Format=_SL160_&tag=johtani-22" >
    </a>
  </div>
  <div class="amazon-shortcode-info">
    <p class="amazon-shortcode-title">
      <a target="_blank" href="https://www.amazon.co.jp/gp/product/4479793313/?tag=johtani-22">
      どんな本でも大量に読める「速読」の本
      </a>
    </p>
  </div>
</div>
Twitterで知り合った方がこの本について書かれていた<a href="http://www.metisous.com/2011/10/post-62">ブログ記事</a>を読んで興味を持ち、読みました。
書籍（特に技術書）が山になっていたこともあり、速読に興味を持っていたところちょうど記事を目にしたのは
きっと何かのタイミングなんだろうなと。</p>
<p>悪い癖で、電車で読もうと本を常に持ち歩くのですが、ついついスマートフォンやゲームで遊んでしまい、今回も読むのに時間がかかってしまいました。
３章の途中までを今月頭に読んでいたのですが、そこから少しほったらかしで、読み終わったのが昨日でした。</p>
<p>本の内容ですが、先ほどのブログにも書かれていますが、速読は技術ではない。
<span style="color:#FF0000">### 速読　＝　速読技術　X　ストック（知識、経験、情報）</span>
であると。あとは、わからなくてもいいから、ざっと目を通す感じで繰り返し読みなさいと。
さらに、１回でわからんくてもいいから、とにかく繰り返し読むことが重要だということでした。</p>
<p>確かに「速読＝１回で速く読む」、「読書＝１回で理解する」という意識がどこかにあったなぁと気付かされました。
プログラム組んだり、あることを覚えるときは繰り返しを意識してたのに、読書は１回読んで「はい、おしまい。」という気になってました。（マンガは繰り返し読むんですけどねぇ）</p>
<p>他の速読の本は胡散臭いし、絶対無理だよなぁと思ってたのですが、この本に書かれている話は筋が通っているように感じました。
ただ、考えずにサラサラ読みなさいという部分の実践はなかなか難しいかな。どうしても頭の中で音読してしまうので。
私は間を開けてしまったせいで、時間がかかってしまいましたが普通なら１日あれば読める内容なので速読に関してちょっとと思ってる方は読んでみると面白いかと思います。</p>
<p>ちょっとだけショックだったのは、この本の論理だと電子書籍は速読に向いていないというところです。
せっかく溜まった書籍をPDF化して、タブレット購入して（まだ買ってない。。。）読もうと思っていたところなのに。。。</p>
</content:encoded>
    </item>
    
    <item>
      <title>「7つの言語　7つの世界」 Io 0日目(Jugemより移植)</title>
      <link>https://blog.johtani.info/blog/2011/09/23/7%E3%81%A4%E3%81%AE%E8%A8%80%E8%AA%9E-7%E3%81%A4%E3%81%AE%E4%B8%96%E7%95%8C-io-0%E6%97%A5%E7%9B%AE/</link>
      <pubDate>Fri, 23 Sep 2011 03:34:00 +0900</pubDate>
      
      <guid>https://blog.johtani.info/blog/2011/09/23/7%E3%81%A4%E3%81%AE%E8%A8%80%E8%AA%9E-7%E3%81%A4%E3%81%AE%E4%B8%96%E7%95%8C-io-0%E6%97%A5%E7%9B%AE/</guid>
      <description>台風15号すごかったですね。幸いにも（？）夏休みだったので、通勤などでひどい目に合わずにすみました。 風雨はすごくてちょっと怖かったですが。。</description>
      <content:encoded><p>台風15号すごかったですね。幸いにも（？）夏休みだったので、通勤などでひどい目に合わずにすみました。
風雨はすごくてちょっと怖かったですが。。。</p>
<p>さて、夏休みに進める予定が、子供の寝かしつけで一緒に寝てしまう日が続いてしまい、
間が開いてしまいました。</p>
<p>0日目というタイトルになっているのは、まだ、1日目に入ってないからです。。。
Ioという未知の言語をMBAにそのままインストールするのも抵抗があり、VirtualBox上にLinuxをインストールしてから
進めようとして思いの外手こずってしまったためです。
ということで、0日目として、VirtualBox上にScientific Linux 6.1をインストールしてIoのインストールまでではまった箇所を記録として残しておきます。</p>
<h3 id="罠その１">罠その１</h3>
<p>罠と言うよりは、私の無知に関する部類なのですが。。。
Scientific Linux 6.1のインストールは特に手こずることなくインストールでき、
起動も出来ました。
次にscpコマンドでダウンロードしてきたIoのソースをLinuxに渡そうとしてはまりました。
問題となったのはネットワーク接続が「NAT」のみだったため。
NATのため、Linux（ゲストOS）から外部への接続は可能だったのですが、Mac（ホストOS）からLinux（ゲストOS）への接続ができませんでした。
で、変更したのは以下の2点。</p>
<ul>
<li>VirtualBoxの環境設定-&gt;ネットワーク-&gt;ホストオンリーネットワークの追加</li>
<li>仮想マシン（Linux）の設定-&gt;ネットワーク-&gt;アダプタ2を有効にしてホストオンリーアダプタを割り当て</li>
</ul>
<p>1番目のホストオンリーネットワークの追加をしておかないと、2番目のアダプタ2でホストオンリーアダプタを選択したときにエラーが出て、設定ができませんでした。割り当てるべきアダプタを先に用意しとかないとダメですよね、そりゃあ。</p>
<h3 id="罠その２">罠その２</h3>
<p>これも罠というほどではないのですが。。。
Ioのビルドには<a href="http://www.cmake.org/">cmake</a>が必要なのですが、Scientific Linux 6.1に入っているcmakeはバージョンが古い（2.6.4）ため、必要なバージョン（2.8以上）をインストールしないとダメでした。
インストール自体はcmakeのサイトにある手順通りのため割愛します。</p>
<h3 id="罠その３">罠その３</h3>
<p>これもちゃんとドキュメント読めよというレベルですが。。。
Ioのインストールは以下のコマンドを実行するという話です。
私がcmakeについて知らなかったと言われればそれまで。。。</p>
<pre><code>
$ cd io
$ mkdir build &amp;amp;&amp;amp; cd build
$ ccmake ..
$ make
$ sudo make install
</code></pre><p>3つ目の「ccmake」の部分がIoのGetting Startedの下の方にありました。上の方に記載がある「cmake」ではエラーがでてうまく行かなかったので。
IoのGetting Startedにもありますが、ccmakeの場合はCUI上にGUIのようなものが起動するので、「c」（configure）と実行後、「g」（generate）を実行して最後に「e」（exit）でccmakeを離れます。
するとmakeが実行できるようになりました。</p>
<p>あとは、/etc/ld.so.conf.d/io.confファイルを作成し、「/usr/local/lib」と記述。ldconfigを実行することで、Ioが実行可能になります。
ということで、1日目に入れず終了。。。</p>
<p>明日は出来るかなぁ。</p>
</content:encoded>
    </item>
    
    <item>
      <title>「7つの言語　7つの世界」 Ruby 3日目（最終日）(Jugemより移植)</title>
      <link>https://blog.johtani.info/blog/2011/09/14/7%E3%81%A4%E3%81%AE%E8%A8%80%E8%AA%9E-7%E3%81%A4%E3%81%AE%E4%B8%96%E7%95%8C-ruby-3%E6%97%A5%E7%9B%AE%E6%9C%80%E7%B5%82%E6%97%A5/</link>
      <pubDate>Wed, 14 Sep 2011 18:21:00 +0900</pubDate>
      
      <guid>https://blog.johtani.info/blog/2011/09/14/7%E3%81%A4%E3%81%AE%E8%A8%80%E8%AA%9E-7%E3%81%A4%E3%81%AE%E4%B8%96%E7%95%8C-ruby-3%E6%97%A5%E7%9B%AE%E6%9C%80%E7%B5%82%E6%97%A5/</guid>
      <description>ということで、Rubyの最終日の感想。 今回もセルフスタディの私の回答が最後の方に記載されてます。見たくない人は気をつけてください。 ツッコミ大</description>
      <content:encoded><p>ということで、Rubyの最終日の感想。
<span style="color:#FF0000">今回もセルフスタディの私の回答が最後の方に記載されてます。</span>見たくない人は気をつけてください。
ツッコミ大募集です。コメント欄にどしどしコメントください。そこは違うだろ？こっちのほうがいいのでは？という感じで。</p>
<h2 id="感想">感想：</h2>
<h3 id="メタプログラミングが特徴">◎メタプログラミングが特徴</h3>
<p>例：ActiveRecordのhas_many、has_oneがいい例</p>
<h3 id="オープンクラス">◎オープンクラス</h3>
<p>クラス定義をいつでも変更可能。
あらゆるクラスやオブジェクトをいつでも再定義できる
書きやすいコードのために再定義が可能＝何でもできるが気を付ける必要あり。
DSLの定義に便利。
確かに便利。ただ、範囲を限定しないと予期せぬ場所で問題が発生しそう。
<span style="color:#0000FF">※解析するための手段はいいのがあるのかな？=&gt;method_missingみたい</span></p>
<h3 id="method_missing">◎method_missing</h3>
<p>対象メソッドが見つからない場合に最後に実行されるメソッド
通常はNoMethodErrorが発行される。</p>
<h3 id="モジュールによるメタプログラミング">◎モジュールによるメタプログラミング</h3>
<p>defやattr_accessorなどその一例。
DSLではモジュール内にメソッドを定義してメソッド＋定数を利用
<span style="color:#0000FF">ActsAs&hellip;ってそういう意味合いだったのか。</span>
親クラスバージョン、親クラス＋マクロ、モジュールそれぞれの実装の仕方の紹介。
<span style="color:#0000FF">※マクロもinclude同様、実行順で、メソッドの上書きが発生するのか？</span>
ActiveRecordではメタプログラミングを利用してDBのカラム名からアクセサを追加。
シンタックスの美しさ＝読みやすさ</p>
<h2 id="感想疑問点">感想＆疑問点：</h2>
<p>メタプログラミングはフレームワークを作成するのが便利そう。
ただし、エラーや問題が起きた時の対処をきちんと準備しておかないとひどい目に合いそう。
<span style="color:#0000FF">クラスやモジュールはわかりやすい単位で1ファイルにまとめるもの？</span>
<span style="color:#0000FF">ファイル名の規則とかあったりする？</span>
<span style="color:#0000FF">ディレクトリ構成でパッケージ構成が可能？</span>
<span style="color:#0000FF">複数のモジュール（gemとか）を組み合わせて使っている場合にincludeの順序がどのようになるかが気になる。</span>
予期せぬ順序でincludeされて利用しようと思ったメソッドがオーバーライドされてるとかありそう。
追っかけるのがまた大変そうだ。
異なるパフォーマンス（開発者の開発速度）の観点が一番おもしろかった。ただ、なれるまでは大変そう。すんなりinjectとかコードブロックをうまく利用するイメージがわかない。
まぁ、思考については反復練習かな。これは他の言語でも一緒かな</p>
<p>ようやく、Rubyの世界が終わりました。楽しかった。次は未知の言語である「Io」です。</p>
<p>　　　</p>
<h3 id="試してみよう">（試してみよう：）</h3>
<dl>
<dt>○eachメソッドがCsvRowオブジェクトを返すようにCSVアプリケーションを変更せよ。そのCsvRowのmethod_mmissingを使って、与えられた見出しの列の値を返すようにせよ。</dt>
<dd>
モジュールにて実装してみた。
```
<p>module ActsAsCsv</p>
<p>def self.included(base)
base.extend ClassMethods
end
　　　　　
module ClassMethods
def acts_as_csv
include InstanceMethods
end
end</p>
<p>module InstanceMethods</p>
<pre><code>def read
  @csv_rows = []
  file = File.new(self.class.to_s.downcase + '.txt')
  headers = file.gets.chomp.split(', ')

  file.each do |row|
    @csv_rows &lt;&lt; CsvRow.new(headers,row.chomp.split(', '))
  end
end

def each(&amp;block)
  csv_rows.each(&amp;block)
end

attr_accessor :csv_rows

def initialize
  read
end
</code></pre>
<p>end</p>
<p>class CsvRow
def initialize(headers, csv_contents)
@headers = headers
@csv_contents = csv_contents
end</p>
<pre><code>attr_accessor :headers, :csv_contents

def method_missing name, *args
  csv_contents.fetch(headers.find_index(name.to_s))
end
</code></pre>
<p>end
end</p>
<pre><code>ここまでが実装したモジュール＋クラス。
以下は実行例。id,name,sizeというheaderをもつCSVを使ってみた。

</code></pre><blockquote>
<blockquote>
<p>require &lsquo;acts_as_csv_module_mod.rb&rsquo;
=&gt; true
class RubyCsv
include ActsAsCsv
acts_as_csv
end
=&gt; RubyCsv
csv = RubyCsv.new
=&gt; #&lt;RubyCsv:0x103c4c530 @csv_rows=[#&lt;ActsAsCsv::CsvRow:0x103c4c030 @csv_contents=[&ldquo;1&rdquo;, &ldquo;RubyCsv.class&rdquo;, &ldquo;20&rdquo;], @headers=[&ldquo;id&rdquo;, &ldquo;name&rdquo;, &ldquo;size&rdquo;]&gt;, #&lt;ActsAsCsv::CsvRow:0x103c4be78 @csv_contents=[&ldquo;2&rdquo;, &ldquo;JRubyCsv.class&rdquo;, &ldquo;50&rdquo;], @headers=[&ldquo;id&rdquo;, &ldquo;name&rdquo;, &ldquo;size&rdquo;]&gt;]&gt;
csv.each {|row| puts row.name}
RubyCsv.class
JRubyCsv.class
=&gt; [#&lt;ActsAsCsv::CsvRow:0x103c4c030 @csv_contents=[&ldquo;1&rdquo;, &ldquo;RubyCsv.class&rdquo;, &ldquo;20&rdquo;], @headers=[&ldquo;id&rdquo;, &ldquo;name&rdquo;, &ldquo;size&rdquo;]&gt;, #&lt;ActsAsCsv::CsvRow:0x103c4be78 @csv_contents=[&ldquo;2&rdquo;, &ldquo;JRubyCsv.class&rdquo;, &ldquo;50&rdquo;], @headers=[&ldquo;id&rdquo;, &ldquo;name&rdquo;, &ldquo;size&rdquo;]&gt;]
csv.each {|row| puts row.id}
(irb):8: warning: Object#id will be deprecated; use Object#object_id
2179096600
(irb):8: warning: Object#id will be deprecated; use Object#object_id
2179096380
=&gt; [#&lt;ActsAsCsv::CsvRow:0x103c4c030 @csv_contents=[&ldquo;1&rdquo;, &ldquo;RubyCsv.class&rdquo;, &ldquo;20&rdquo;], @headers=[&ldquo;id&rdquo;, &ldquo;name&rdquo;, &ldquo;size&rdquo;]&gt;, #&lt;ActsAsCsv::CsvRow:0x103c4be78 @csv_contents=[&ldquo;2&rdquo;, &ldquo;JRubyCsv.class&rdquo;, &ldquo;50&rdquo;], @headers=[&ldquo;id&rdquo;, &ldquo;name&rdquo;, &ldquo;size&rdquo;]&gt;]</p>
</blockquote>
</blockquote>
<pre><code>
&lt;span style=&quot;color:#FF0000&quot;&gt;※idというcsvフィールド名にしたら、object_idとかぶっているようでwarningが出てしまった。&lt;/span&gt;

CsvRowクラスの定義がモジュールの中に入っているが、この実装でも動くみたい。ただ、パッケージみたいな感じ7日までは調査してない。。。
</code></pre></content:encoded>
    </item>
    
    <item>
      <title>「7つの言語　7つの世界」 Ruby 2日目(Jugemより移植)</title>
      <link>https://blog.johtani.info/blog/2011/09/10/7%E3%81%A4%E3%81%AE%E8%A8%80%E8%AA%9E-7%E3%81%A4%E3%81%AE%E4%B8%96%E7%95%8C-ruby-2%E6%97%A5%E7%9B%AE/</link>
      <pubDate>Sat, 10 Sep 2011 02:11:00 +0900</pubDate>
      
      <guid>https://blog.johtani.info/blog/2011/09/10/7%E3%81%A4%E3%81%AE%E8%A8%80%E8%AA%9E-7%E3%81%A4%E3%81%AE%E4%B8%96%E7%95%8C-ruby-2%E6%97%A5%E7%9B%AE/</guid>
      <description>ということで、Ruby2日目の感想（2日目だけで2日間かかったのは内緒。。。） 今回もセルフスタディの私の回答が最後の方に記載されてます。見た</description>
      <content:encoded><p>ということで、Ruby2日目の感想（2日目だけで2日間かかったのは内緒。。。）
<span style="color:#FF0000">今回もセルフスタディの私の回答が最後の方に記載されてます。</span>見たくない人は気をつけてください。
ツッコミ大募集です。コメント欄にどしどしコメントください。そこは違うだろ？こっちのほうがいいのでは？という感じで。</p>
<h2 id="感想">感想：</h2>
<h3 id="関数の定義span-stylecolor0000ffありゃ利用するのはダメなんだこれじゃspanspan-stylecolorff0000--gt単なるタイプミスでしたお恥ずかしいspan">◎関数の定義：<del><span style="color:#0000FF">ありゃ、利用するのはダメなんだ、これじゃ。</span></del><span style="color:#FF0000">&ndash;&gt;単なるタイプミスでした。お恥ずかしい。。。</span></h3>
<pre><code>
&gt;&gt; def tell_the_truth
&gt;&gt;   true
&gt;&gt; end
=&gt; nil
&gt;&gt; tell_the_trueth()
NoMethodError: undefined method `tell_the_trueth' for main:Object
     from (irb):4
</code></pre><h3 id="配列そしてシンタックスシュガー">◎配列：そしてシンタックスシュガー</h3>
<p>puts animalsで内容が出力されるのはうれしい。JavaだとHashCodeが出てくるから。出力メソッド書かないといけなくなる。
animals[-1]で最後の要素とかかなり便利。
animals[0..1]はRangeクラスを利用する形。Rangeはやはり便利。substringなどもできそう。
カラ配列の定義は必要。a = []
1.9と1.8でinclude?の書き方が異なるので注意！
配列（Array）クラスは中はObjectが入る。
多次元配列もOK。popやpushでキューとしても利用可能。</p>
<h3 id="ハッシュ">◎ハッシュ：</h3>
<p>Mapのようなもの。任意のキーが利用可能。:付きの文字列はシンボルと呼ばれる定数値を簡単に定義する方法。
object_idという属性？関数によりObjectのハッシュコードが取れるらしい。
ブレース＝「{}」のカッコのこと。do～endでも代用可能</p>
<h3 id="コードブロックとyeild">◎コードブロックとyeild</h3>
<p>コードブロック＝名前なし関数。習慣では複数行の場合、do/endで、１行は{}みたい。Javaと混同しそう。
コードブロックは引数も指定可能。
「yield」予約語？を利用してコードブロック自体をメソッド内部などで呼び出し可能。
ということで、コードブロックは引数にも指定できると。<span style="color:#0000FF">コードブロック＝関数もObjectとして扱われてる感じか？</span>
<span style="color:#0000FF">実行遅延、分岐、共通関数とか？Javaだとabstractメソッドを利用して処理するようなイメージか？</span>ちょっと違うなぁ。
なれると、yieldはコードを読みやすくできそう。また、シンタックスハイライトしてくれるツールがあれば、更に便利。</p>
<h3 id="ファイルの実行">◎ファイルの実行</h3>
<pre><code>
ruby ファイル名
</code></pre><p>vi、Emacs、TextMateなどがあるよ。</p>
<h3 id="クラスの定義">◎クラスの定義</h3>
<p>※数字で始まる変数は利用できない！Javaと一緒
Tree.rbとログを参考にすること。
&amp;使うとブロックに名前が付けられる。<span style="color:#0000FF">yieldじゃなくてもいい？</span>
クラス名はキャメルケース。
変数とメソッド名は「_」アンダーバーつなぎ
インスタンス変数の頭は@
クラス変数は@@
定数は大文字
※メソッド名、変数名には違和感が。<span style="color:#0000FF">なんでこんな規則？？</span>
判定用関数とメソッドには「?」（if test?）をつける！！Javaでいう「is」か。</p>
<h3 id="mixin多重継承モジュールと呼ばれるものを利用">◎Mixin（多重継承？モジュールと呼ばれるものを利用）</h3>
<p>多重継承のような類似の振る舞いを伝搬する仕組み。
Javaではインタフェースでやること。
Rubyではモジュールといい、関数と定数の集まり。
クラスに機能を盛り込む場合はincludeする
<span style="color:#0000FF">※複数includeして、includeしたものの中に同じメソッドとかあったらどーなる？</span>
<span style="color:#0000FF">　&ndash;&gt;Overrideされた＝includeがあとにあるもので上書きされる</span>
Abstractにできないものをモジュール化できるの楽。
javaだとstaticメソッドだらけのUtilクラスを別途起こすイメージだけど、内部で呼ばれるメソッド（コードブロック）が同じインタフェースじゃないと行けないから、インタフェースの記述もしないと行けない。
ただし、同一名のメソッドを持ってるとややこしそう。
<span style="color:#0000FF">※モジュールからモジュールは呼べる？</span></p>
<h3 id="モジュールenumerableセット">◎モジュール、Enumerable、セット</h3>
<p>EnumerableとComparable（JavaのCollectionまわりかな。）
宇宙船演算子（&lt;=&gt;）Javaのequalsに似てる
any?とかCollectionUtils？？に似たのあったな。
<span style="color:#0000FF">※今利用しているクラスが何をincludeしてるかってのは分かる仕組みあるのかな？
※そういえば、メソッドごとに戻り値があるが、全部newされてインスタンス化されてGCの対象になってるのか？irbだけ？</span>
injectはすんなり使うイメージが出にくそう。また、ソースをぱっと見て理解出来ない。なれだろうけど。
※injectしながらinjectとかあるんだろうな。</p>
<h3 id="探してみよう">（探してみよう：）</h3>
<dl>
<dt>○コードブロックを使った場合と使わない場合の両方について、ファイルにアクセスするコードを書く。コードブロックの利点は？</dt>
<dd>※コードブロックあり。
```
<p>File.open(&ldquo;tree.rb&rdquo;, &lsquo;r&rsquo;) {|f| f.each {|line| puts &ldquo;#{f.lineno} : #{line}&quot;}}</p>
<pre><code>※コードブロックなし
</code></pre><p>f = File.open(&ldquo;tree.rb&rdquo;, &lsquo;r&rsquo;)
while line = f.gets
puts &ldquo;#{f.lineno} : #{line}&rdquo;
end</p>
<pre><code>コードブロックの利点：
　見通しの良さ。行数が少なくてすむ。繰り返し処理が簡単に記述できる。
　※うーん、まだきちんと理解できてないか？
&lt;/dd&gt;
&lt;dt&gt;○ハッシュを配列に変換するにはどうすればよいか？また、逆に配列をハッシュに変換する方法は？&lt;/dt&gt;
&lt;dd&gt;
※間違えた。。。
</code></pre><blockquote>
<blockquote>
<p>h = [:key1 =&gt; &ldquo;hoge&rdquo;, :key2 =&gt; &ldquo;boke&rdquo;, :key3 =&gt; &ldquo;fuga&rdquo;]
h.each {|key, value| puts &ldquo;#{key} is #{value}&quot;}
=&gt;key1hogekey2bokekey3fuga is</p>
</blockquote>
</blockquote>
<pre><code>
ハッシュ-&amp;gt;配列変換
</code></pre><p>h.to_a</p>
<pre><code>
配列-&amp;gt;ハッシュ変換
</code></pre><p>a = [&ldquo;value1&rdquo;, &ldquo;valu2&rdquo;, &ldquo;value3&rdquo;]
h = {}
a.each {|i| h.store(a.index(i),i) }</p>
<pre><code>※また間違い？なんでそうなる？
</code></pre><p>a.inject(h2) {|hoge, i| hoge[a.index(i).to_s] = i}</p>
<pre><code>こっちならいいみたい。まだinjectがわかってない。
</code></pre><p>a.inject(h2) {|hoge, i| hoge[a.index(i).to_s] = i;puts &ldquo;#{i}&quot;; hoge}</p>
<pre><code>
&lt;/dd&gt;
&lt;dt&gt;○ハッシュの各要素について繰り返すにはどうすればよいか？&lt;/dt&gt;
&lt;dd&gt;
</code></pre><p>h.each {|key, value| puts &ldquo;#{key} is #{value}&quot;}</p>
<pre><code>&lt;/dd&gt;
&lt;dt&gt;○Rubyの配列はスタックとしても使える。スタック以外に配列で実現可能なよくあるデータ構造体を挙げよ。&lt;/dt&gt;
&lt;dd&gt;キュー。
他にある？Treeとか？Treeはハッシュじゃないか？Set？順番が関係ないけど。&lt;/dd&gt;
&lt;/dl&gt;


### **（試してみよう：）**
&lt;dl&gt;
&lt;dt&gt;○最初に、eachだけを用いて、１６個の数値と４個の数値の配列の中身を同時に出力せよ。次に、同じ事をEnumerableのeach_sliceを用いて実行せよ。&lt;/dt&gt;
&lt;dd&gt;
&lt;span style=&quot;color:#FF0000&quot;&gt;&lt;em&gt;※これ日本語がわからないんだが、4個ずつ出せってことか？？&lt;/em&gt;&lt;/span&gt;ということで、「16個の数字の配列の中身を4個ずつ同時に出力せよ。」と解釈して実装してみた
※each利用版
</code></pre><p>a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]
s = []
a.each do |b|
unless s.length &lt; 4
puts s.inspect
s.clear
end
s &laquo; b
end</p>
<pre><code>
※each_slice
</code></pre><p>a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]
a.each_slice(4) {|b| puts b.inspect}</p>
<pre><code>また、えらい違いだな。
&lt;/dd&gt;
&lt;dt&gt;○Treeクラスは面白いクラスだったが、きれいなインタフェースを用いて新しいツリーを指定することは出来なかった。そこで、initializerにハッシュと配列が入れ子になった構造体を指定できるようにせよ。具体的には、次のようなツリーを指定できるようにしたい。{'grandpa' =&amp;gt; { 'dad' =&amp;gt; {'child 1' =&amp;gt; [], 'child 2' =&amp;gt; [] }, 'uncle' =&amp;gt; {'child 3' =&amp;gt; [], 'child 4' =&lt; [] } } }&lt;/dt&gt;
&lt;dd&gt;&lt;span style=&quot;color:#FF0000&quot;&gt;※root（ここではgrandpaレベル）が複数あると破綻しないのか？&lt;/span&gt;
</code></pre><p>class Tree
attr_accessor :children, :node_name</p>
<p>def initialize(name, children=[])
@children = children
@node_name = name
end</p>
<p>def initialize(hash)
hash.each do |key, value|
@node_name = key
@children = value.inject([]) do |array, (child_key, child_val)|
puts &ldquo;inject! #{key}&rdquo;
[Tree.new({child_key =&gt; child_val})] + array
end
end
end</p>
<p>def visit_all(&amp;block)
visit &amp;block
children.each {|c| c.visit_all &amp;block}
end</p>
<p>def visit(&amp;block)
block.call self
end
end</p>
<pre><code>
残念ながらちょっとカンニングしてしまいました。。。
&lt;/dd&gt;
&lt;dt&gt; ○ファイル内で、あるフレーズを含む全ての行を出力する簡単なgrepをかけ。簡単な正規表現でマッチングを行い、ファイルから行を読み出す必要がある（この処理はRubyでは驚くほど簡単にかける）。必要なら行番号も出力してみると良い。&lt;/dt&gt;
&lt;dd&gt;※メソッドだけでいいな。&lt;span style=&quot;color:#0000FF&quot;&gt;ファイルクローズはこの記述の場合はコーディングブロックのendのタイミングでクローズされるのか？&lt;/span&gt;
</code></pre><p>class RegGrep
def grep(filename, regexp)
File.open(filename, &lsquo;r&rsquo;) do |f|
f.each do |line|
puts &ldquo;#{f.lineno} : #{line}&rdquo; if line.match(regexp)
end
end
end
end</p>
<pre><code>&lt;/dd&gt;
&lt;/dl&gt;

ということで、2日目終了。
恥ずかしいコードだらけだけど、ぜひツッコミ入れてもらえると助かります。

数年前までは、恥ずかしいからとか見せられるレベルじゃないからと、ほとんどアウトプットしなかったのですが、
最近はそれではものすごく損をしていると思っています。
ホントは発表するとか議論するとかする場もあればいいのですが。
アウトプットすることで、フィードバックが貰えて、いろんなかたの考えが参考になり、糧となり成長していけるのかと。
（これじゃ成長できないレベルだよという話でなければいいのだが。。。）

一度、Rubyのプロフェッショナル各位に見てもらいたいなぁｗ
</code></pre></content:encoded>
    </item>
    
    <item>
      <title>「7つの言語　7つの世界」 Ruby 1日目(Jugemより移植)</title>
      <link>https://blog.johtani.info/blog/2011/09/09/7%E3%81%A4%E3%81%AE%E8%A8%80%E8%AA%9E-7%E3%81%A4%E3%81%AE%E4%B8%96%E7%95%8C-ruby-1%E6%97%A5%E7%9B%AE/</link>
      <pubDate>Fri, 09 Sep 2011 14:12:00 +0900</pubDate>
      
      <guid>https://blog.johtani.info/blog/2011/09/09/7%E3%81%A4%E3%81%AE%E8%A8%80%E8%AA%9E-7%E3%81%A4%E3%81%AE%E4%B8%96%E7%95%8C-ruby-1%E6%97%A5%E7%9B%AE/</guid>
      <description>実に3年ぶりくらいにゆっくりできる日々が訪れたので、積読状態の本を消化しようと「7つの言語 7つの世界」を読み始めました。 せっかくブログも始め</description>
      <content:encoded><p>実に3年ぶりくらいにゆっくりできる日々が訪れたので、積読状態の本を消化しようと「7つの言語　7つの世界」を読み始めました。</p>
<p>せっかくブログも始めたので、備忘録も兼ねて感想などを書いていこうかと。</p>
<p>この本ですが、以下の7つの言語についてエッセンスがまとめられています。</p>
<ul>
<li>Ruby</li>
<li>Io</li>
<li>Prolog</li>
<li>Scala</li>
<li>Erlang</li>
<li>Clojure</li>
<li>Haskell</li>
</ul>
<p>まずはRubyからです。
ここ2年ほどRuby（Rails）に関連する仕事をしていたのですが、Ruby周りはプロフェッショナルな方たちがいたので、きちんと勉強していないことがこの本を読み始めてわかりました。</p>
<p>ということで、前置きはそれなりな記述ですが、感想は適当になりますので、あしからず。</p>
<h3 id="感想">感想：</h3>
<p>irbが便利。簡単に動作確認ができるのが便利。Javaだとコンパイルが必要。
変数を定義する必要がない気軽さはある。
必ず戻り値が帰ってくる「puts &lsquo;hello, world&rsquo;」でも。=&gt;nil
putsは楽かな。まぁ、Eclipse使ってると一緒か。
「4」もオブジェクトとなっている。ここもJavaと異なる。
(x &lt;= 4).classという記述でTrueClassというクラスだとわかる。
unlessが結構便利。ただし、記述方法が多数あるので、可読性は落ちる？場合によってはわかりやすいか？
あと、括弧()がないのも慣れない。（まぁ、これは慣れの問題。ただし、カッコありでもOK）
{}のかわりがif～endなのはわかりやすいかも。
if not はわかりやすくていい。!はだいたい間違えるから。。。
whileも１行形式で書けるのか。「x = x + 1 while x &lt; 10」慣れないと厳しい。個人的には混在すると読めないなぁ。
nilとfalse以外がすべてtrueに評価されるのは厳しいのでは？型のチェックがないので、booleanが入ってると想定してない場合に挙動を読めないかも。実行時に動作が変だなーと思うことが出てきそう。
and、orの記述が使えるのは読みやすい。ただし、混在するとやっかい。
判定結果が明らかになった時点で実行が中止されるのは普通。&amp;、|の挙動はJava同様。</p>
<p>やりながら疑問点：</p>
<ul>
<li>NetBeansとかIDEでフォーマッタやcheckstyleみたいなのはあるのか？</li>
<li>コーディング規約はあるのか？（2日目に「習慣」があるらしいとの記載があった。）</li>
<li>必ず戻り値が戻ってくるのは、必ずGC対象になりうるオブジェクトが生成されるってことか？</li>
</ul>
<p>ここまでが感想と疑問点。で、この本の面白いところは最後に調査、コーディングを行う練習問題的なものがある部分です。
一応、私なりの答えを書いておこうかと。（一覧などで見えないようにはしますが、ネタバレがあるので注意してください。）</p>
<p>ということで、セルフスタディの回答。</p>
<h3 id="探してみよう">（探してみよう）</h3>
<dl>
<dt>○Ruby API</dt>
<dd>http://ruby-doc.org/core/</dd>
<dt>○Programming Ruby: The Pragmatic Programmer's Guideのオンライン版</dt>
<dd>http://www.ruby-doc.org/docs/ProgrammingRuby/参考資料：http://www.swlab.it.okayama-u.ac.jp/man/ruby/uguide/uguide00.html</dd>
<dt>○文字列の一部を置換するメソッド</dt>
<dd>"hello".gsub(/[aeiou]/, '*')</dd>
<dt>○Rubyの正規表現に関する情報</dt>
<dd>日本語：http://www.namaraii.com/rubytips/?%A5%D1%A5%BF%A1%BC%A5%F3%A5%DE%A5%C3%A5%C1
英語の試せるサイト（irbが動けば必要ないかもね）：http://rubular.com/</dd>
<dt>○Rubyの範囲に関する情報</dt>
<dd>日本語：http://doc.okkez.net/static/192/class/Range.html
英語：RDocのRangeクラスに相当するのかな。</dd>
</dl>
<h3 id="試してみよう">（試してみよう）</h3>
<dl>
<dt>○文字列"Hello, world"を出力する。</dt>
<dd>```
<dt>○文字列"Hello, Ruby"の中の"Ruby"という単語のインデックスを検索する。</dt>
<dd>```
<p>s = &lsquo;Hello, Ruby&rsquo;
s.index(&lsquo;Ruby&rsquo;) //indexofで間違えた</p>
<pre><code class="language-</dd>" data-lang="</dd>">&lt;dt&gt;○自分の名前を10回出力する。&lt;/dt&gt;
&lt;dd&gt;```

※まずは、正統派。
i = 0
while i &lt; 10
  puts &quot;johtani&quot;
  i = i + 1
end
</code></pre><pre><code>※Rangeを利用
(1..10).each {|n| puts &quot;johtani #{n}&quot;}
</code></pre><pre><code>
※forもあるよね
for i in 1..10
  puts &quot;johtani&quot;
end
</code></pre><pre><code>
※timesってのもある。（0始まり）
10.times {|n| puts &quot;johtani #{n}&quot;}
</code></pre><pre><code>
※uptoなんてのもあるのか。
1.upto(10) {|n| puts &quot;johtani #{n}&quot;}
</code></pre><pre><code>
※downtoも
10.downto(1) {puts &quot;johtani&quot;}
</code></pre><pre><code>
※stepもある。
10.step(1, -1) {puts &quot;johtani&quot;}//step(上限,ステップ)
```&lt;/dd&gt;
&lt;dt&gt;○文字列&quot;This is sentence number 1&quot;の1を10までカウントアップしながら10回出力する。&lt;/dt&gt;
&lt;dd&gt;```

1.upto(10) {|n| puts &quot;This is sentence number #{n}&quot;}
※あとは上記と一緒
```&lt;/dd&gt;
&lt;dt&gt;○ファイルに格納されているRubyプログラムを実行する。&lt;/dt&gt;
&lt;dd&gt;```

vi hoge.rb
※#上記処理をどれか記述
</code></pre><pre><code>
 $ ruby hoge.rb
</code></pre></dd>
<dt>○ボーナス問題：少し物足りない人は、乱数を選択するプログラムを書いてみてほしい。プレーヤーに数字を選択してもらい、その数字が生成された乱数よりも大きいか小さいかを返す。</dt>
<dd>
```
<h1 id="---coding-utf-8---">-<em>- coding: utf-8 -</em>-</h1>
<p>range = (1..100)
while true
puts &ldquo;#{range.min}から#{range.max}の数字を入力してください&rdquo;
n = gets
n = n.to_i
if range.include?(n)
break;
else
puts &ldquo;範囲外の入力値です。もう一度入力してください&rdquo;
end
end
i = rand(range.max)
if i &lt; n
puts &ldquo;入力「#{n}」は乱数「#{i}」より大きいです&rdquo;
elsif i == n
puts &ldquo;入力「#{n}」は乱数「#{i}」と等しいです&rdquo;
else
puts &ldquo;入力「#{n}」は乱数「#{i}」より小さいです&rdquo;
end</p>
<pre><code class="language-</dd>" data-lang="</dd>">&lt;/dl&gt;

とまぁ、こんな感じ。こんな方法もあるよ、ここおかしくない？などあれば、コメント欄まで。
リアクション大募集です。
はやく、シンタックスライター導入せねば。
</code></pre></content:encoded>
    </item>
    
  </channel>
</rss>
