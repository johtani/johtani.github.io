<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>azure search on @johtaniの日記 3rd</title>
    <link>https://blog.johtani.info/tags/azure-search/</link>
    <description>Recent content in azure search on @johtaniの日記 3rd</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja</language>
    <lastBuildDate>Tue, 18 Aug 2020 18:26:47 +0900</lastBuildDate><atom:link href="https://blog.johtani.info/tags/azure-search/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>TerraformでAzure Cognitive Searchのクラスターを起動</title>
      <link>https://blog.johtani.info/blog/2020/08/18/azure-search-with-terraform/</link>
      <pubDate>Tue, 18 Aug 2020 18:26:47 +0900</pubDate>
      
      <guid>https://blog.johtani.info/blog/2020/08/18/azure-search-with-terraform/</guid>
      <description>負荷を計測するために、数回、Azure Cognitive Searchのクラスターを起動したり、停止したりしてました。 これは、Terraformでやると楽でき</description>
      <content:encoded><p>負荷を計測するために、数回、Azure Cognitive Searchのクラスターを起動したり、停止したりしてました。
これは、<a href="https://www.terraform.io/">Terraform</a>でやると楽できるのでは?と思ったので、やってみました。
1パーティションのクラスターなので、全然大したことはないのですが、メモを残しておくためにブログに書いておきます。</p>
<p>基本的には<a href="https://www.terraform.io/docs/providers/azurerm/r/search_service.html">Terraformの公式ドキュメント</a>にあったものを自分用に変数を抽出しただけです。</p>
<h2 id="ファイルたち">ファイルたち</h2>
<p>単にクラスターを起動するためだけなので、2種類のファイルだけ作成しました(1個でもいいかも)。</p>
<ul>
<li><code>variables.tf</code> - 変数用のファイル。いくつかの設定を変数として定義しました。</li>
<li><code>terraform.tf</code> - Terraform本体のファイル。</li>
</ul>
<h3 id="variablestf"><code>variables.tf</code></h3>
<p>まずは<code>variables.tf</code>です(ファイル内の並びは異なりますが。。。)。terraform.tfで利用する5つの変数です。</p>
<ul>
<li>resource_group - リソースグループ名。既存とは異なるリソースグループ名にしました(変に壊してもいいので)。</li>
<li>machine_type - 価格レベル(SKU)。<a href="https://www.terraform.io/docs/providers/azurerm/r/search_service.html#sku">公式ドキュメントに設定できる値の一覧</a>があります。今回はWikipediaのデータを登録していたのでそれが入るサイズにしています。</li>
<li>region - 場所(リージョン)。リージョンの一覧はどこにあるんだろう?<a href="https://azure.microsoft.com/en-us/global-infrastructure/geographies/#geographies">これを参考</a>にしましたが。</li>
<li>partition_size - パーティションのサイズ(=Elasticsearchでのシャードかな?)です。今回は1つでの性能を計測したかったので1にしてあります。</li>
<li>search_cluster_name - Azure Cognitive Searchのサービス名。<code>search.windows.net</code>名前空間で一意である必要があったので、他の人が使わなそうな名前をつけています。</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml">variable <span style="color:#e6db74">&#34;machine_type&#34;</span> {
  default = <span style="color:#e6db74">&#34;standard&#34;</span>
}

variable <span style="color:#e6db74">&#34;region&#34;</span> {
  default = <span style="color:#e6db74">&#34;East Asia&#34;</span>
}

variable <span style="color:#e6db74">&#34;resource_group&#34;</span> {
  default = <span style="color:#e6db74">&#34;johtani-wiki-test&#34;</span>
}

variable <span style="color:#e6db74">&#34;search_cluster_name&#34;</span> {
  default = <span style="color:#e6db74">&#34;johtani-wikipedia&#34;</span>
}

variable <span style="color:#e6db74">&#34;partition_size&#34;</span> {
  default = <span style="color:#ae81ff">1</span>
}
</code></pre></div><h3 id="terraformtf"><code>terraform.tf</code></h3>
<p><code>terraform.tf</code>は以下の通り。<a href="https://www.terraform.io/docs/providers/azurerm/r/search_service.html">Terraformの公式ドキュメントにある例</a>に<code>provider</code>を追加しただけのものになります。</p>
<ul>
<li>provider - プロバイダーの設定。Azureを利用するという宣言です。<code>features {}</code>がないとエラーになります。空でも必ず指定が必要です。認証周りについては、<a href="https://www.terraform.io/docs/providers/azurerm/guides/azure_cli.html"><code>azure-cli</code>経由で認証する方式</a>を採用しました。<code>azure-cli</code>はHomebrewでインストールしています。</li>
<li>azurerm_resource_group - リソースグループの設定。<code>variables.tf</code>の<code>resource_group</code>と<code>region</code>を利用しています。必須項目はこの2種類だけです。</li>
<li>azurerm_search_service - Azure Cognitive Searchの設定。<code>partition_count</code>以外は必須項目です。<code>variables.tf</code>と<code>azurerm_resource_group</code>の設定を利用しています。今回は利用していませんが、レプリカ数なども指定できるようになっています。</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#75715e"># Azureのproviderを指定。</span>
provider <span style="color:#e6db74">&#34;azurerm&#34;</span> {
  features {}
}

<span style="color:#75715e"># リソースグループの設定</span>
resource <span style="color:#e6db74">&#34;azurerm_resource_group&#34;</span> <span style="color:#e6db74">&#34;wiki-test&#34;</span> {
  name     = var.resource_group
  location = var.region
}

<span style="color:#75715e"># Azure Cognitive Searchの設定</span>
resource <span style="color:#e6db74">&#34;azurerm_search_service&#34;</span> <span style="color:#e6db74">&#34;search_service&#34;</span> {
  name                = var.search_cluster_name
  resource_group_name = azurerm_resource_group.wiki-test.name
  location            = azurerm_resource_group.wiki-test.location
  sku                 = var.machine_type
  partition_count     = var.partition_size
}
</code></pre></div><p>以上がファイルです。ほぼ公式ドキュメントのサンプル通りですねw</p>
<h2 id="デプロイとか">デプロイとか</h2>
<p>ファイルの準備ができたら実際にデプロイします。
Azureの環境への認証にはAzure CLIを利用して、事前にログインした状態にします。
実際にデプロイするまでの手順は次のようになります。</p>
<ol>
<li><code>az login</code> - Azureの認証。ブラウザが起動してログイン画面が表示されます。無事認証がOKなら、<code>az</code>コマンドでAzure Cloudの情報が取得できます。</li>
<li><code>terraform init</code> - 初回だけです。Terraformのワーキングディレクトリの初期化処理を実行します。</li>
<li><code>terraform plan</code> - Terraform &lt; 0.12の場合は実行。最新版だともういらないみたいだ。</li>
<li><code>terraform apply</code> - 実際にAzure上にクラスターを起動します。Terraformが隠蔽してくれているので、実際にどんなことをやっているかはわかってないですが。</li>
</ol>
<p>以上で、Azure Cognitive Searchのクラスターが起動します。
すごく簡単です。Webコンソールでチェックすれば、起動していることも確認できます。</p>
<p>この状態では、クラスターが起動しただけなので、あとは必要に応じてデータをロードしたり、アプリから検索したりと行ったことが可能になります。
そのへんの話はまた機会があれば。</p>
<h2 id="destroy">Destroy</h2>
<p>今回は負荷テスト用にクラスターを起動していましたので、必要なくなれば、クラスターを削除します。Terraformを導入したもう一つの理由がこの簡略化です。
<code>terraform destroy</code>を実行するだけで、Azure Cognitive Searchのクラスターおよび、リソースグループが削除されます。</p>
<h2 id="まとめ">まとめ</h2>
<p>ということで、ほぼ公式ドキュメントのままですが、TerraformでAzure Cognitive Searchのクラスターを起動する方法の紹介でした。
ブログを書いていて、1点気になったのは、ロケーション(リージョン)の一覧はどこにあるんだろう?という点です。azコマンドとかで出てくるのかなぁ?</p>
</content:encoded>
    </item>
    
    <item>
      <title>Azure Cognitive Searchでの日本語向けAnalyzerの違い</title>
      <link>https://blog.johtani.info/blog/2020/06/09/difference-analyzers-in-azure-search/</link>
      <pubDate>Tue, 09 Jun 2020 17:44:00 +0900</pubDate>
      
      <guid>https://blog.johtani.info/blog/2020/06/09/difference-analyzers-in-azure-search/</guid>
      <description>Azure Cognitive Searchで日本語を扱うときに、形態素解析器を使いたい場合、2種類のAnalyzerが用意されています。今回はこれらの違いがどんなもの</description>
      <content:encoded><p>Azure Cognitive Searchで日本語を扱うときに、形態素解析器を使いたい場合、2種類のAnalyzerが用意されています。今回はこれらの違いがどんなものかを見ていくことにします。</p>
<h2 id="analyzerとは">Analyzerとは?</h2>
<p>まずは、その前にAnalyzerとは何者か?というのを少しだけ。
Azure Cognitive Searchは<a href="https://ja.wikipedia.org/wiki/%E8%BB%A2%E7%BD%AE%E3%82%A4%E3%83%B3%E3%83%87%E3%83%83%E3%82%AF%E3%82%B9">転置インデックス</a>を内部で作成して、検索を行っています。
この、転置インデックスは、「単語」がどのドキュメントに入っているか?を素早く見つけることができるデータ構造となっています。</p>
<p>Azure Cognitive Searchは、この「単語」を入力された文章から生成するときに、Analyzerというものを利用します。
Analyzerは入力された文章をある規則に則って単語に分割する機能です。
この「ある規則」が、各種言語や用途によって様々に用意されています。
今回はこの中の<code>ja.lucene</code>と<code>ja.microsoft</code>という2種類のAnalyzerについて違いを見ていきます。</p>
<h2 id="2種類のanalyzerの違いはどんなもの">2種類のAnalyzerの違いはどんなもの?</h2>
<p>このAnalyzerの挙動を見るためのエンドポイントとして<code>analyze</code>というAPIがあります(<a href="https://blog.johtani.info/blog/2020/03/19/azure-search-analyze-plugin/">詳細は昔のブログを参照</a>)。</p>
<p>このAPIを利用して、Wikipediaのいくつかの文章を単語に区切って見て、
<code>ja.microsoft</code>がどんな動きをしているのか想像してみます(残念ながら<code>ja.microsoft</code>の仕様?や挙動についてはページが見つからないため)。</p>
<h3 id="もとの文章と解析結果一部抜粋">もとの文章と解析結果(一部抜粋)</h3>
<p>文章は、手元のElasticsearchに登録したjawikiのデータからランダムに抽出しています。また、自前のツールで生成したWikipediaのデータなので、まだ一部、見苦しい文字列になっています(そっちもなおさないと)。</p>
<h4 id="1-砂川熊本県">1. 砂川（熊本県）</h4>
<blockquote>
<p>thumb|250px|right|上砂川橋より上流方砂川（すながわ）は、熊本県宇城市・八代郡氷川町を流れる二級河川。</p>
</blockquote>
<p>この文字列から抽出された単語で特徴的なものを一部抜粋しました。</p>
<table>
<thead>
<tr>
<th><code>ja.microsoft</code></th>
<th><code>ja.lucene</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>250px</td>
<td>250</td>
</tr>
<tr>
<td></td>
<td>px</td>
</tr>
<tr>
<td>上砂</td>
<td>上, 上砂川</td>
</tr>
<tr>
<td>川橋</td>
<td>砂川</td>
</tr>
<tr>
<td></td>
<td>橋</td>
</tr>
<tr>
<td>宇城</td>
<td>宇</td>
</tr>
<tr>
<td>市</td>
<td>城市</td>
</tr>
<tr>
<td>二級</td>
<td>二</td>
</tr>
<tr>
<td>^</td>
<td>級</td>
</tr>
</tbody>
</table>
<p>まず、最初の<code>250px</code>ですが、<code>ja.microsoft</code>では、<code>px</code>が単位であると判定しているのか、数値と合わせた単語として抽出されています。この場合、<code>250</code>で検索しても、この文字列はヒットしない形になるので、ノイズが減ることが考えられるかと。</p>
<p><code>上砂川橋</code>という文字は、分割の仕方が別れました。
<code>ja.lucene</code>では、<code>上砂川</code>という単語が地名として辞書に存在するために、このような分割になっています。<code>ja.microsoft</code>のデータは品詞の情報が取れないのですが、<code>上砂</code>、<code>川橋</code>ともに、名詞として辞書に存在しているのではないかなと。<code>ja.lucene</code>には<code>川橋</code>という単語は存在していないようでした。</p>
<p><code>宇城市</code>(うきし)については、2005年に合併でできた市のようで、<code>ja.lucene</code>が利用している辞書には存在しない可能性があり、<code>宇城</code>という文字が抽出できてないと思われます。</p>
<p>最後は<code>二級</code>です。<code>ja.lucene</code>では、数字と助数詞として分割されています。こちらも何かしらのロジックにより、<code>二級</code>という1単語でヒットできるように数字と単位?が合わせた単語で出てくる仕組みが<code>ja.microsoft</code>なのかなと。</p>
<h4 id="2-uefa-u-18女子選手権2000">2. UEFA U-18女子選手権2000</h4>
<blockquote>
<p>UEFA U-18女子選手権2000は第3回目のUEFA U-18女子選手権である。決勝トーナメントは2000年7月27日から8月4日までフランスで行われ、ドイツが初優勝を果たした。</p>
</blockquote>
<p>この文字列から抽出された単語で特徴的なものを一部抜粋しました。</p>
<table>
<thead>
<tr>
<th><code>ja.microsoft</code></th>
<th><code>ja.lucene</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>u-18, u</td>
<td>u</td>
</tr>
<tr>
<td>18, nn18</td>
<td>18</td>
</tr>
<tr>
<td>第3回目</td>
<td>第</td>
</tr>
<tr>
<td></td>
<td>3</td>
</tr>
<tr>
<td></td>
<td>回</td>
</tr>
<tr>
<td></td>
<td>目</td>
</tr>
<tr>
<td>トーナメント, トナメント</td>
<td>トーナメント</td>
</tr>
<tr>
<td>2000年</td>
<td>2000</td>
</tr>
<tr>
<td></td>
<td>年</td>
</tr>
<tr>
<td>7月</td>
<td>7</td>
</tr>
<tr>
<td></td>
<td>月</td>
</tr>
<tr>
<td>27日</td>
<td>27</td>
</tr>
<tr>
<td></td>
<td>日</td>
</tr>
</tbody>
</table>
<p>数字を含む単語<code>第3回目</code>や<code>2000年</code>、<code>7月</code>などは、<code>ja.microsoft</code>は先程と同様、数字と単位の組み合わせを1単語として出力しています。</p>
<p>また、<code>トーナメント</code>という単語を<code>トナメント</code>という形で、長音を除去した形で出力しています。
今回の文字列ではないですが、この他に、<code>センター</code>を<code>センター</code>と<code>センタ</code>の2パターンの単語で出力するといったことを行っています。
<code>ja.lucene</code>の場合、単語の最後に長音がある場合だけ<code>センタ</code>として、長音を除去した単語が出力されます。
これは、長音の表記ゆれに対応するためではないかなと。たとえば、<code>インターフェース</code>と<code>インタフェース</code>、<code>インターフェイス</code>のように、人や文章によって、間にでてくる長音を使ったり使わなかったりという表記ゆれに対応するためだと思われます。
その他にも、<code>イプロゥヴェト</code>を<code>イプロゥベト</code>に、<code>ネクスト</code>を<code>ネキスト</code>に、<code>バラエティ</code>を<code>バラエチ</code>にも変換するなどといった処理をしてくれるようです。カタカナの表記ゆれには強そうですね(これどうやってるんだろう?)。</p>
<p><code>ja.microsoft</code>では、<code>nn18</code>というちょっと変わった単語も出てきていました。純粋な数字の場合は<code>nn</code>と入力してくれるようで、数字だけで検索したい場合に利用できるのかな?これはドキュメントに書いておいてほしいかも?</p>
<h3 id="共通点">共通点</h3>
<p><code>ja.lucene</code>、<code>ja.microsoft</code>ともに、共通している動作として、「てにをは」といった単語は除去されていました。違いがあるものとしては、「より」(助詞-格助詞-一般)、「されている」(動詞-自立、動詞-接尾、助詞-接続助詞、動詞-非自立)、「ある」(助動詞)といったものは<code>ja.microsoft</code>では除去されずに出てきていました。
ストップワード的に「てにをは」あたりを除去をしている感じでしょうか?</p>
<p>アルファベットで構成されている単語についても、基本はそのまま出力される挙動のようでした。</p>
<h2 id="じゃあどっちがいいの">じゃあどっちがいいの?</h2>
<p>残念ながらどちらがいいかは、一長一短かなぁと。
<code>ja.lucene</code>に関しては、Luceneの仕組みを利用しているので、Elasticsearchなどを使えば、個別の単語についてより詳細の情報を取得することが可能です(品詞、読みなど)。<code>ja.microsoft</code>については、残念ながら手の入れようがないので、そういう動きのものだという割り切った使い方になるでしょうか?
ただ、長音の除去による表記ゆれなどについては、便利な機能なので、そのあたりの問題に対応したい場合は、<code>ja.microsoft</code>を活用するのも良いかと思います。</p>
<p>個人的には、より細かい単語としてインデックスに登録できるもののほうが、柔軟な検索には対応できるのではないかなぁと考えています(Kuromojiの辞書をUniDicにするとか?も考えますが、これはAzure Searchではできないですが)。</p>
<h2 id="まとめ">まとめ</h2>
<p>Wikipediaのデータをいくつか使って、<code>ja.microsoft</code>と<code>ja.lucene</code>の違いについて、考察してみました。何かの役に立てばと。
他に、これはどんな感じになるの?などありましたら、コメントいただければと。</p>
</content:encoded>
    </item>
    
    <item>
      <title>Azure Cognitive Searchのリクエストのロギング</title>
      <link>https://blog.johtani.info/blog/2020/05/26/logging-azure-search-request/</link>
      <pubDate>Tue, 26 May 2020 17:22:47 +0900</pubDate>
      
      <guid>https://blog.johtani.info/blog/2020/05/26/logging-azure-search-request/</guid>
      <description>今回はAzure Cognitive SearchのSDKを利用したアプリケーションが、実際にAzure Cognitive Searchに対して送信しているリクエストのパラメータ</description>
      <content:encoded><p>今回はAzure Cognitive SearchのSDKを利用したアプリケーションが、実際にAzure Cognitive Searchに対して送信しているリクエストのパラメータとボディをログに保存する方法について紹介します。</p>
<h2 id="動機">動機</h2>
<p>アプリケーションでリクエストを組み立てて、SDK経由で送信していると、最終的にAzure Cognitive Searchに対して送信されているリクエストのパラメータや検索条件などをひと目で見たいことがあります。
アプリケーションでは、ソート条件や、クエリ文字列の組み立てなどの処理は異なる場所で行われたりしますので。</p>
<p>また、公式リファレンスでは、機能の説明はRest APIの使い方と組み合わせで説明されることが多いです。</p>
<p>ということで、SDKを利用しているアプリからAzure Searchへ送信されているリクエストをログに保存する方法を調べてみました。</p>
<h2 id="方法">方法</h2>
<p>調べてみるといくつかの手段を取ることができそうだとわかりました。実際に調べて実装する方法を4種類ほど試してみたのでブログに残しておきます。なお、2020年4月時点でのSDKとAzureの仕組みに基づいたブログになります。最新版ではお手軽な方法があるかもしれません。</p>
<ol>
<li>DelegatingHandlerを利用する</li>
<li>ServiceClientTracingの機能を利用する</li>
<li>Azure Application Insightsを活用する</li>
<li>Azure Cognitive Searchのコンソールにある診断情報の機能を利用する</li>
</ol>
<p>1、2はAzure Cognitive SearchのSDKのリファレンスから当たりを付けて見つけた方法です。
3はApplication Insights、4はAzure Cognitive Searchの機能になります。
これらの方法について個別に説明していきます。</p>
<h3 id="1-delegatinghandleを利用する">1. DelegatingHandleを利用する</h3>
<p>まずは、SDKでロギングの機能がないかを調べて見つけた機能がこちらです。
SDKの<a href="https://docs.microsoft.com/ja-jp/dotnet/api/microsoft.azure.search.searchserviceclient.-ctor?view=azure-dotnet#Microsoft_Azure_Search_SearchServiceClient__ctor_System_String_Microsoft_Azure_Search_SearchCredentials_System_Net_Http_HttpClientHandler_System_Net_Http_DelegatingHandler___">SearchServiceClient</a>のコンストラクタの引数に<a href="https://docs.microsoft.com/en-us/dotnet/api/system.net.http.delegatinghandler?view=netframework-4.8">DelegatingHandler</a>というものが渡せることを発見しました。</p>
<p>これは、.NET FrameworkのHttpのAPIに存在するクラスで、HTTPのクライアントがHTTPの送受信時に、処理を挟むことができる機能です。フレームワーク側で、<a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.extensions.http.logging.logginghttpmessagehandler?view=dotnet-plat-ext-3.1&amp;viewFallbackFrom=netframework-4.8">LoggingHttpMessaggeHandler</a>というクラスを用意してくれていましたが、残念ながらこちらは、リクエストとレスポンスのヘッダのみをロギングするクラスでした。
ということで、リクエストボディをログに出力したい場合は独自に拡張してやる必要があります。なお、ロギングには<code>Microsoft.Extensions.Logging</code>の<code>ILogger</code>を使用します。</p>
<p>また、Azure Cognitive SearchのSDK側に違う問題点もありました。<a href="https://docs.microsoft.com/ja-jp/azure/search/tutorial-csharp-create-first-app#add-the-runqueryasync-method">チュートリアルにあるように</a>、検索するときには、SDKは次のような使い方を想定しています。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C#" data-lang="C#">        <span style="color:#75715e">// Create a service and index client.
</span><span style="color:#75715e"></span>        _serviceClient = <span style="color:#66d9ef">new</span> SearchServiceClient(searchServiceName, <span style="color:#66d9ef">new</span> SearchCredentials(queryApiKey));
        _indexClient = _serviceClient.Indexes.GetClient(<span style="color:#e6db74">&#34;hotels&#34;</span>);
</code></pre></div><p>インデックス用のクライアントを取得するために、<code>GetClient(インデックス名)</code>というメソッドを使用します。この<a href="https://docs.microsoft.com/ja-jp/dotnet/api/microsoft.azure.search.indexesgetclientextensions.getclient?view=azure-dotnet#Microsoft_Azure_Search_IndexesGetClientExtensions_GetClient_Microsoft_Azure_Search_IIndexesOperations_System_String_"><code>GetClient</code>メソッドのバリエーション</a>として、DelegatingHandlerを受け取るメソッドがないのです。。。</p>
<p>ということで、DelegationHandlerを活用する方法としては、以下の2つを実装する必要があります。</p>
<ol>
<li>CustomなLoggingHttpMessageHandlerクラスを実装</li>
<li>GetClientと同等の処理をDelegatingHandlerを引数にしたものを実装する</li>
</ol>
<p>以上の2つを実装し、アプリケーション側から2で作成したGetClientを呼び出すことで、リクエストをボディも含めてログ出力することが可能になります。以下は実装例です。</p>
<p>CustomHttpMessageHandlerクラス。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C#" data-lang="C#"><span style="color:#66d9ef">using</span> System;
<span style="color:#66d9ef">using</span> System.Collections.Generic;
<span style="color:#66d9ef">using</span> System.Diagnostics;
<span style="color:#66d9ef">using</span> System.Net.Http;
<span style="color:#66d9ef">using</span> System.Net.Http.Headers;
<span style="color:#66d9ef">using</span> System.Text;
<span style="color:#66d9ef">using</span> System.Threading;
<span style="color:#66d9ef">using</span> System.Threading.Tasks;
<span style="color:#66d9ef">using</span> Microsoft.Extensions.Logging;

<span style="color:#66d9ef">namespace</span> AzureSearchSample
{
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">CustomLoggingHttpMessageHandler</span> : DelegatingHandler
    {
        <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">readonly</span> ILogger _logger;
        <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">readonly</span> <span style="color:#66d9ef">bool</span> _logContent = <span style="color:#66d9ef">false</span>;

        <span style="color:#66d9ef">public</span> CustomLoggingHttpMessageHandler(ILogger logger, <span style="color:#66d9ef">bool</span> logContent)
        {
            <span style="color:#66d9ef">if</span> (logger == <span style="color:#66d9ef">null</span>)
            {
                <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> ArgumentNullException(nameof(logger));
            }

            <span style="color:#66d9ef">this</span>._logger = logger;
            <span style="color:#66d9ef">this</span>._logContent = logContent;
        }


        <span style="color:#66d9ef">protected</span> <span style="color:#66d9ef">override</span> <span style="color:#66d9ef">async</span> Task&lt;HttpResponseMessage&gt; SendAsync(HttpRequestMessage request, CancellationToken cancellationToken)
        {
            <span style="color:#66d9ef">if</span> (request == <span style="color:#66d9ef">null</span>)
            {
                <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> ArgumentNullException(nameof(request));
            } 
            <span style="color:#66d9ef">await</span> Log.RequestStart(<span style="color:#66d9ef">this</span>._logger, request, <span style="color:#66d9ef">this</span>._logContent);
            <span style="color:#66d9ef">var</span> stopwatch = <span style="color:#66d9ef">new</span> Stopwatch();
            HttpResponseMessage response = <span style="color:#66d9ef">await</span> <span style="color:#66d9ef">base</span>.SendAsync(request, cancellationToken).ConfigureAwait(<span style="color:#66d9ef">false</span>);
            stopwatch.Stop();
            <span style="color:#66d9ef">await</span> Log.RequestEnd(<span style="color:#66d9ef">this</span>._logger, response, stopwatch.Elapsed);

            <span style="color:#66d9ef">return</span> response;
        }

        <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Log</span>
        {
            <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">EventIds</span>
            {
                <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">readonly</span> EventId RequestStart = <span style="color:#66d9ef">new</span> EventId(<span style="color:#ae81ff">100</span>, <span style="color:#e6db74">&#34;RequestStart&#34;</span>);
                <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">readonly</span> EventId RequestEnd = <span style="color:#66d9ef">new</span> EventId(<span style="color:#ae81ff">101</span>, <span style="color:#e6db74">&#34;RequestEnd&#34;</span>);
            }

            <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">async</span> Task RequestStart(ILogger logger, HttpRequestMessage request, <span style="color:#66d9ef">bool</span> logContent)
            {
                StringBuilder message = <span style="color:#66d9ef">new</span> StringBuilder();
                message.AppendLine(<span style="color:#e6db74">$&#34;Sending HTTP request {request.Method} {request.RequestUri}&#34;</span>);
                <span style="color:#66d9ef">if</span> (logger.IsEnabled(LogLevel.Trace))
                {
                    LogHttpHeaders(message, request.Headers);
                    <span style="color:#66d9ef">await</span> LogHttpContent(message, request.Content, logContent);
                    logger.Log(
                        LogLevel.Trace,
                        EventIds.RequestStart,
                        message,
                        <span style="color:#66d9ef">null</span>,
                        (state, ex) =&gt; state.ToString());
                }
            }

            <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">async</span> Task RequestEnd(ILogger logger, HttpResponseMessage response, TimeSpan duration)
            {
                StringBuilder message = <span style="color:#66d9ef">new</span> StringBuilder();
                message.AppendLine(
                    <span style="color:#e6db74">$&#34;Recieving HTTP response after {duration.TotalMilliseconds}ms - {response.StatusCode}&#34;</span>);
                <span style="color:#66d9ef">if</span> (logger.IsEnabled(LogLevel.Trace))
                {
                    LogHttpHeaders(message, response.Headers);
                    <span style="color:#66d9ef">await</span> LogHttpContent(message, response.Content, <span style="color:#66d9ef">false</span>);
                    logger.Log(
                        LogLevel.Trace,
                        EventIds.RequestEnd,
                        message,
                        <span style="color:#66d9ef">null</span>,
                        (state, ex) =&gt; state.ToString()
                        );
                }
            }

            <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> LogHttpHeaders(StringBuilder message, HttpHeaders headers)
            {
                <span style="color:#66d9ef">if</span> (headers == <span style="color:#66d9ef">null</span>) <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> ArgumentNullException(nameof(headers));
                <span style="color:#66d9ef">foreach</span> (KeyValuePair&lt;<span style="color:#66d9ef">string</span>, IEnumerable&lt;<span style="color:#66d9ef">string</span>&gt;&gt; header <span style="color:#66d9ef">in</span> headers)
                {
                    <span style="color:#66d9ef">foreach</span> (<span style="color:#66d9ef">string</span> <span style="color:#66d9ef">value</span> <span style="color:#66d9ef">in</span> header.Value)
                    {
                        message.AppendLine(<span style="color:#e6db74">$&#34;{header.Key}: {value}&#34;</span>);
                    }
                }
            }

            <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">async</span> Task LogHttpContent(StringBuilder message, HttpContent content,
                <span style="color:#66d9ef">bool</span> logContent)
            {
                <span style="color:#66d9ef">if</span> (content != <span style="color:#66d9ef">null</span>)
                {
                    <span style="color:#66d9ef">foreach</span> (KeyValuePair&lt;<span style="color:#66d9ef">string</span>,IEnumerable&lt;<span style="color:#66d9ef">string</span>&gt;&gt; header <span style="color:#66d9ef">in</span> content.Headers)
                    {
                        <span style="color:#66d9ef">foreach</span> (<span style="color:#66d9ef">string</span> <span style="color:#66d9ef">value</span> <span style="color:#66d9ef">in</span> header.Value)
                        {
                            message.AppendLine(<span style="color:#e6db74">$&#34;{header.Key}: {value}&#34;</span>);
                        }
                    }

                    <span style="color:#66d9ef">if</span> (logContent)
                    {
                        <span style="color:#66d9ef">string</span> contentBody = <span style="color:#66d9ef">await</span> content.ReadAsStringAsync();
                        message.AppendLine(contentBody);
                    }
                }
            }
        }
    }
}
</code></pre></div><p>GetClientの実装</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C#" data-lang="C#">
        <span style="color:#66d9ef">private</span> ISearchIndexClient GetClient(<span style="color:#66d9ef">string</span> indexName, <span style="color:#66d9ef">params</span> DelegatingHandler[] handlers)
        {
            <span style="color:#66d9ef">var</span> rootHandler = _searchServiceClient.HttpMessageHandlers.OfType&lt;HttpClientHandler&gt;().SingleOrDefault();
            <span style="color:#66d9ef">var</span> indexClient =
                <span style="color:#66d9ef">new</span> SearchIndexClient(_searchServiceClient.SearchServiceName, indexName,
                    _searchServiceClient.SearchCredentials, rootHandler, handlers)
                {
                    SearchDnsSuffix = _searchServiceClient.SearchDnsSuffix
                };

            indexClient.HttpClient.Timeout = _searchServiceClient.HttpClient.Timeout;
            <span style="color:#66d9ef">return</span> indexClient;
        }
</code></pre></div><p>出力されるログ例</p>
<pre><code>2020/04/14 19:17:53.591|TRACE|Sending HTTP request POST https://サービス名.search.windows.net/indexes('インデックス名')/docs/search.post.search?api-version=2019-05-06
client-request-id: be02140f-3a07-48cc-b018-d8aa5e819bc3
Accept-Language: en-US
Accept: application/json; odata.metadata=none
api-key: APIキー
User-Agent: FxVersion/4.700.20.11803
User-Agent: OSName/MacOs
User-Agent: OSVersion/Darwin.19.4.0.Darwin.Kernel.Version.19.4.0.Wed.Mar.4.22.28.40.PST.2020.root.xnu.6153.101.6.15RELEASE.X86.64
User-Agent: Microsoft.Azure.Search.SearchIndexClient/10.100.19.52907
Content-Type: application/json; charset=utf-8
{
  &quot;count&quot;: false,
  &quot;facets&quot;: [],
  &quot;queryType&quot;: &quot;simple&quot;,
  &quot;scoringParameters&quot;: [],
  &quot;search&quot;: &quot;azure&quot;,
  &quot;searchMode&quot;: &quot;any&quot;
}
 |AzureSearchSample.SearchService|EventId_Id=100, EventId_Name=RequestStart, EventId=RequestStart
</code></pre><h4 id="メリットデメリット">メリット、デメリット</h4>
<p>Azure Cognitive Searchの検索の処理だけを対象にリクエストのログを出力することが可能です。また、影響範囲はアプリケーションだけに閉じていますので、デバッグ目的などでログ出力したい場合に、自分だけの手元でログの確認が可能になります。</p>
<p>デメリットとしては、独自に実装しなければいけない範囲が広いことです。</p>
<h3 id="2-serviceclienttracingの機能を利用する">2. ServiceClientTracingの機能を利用する</h3>
<p><code>Microsoft.Rest.ClientRuntime</code>というライブラリをAzure Cognitive Searchは利用しています。
このライブラリに<a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.rest.serviceclienttracing?view=azure-dotnet"><code>ServiceClientTracing</code></a>というクラスが存在します。
なにやら、クライアントの処理のトレースができそうです。</p>
<p>Azure Cognitive SearchのSDKの実装がGitHubに公開されており、検索リクエストの処理を投げる直前に、このトレースの仕組がONになっていると、<a href="https://github.com/Azure/azure-sdk-for-net/blob/a080ceda8df5e397aadd4b7c48c83431c5203b59/sdk/search/Microsoft.Azure.Search.Data/src/Generated/DocumentsOperations.cs#L798"><code>ServiceClientTracing.SendRequest</code>メソッドを呼び出していました</a>。</p>
<p>実際に<code>SendRequest</code>メソッドに送られたものに対して何かしらの処理を行うのは、<a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.rest.iserviceclienttracinginterceptor?view=azure-dotnet"><code>IServiceClientTracingIntercepter</code></a>インターフェースを実装したクラスになります。
このインターフェースの実装が<a href="https://www.nuget.org/packages/Microsoft.Rest.ClientRuntime.Log4Net/">Log4Net</a>に存在します。Log4Netを利用している場合は、これを活用すれば楽ができます。</p>
<p>実際に<code>ServiceClientTracing</code>を有効にするには、以下の2行を呼び出すだけです。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C#" data-lang="C#">ServiceClientTracing.IsEnabled = <span style="color:#66d9ef">true</span>;
ServiceClientTracing.AddTracingInterceptor(<span style="color:#66d9ef">new</span> Log4NetTracingInterceptor());
</code></pre></div><p>あとは、Rest.ClientRuntimeがよしなにやってくれます。
1とは異なり、トレースログなので、リクエストのボディについても出力してくれます。</p>
<pre><code>2020-05-26 19:09:04,058 [1] DEBUG Microsoft.Rest.Tracing.Log4Net.Log4NetTracingInterceptor [(null)] - invocationId: 1
instance: Microsoft.Azure.Search.DocumentsProxyOperations
method: SearchPost
parameters: {searchRequest=Microsoft.Azure.Search.Models.SearchRequest,clientRequestId=,cancellationToken=System.Threading.CancellationToken}
2020-05-26 19:09:04,164 [1] DEBUG Microsoft.Rest.Tracing.Log4Net.Log4NetTracingInterceptor [(null)] - invocationId: 1
request: Method: POST, RequestUri: 'https://サービス名.search.windows.net/indexes('インデックス名')/docs/search.post.search?api-version=2019-05-06', Version: 2.0, Content: System.Net.Http.StringContent, Headers:
{
  client-request-id: 591cb14f-e5c2-4a85-977d-01d1f6431ddc
  Accept-Language: en-US
  Accept: application/json; odata.metadata=none
  api-key: APIキー
  Content-Type: application/json; charset=utf-8
}

Body:
{
{
  &quot;count&quot;: false,
  &quot;facets&quot;: [],
  &quot;queryType&quot;: &quot;simple&quot;,
  &quot;scoringParameters&quot;: [],
  &quot;search&quot;: &quot;azure&quot;,
  &quot;searchMode&quot;: &quot;any&quot;
}
}

2020-05-26 19:09:04,459 [Thread Pool Worker] DEBUG Microsoft.Rest.Tracing.Log4Net.Log4NetTracingInterceptor [(null)] - invocationId: 1
response: StatusCode: 200, ReasonPhrase: 'OK', Version: 1.1, Content: System.Net.Http.StreamContent, Headers:
{
  Cache-Control: no-cache
  Pragma: no-cache
  request-id: 591cb14f-e5c2-4a85-977d-01d1f6431ddc
  elapsed-time: 72
  OData-Version: 4.0
  Preference-Applied: odata.include-annotations=&quot;*&quot;
  Strict-Transport-Security: max-age=15724800; includeSubDomains
  Date: Tue, 26 May 2020 10:09:04 GMT
  Content-Type: application/json; odata.metadata=none
  Expires: -1
  Content-Length: 376
}
</code></pre><h4 id="メリットデメリット-1">メリット、デメリット</h4>
<p>Log4Netを利用しているアプリの場合、2行だけを追加することで実装が完了するのがお手軽な点です。</p>
<p>難点としては、Rest Client全てにたいしてトレース処理が入ってしまうので、Azure Cognitive Search以外にもRestクライアントを利用しているものが存在した場合、ログの量が増えてしまいます。また、検索以外の処理でもトレースされてしまうのもデメリットになります。</p>
<p>Log4Net以外のログ機構を使用している場合は、自分で<code>IServiceClientTracingInterceptor</code>を実装する必要も出てきます(<a href="https://stackoverflow.com/questions/46943669/microsoft-rest-serviceclienttracing-how-to-output-tracing-results-to-console-o">参考:StackOverflow</a>)。</p>
<h3 id="3-azure-application-insightsを活用する">3. Azure Application Insightsを活用する</h3>
<p>ここから紹介する3と4については、ログの出力先がAzure上になります。</p>
<p><a href="https://docs.microsoft.com/ja-jp/azure/azure-monitor/app/app-insights-overview">AzureのApplication Insights</a>を利用する方法です。
Azure?.NET?のアプリケーションパフォーマンスモニタリングのサービスです。</p>
<p>Application Insightsを自分のアプリケーションに設定することで、アプリケーションのパフォーマンス監視に関する情報がAzure上のApplication Insightsリソースに送信されるようになります。</p>
<p>ただ、Application Insightsのデフォルトの機能では、URL程度の情報だけが送信されます(<a href="https://blog.shibayan.jp/entry/20190405/1554459340">参考:しばやんさんのブログ</a>)</p>
<p>こちらも拡張機能が用意されており、ITelemetryInitializerのインターフェースを実装したクラスを用意することで、独自の情報をApplication Insightsに出力することが可能となります。詳細については<a href="https://blog.shibayan.jp/entry/20190405/1554459340">しばやんさんのブログ</a>を参考にしてもらうのが良いかと。</p>
<p>Httpリクエストを出力する実装例は次のとおりです。ただ、ちょっとうまく行かないパターンがあったので、コメントアウトとして残してあったりします(なんでだろう?)</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C#" data-lang="C#"><span style="color:#66d9ef">using</span> System.Collections.Generic;
<span style="color:#66d9ef">using</span> System.Net.Http;
<span style="color:#66d9ef">using</span> System.Net.Http.Headers;
<span style="color:#66d9ef">using</span> Microsoft.ApplicationInsights.Channel;
<span style="color:#66d9ef">using</span> Microsoft.ApplicationInsights.DataContracts;
<span style="color:#66d9ef">using</span> Microsoft.ApplicationInsights.Extensibility;

<span style="color:#66d9ef">namespace</span> AzureSearchWebSample.ApplicationInsights
{
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">HttpRequestInitializer</span> : ITelemetryInitializer
    {
        <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> Initialize(ITelemetry telemetry)
        {

            <span style="color:#66d9ef">if</span> (!(telemetry <span style="color:#66d9ef">is</span> DependencyTelemetry dependency))
            {
                <span style="color:#66d9ef">return</span>;
            }

            HttpRequestMessage requestMessage = <span style="color:#66d9ef">null</span>;
            HttpRequestHeaders requestHeaders;
            <span style="color:#66d9ef">if</span> (dependency.TryGetOperationDetail(<span style="color:#e6db74">&#34;HttpRequest&#34;</span>, <span style="color:#66d9ef">out</span> <span style="color:#66d9ef">var</span> details) &amp;&amp;
                details <span style="color:#66d9ef">is</span> HttpRequestMessage request)
            {
                requestMessage = request;
                requestHeaders = request.Headers;            
                <span style="color:#66d9ef">if</span> (requestMessage.Method == HttpMethod.Post)
                {
                    <span style="color:#66d9ef">string</span> contentBody = requestMessage.Content.ReadAsStringAsync().GetAwaiter().GetResult();
                    dependency.Properties.Add(<span style="color:#e6db74">&#34;RequestBody&#34;</span>,contentBody);
                }
            }
            <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (dependency.TryGetOperationDetail(<span style="color:#e6db74">&#34;HttpRequestHeaders&#34;</span>, <span style="color:#66d9ef">out</span> details) &amp;&amp;
                     details <span style="color:#66d9ef">is</span> HttpRequestHeaders headers)
            {
                requestHeaders = headers;
            }
            <span style="color:#66d9ef">else</span>
            {
                <span style="color:#66d9ef">return</span>;
            }

            <span style="color:#66d9ef">foreach</span> (KeyValuePair&lt;<span style="color:#66d9ef">string</span>,IEnumerable&lt;<span style="color:#66d9ef">string</span>&gt;&gt; header <span style="color:#66d9ef">in</span> requestHeaders)
            {
                <span style="color:#66d9ef">foreach</span> (<span style="color:#66d9ef">string</span> <span style="color:#66d9ef">value</span> <span style="color:#66d9ef">in</span> header.Value)
                {
                    dependency.Properties.Add(header.Key, <span style="color:#66d9ef">value</span>);
                }
            }
            <span style="color:#75715e">//この実装の場合は出力されなかった。なぜ?
</span><span style="color:#75715e"></span>            <span style="color:#75715e">// if (requestMessage != null &amp;&amp; requestMessage.Method == HttpMethod.Post)
</span><span style="color:#75715e"></span>            <span style="color:#75715e">// {
</span><span style="color:#75715e"></span>            <span style="color:#75715e">//     string contentBody = requestMessage.Content.ReadAsStringAsync().GetAwaiter().GetResult();
</span><span style="color:#75715e"></span>            <span style="color:#75715e">//     dependency.Properties.Add(&#34;RequestBody&#34;,contentBody);
</span><span style="color:#75715e"></span>            <span style="color:#75715e">// }
</span><span style="color:#75715e"></span>        }
    }
}
</code></pre></div><h4 id="メリットデメリット-2">メリット、デメリット</h4>
<p>すでにApplication Insightsを利用している場合はついでに情報が出力されるので便利です。かつ、常にリクエストログを見れるようにしておく場合はとても便利だと思います。</p>
<p>Application Insightsを利用していない場合は、そこから導入しなければならなくなるので、手間が増えるかもしれないです。</p>
<h3 id="4-azure-cognitive-searchのコンソールにある診断情報の機能を利用する">4. Azure Cognitive Searchのコンソールにある診断情報の機能を利用する。</h3>
<p>最後は<a href="https://docs.microsoft.com/ja-jp/azure/search/search-monitor-logs">Azure Cognitive Searchの診断ログ</a>を有効にする方法です。
ここまで説明してきた方法の中で、一番お手軽な方法です。。。</p>
<p>これまでは、リクエストボディを出力する方法を考えていましたが、Azure Cognitive Search側の診断ログを有効にすると、リクエストボディで送信したものが、<a href="https://docs.microsoft.com/ja-jp/azure/search/search-monitor-logs#properties-schema">Azure Cognitive Search側で、クエリパラーメータとして、診断ログに出力</a>されます(診断ログの<code>Query_s</code>)。</p>
<p>あとは、<a href="https://docs.microsoft.com/ja-jp/azure/search/search-monitor-logs#query-log-information">Azureのコンソール</a>で当該時間のログを見ればよいだけです。以下は出力されたログの一部です。Description_sにはURLのパスが記載されています。</p>
<p>診断ログ例(一部)</p>
<pre><code>Description_s      POST /indexes('multi-field-test')/docs/search.post.search
Query_s            ?api-version=2019-05-06&amp;searchMode=Any&amp;search=azure&amp;queryType=Simple&amp;$count=false
</code></pre><h4 id="メリットデメリット-3">メリット、デメリット</h4>
<p>アプリケーション側に手を入れる必要がなのでお手軽です。
一度設定しておけばコンソール側でログをいつでも見れるので便利です。</p>
<p>リクエスト量が多くなってしまうと、ログの量も多くなり、費用がかさむ恐れがあります。また、複数の人が触る環境の場合は自分で送信したリクエストがどれだったのか?といった状況に陥る可能性はあります。</p>
<h2 id="その他は">その他は?</h2>
<p>Azureに対してではないですが、昔似たようなことをやるときにやっていた方法として、ローカルにプロキシサーバーを起動し、そのプロキシサーバー経由でアプリケーションから、Azureに接続することで、リクエストを保存する方法もあります。
ざんねんながら、未調査ですがアプリなどにはそれほど手を入れる必要はないかと思います。</p>
<h2 id="まとめ">まとめ</h2>
<p>ちょっと送信リクエストの内容が見てみたいという話でしたが、いろいろな手段が存在しました。
自分の状況、環境に合わせて手段を選択肢てみるのがいいかと思います。
まずは、簡単な診断ログあたりからでしょうか?</p>
</content:encoded>
    </item>
    
    <item>
      <title>Microsoft Build(2020)のAzure Cognirive Searchのセッションを見たのでメモ</title>
      <link>https://blog.johtani.info/blog/2020/05/22/watching-azure-cognirive-search-session-at-ms-build/</link>
      <pubDate>Fri, 22 May 2020 12:10:41 +0900</pubDate>
      
      <guid>https://blog.johtani.info/blog/2020/05/22/watching-azure-cognirive-search-session-at-ms-build/</guid>
      <description>Mircosoft Buildというイベントが今週ありました(MSの方やお客さんに教えてもらった)。 そこで、Azure Cognitive Searchのセッション(MyBuil</description>
      <content:encoded><p><a href="https://mybuild.microsoft.com/">Mircosoft Buildというイベント</a>が今週ありました(MSの方やお客さんに教えてもらった)。</p>
<p>そこで、Azure Cognitive Searchのセッション(<a href="https://mybuild.microsoft.com/sessions/391f3d09-50b4-476a-9acf-4fd2d4927a9e">MyBuild - Cognitive Search： The pocket-knife for knowledge mining</a>)があったので、見てみました。
内容がどんなものかをメモっておきます。
最初はCognitive Searchがどんなものよという説明でした。</p>
<h2 id="ビルトインスキルの拡充の話">ビルトインスキルの拡充の話</h2>
<p>データソースからデータを取り出し、エンリッチし、検索エンジンに保存するという、<a href="https://docs.microsoft.com/ja-jp/azure/search/cognitive-search-concept-intro">パイプラインが組めるようになっています</a>。</p>
<p>このパイプラインで利用できる処理のことがスキルと呼ばれています。ここで利用できる<a href="https://docs.microsoft.com/ja-jp/azure/search/cognitive-search-predefined-skills">ビルトインスキル</a>が拡充されますよという話でした。ちょっとだけ抜き出すと以下のとおりです。</p>
<ul>
<li>Azure Machine Learning</li>
<li><a href="https://docs.microsoft.com/ja-jp/azure/search/cognitive-search-skill-text-translation">Text translation</a></li>
<li>Brand detection</li>
<li>Object detection</li>
</ul>
<p><a href="https://docs.microsoft.com/ja-jp/azure/search/cognitive-search-predefined-skills">スキルのリファレンス</a>には載ってるものと載ってないものがあるので、今後追加されてくのかな?
Brand detectionがどんなものなんだろう?ってのがちょっと気になりました。どっかにデモとかあるかなぁ?</p>
<h2 id="スキルセットのための新機能--debug-sessionのデモ">スキルセットのための新機能 : Debug Sessionのデモ</h2>
<p>上記のスキルを組み合わせてパイプラインを組んで、データソースから取り出したデータをエンリッチしてから、検索エンジンに入れる処理をかけるのですが、その処理のデバッグ用に新しいGUIの機能が追加されてますよという紹介とデモでした。</p>
<ul>
<li><a href="https://docs.microsoft.com/en-us/azure/search/cognitive-search-tutorial-debug-sessions#start-your-debug-session">Tutorial： Use Debug sessions to diagnose, fix, and commit changes to your skillset - Azure Cognitive Search | Microsoft Docs</a></li>
</ul>
<h2 id="manage-identityの話">Manage Identityの話</h2>
<p>Azure Cognitive Searchにデータを登録するパイプランの最初の段階で、各種データソースにアクセスが必要です。
このアクセス時にコネクションの設定にアカウントキーなども含めてましたが、これをコネクション設定ではなく、専用の管理機能が用意されましたよという話でした。</p>
<ul>
<li><a href="https://docs.microsoft.com/en-us/azure/search/search-howto-managed-identities-data-sources">Set up a connection to a data source using a managed identity (preview) - Azure Cognitive Search | Microsoft Docs</a></li>
</ul>
<h2 id="qa">QA</h2>
<ul>
<li>Similarityとかの話
<ul>
<li><a href="https://docs.microsoft.com/ja-jp/azure/search/index-similarity-and-scoring#similarity-ranking-algorithms">BM25になってるよ</a>とか</li>
</ul>
</li>
<li>SDKの話とか</li>
<li>ほかにRelevancyの話
<ul>
<li>Analyzerをデフォルトのままじゃなくてちゃんと考えて使いましょう(例:<a href="https://docs.microsoft.com/ja-jp/azure/search/index-add-language-analyzers#language-analyzer-list">各言語用のAnalyzerがいっぱいあるよ</a>とか)</li>
</ul>
</li>
</ul>
<p>こんな感じでした。</p>
</content:encoded>
    </item>
    
    <item>
      <title>Visual Studio Codeのプラグインを作ってみた(Azure Search Analyze Client)</title>
      <link>https://blog.johtani.info/blog/2020/03/19/azure-search-analyze-plugin/</link>
      <pubDate>Thu, 19 Mar 2020 10:50:15 +0900</pubDate>
      
      <guid>https://blog.johtani.info/blog/2020/03/19/azure-search-analyze-plugin/</guid>
      <description>動機 Azure Cognitive Searchを検索エンジンに使っているお客さんを手伝っています。 そこで、検索の基本的な話をさせていただきました(もともとJJUGナイ</description>
      <content:encoded><h2 id="動機">動機</h2>
<p><a href="https://docs.microsoft.com/ja-jp/azure/search/search-what-is-azure-search">Azure Cognitive Search</a>を検索エンジンに使っているお客さんを手伝っています。
そこで、<a href="https://noti.st/johtani/halVGM">検索の基本的な話</a>をさせていただきました(もともとJJUGナイトセミナーでしゃべる予定だったスライドがベース)。</p>
<p>で、Elasticsearchなどの転置インデックスを利用している検索エンジンで検索の基本的な動作がどうなっているかを理解するのに、
個人的には一番重要だと思っているのがAnalysis(Analyze)の機能です。
転置インデックスの単語の切り出し方がどうなっているかによって、望んだ単語でうまく検索できているかいないかなどがわかります。</p>
<p><a href="https://docs.microsoft.com/ja-jp/rest/api/searchservice/test-analyzer">Azure Cognitive SearchもAnalyze Text</a>というAPIを提供してくれています(内部的にはElasticsearchだし)。
APIはあるのですが、返ってくる結果はJSONです。また、他のAnalyzerの設定との違いなどをみたくなったりもします。
やはり、普段使っているツールなどで簡単にどういう単語が出てくるかがわかるとうれしんじゃないかなぁ?と。</p>
<p>ということで、最初はPythonでちょっとAPI呼び出して、カンマ区切りで出力するものを作ってみたのですが、GUIとかあると便利かなぁという話になりました。
最近、ブログ書いたりするのにVisual Studio Codeを使い始めているので、これなら使いやすいかなと。
ということで、Visual Studio Codeの拡張機能(プラグイン?)としてインストールできる<a href="https://github.com/johtani/azure-search-analyze-client">ツール</a>を作ってみました。
Azure Cognitive Searchを使っている人向けなので、ニッチなツールですが。。。</p>
<h3 id="余談">余談</h3>
<p>Elastic Stack(Elasticsearch)向けにはKibanaのプラグインでAnalyze APIを可視化するツールを作ってます。
<a href="https://github.com/johtani/analyze-api-ui-plugin">analyze-api-ui-plugin</a>です。Elastic Stack、特にKibanaを必ず利用する方はこちらを使うと便利かもです。</p>
<h2 id="概要と機能">概要と機能</h2>
<ul>
<li><a href="https://github.com/johtani/azure-search-analyze-client">GitHub リポジトリ</a></li>
<li><a href="https://marketplace.visualstudio.com/items?itemName=johtani.azure-search-analyze-client&amp;ssr=false#overview">Visual Studio Marketplaceのページ</a></li>
</ul>
<p>Marketplaceに公開しているので、<code>johtani</code>や<code>Azure Search Analyze Client</code>などで検索してもらえれば出てきてインストールができます。</p>
<p>機能としては、以下の2つです。</p>
<ol>
<li>テンプレートから入力値設定用のドキュメントを作成(<code>Untitled-1</code>というドキュメントをエディタに新しく開く)</li>
<li>Azure Cognitive SearchのAnalyze Text APIを呼び出して、結果をHTMLのテーブル形式で表示</li>
</ol>
<h3 id="入力値設定用のドキュメント作成">入力値設定用のドキュメント作成</h3>
<p>APIの呼び出しに必要な情報を記入してもらうのに、いくつか案を考えました。</p>
<ul>
<li>プラグインの設定に記入してもらう</li>
<li>環境変数とかを読み出す</li>
<li>テキストとして保存したファイルを使う</li>
</ul>
<p>設定や環境変数だと、異なる環境に接続したりするときに、わざわざ設定し直すのがめんどくさいかもと。
で、愛用していた<a href="https://marketplace.visualstudio.com/items?itemName=humao.rest-client">REST API Client</a>を真似するのが良いかもという結論になり、<code>.analyze</code>という拡張子のファイルから必要な項目を読み出して、APIを呼び出す形にしてあります。</p>
<p><code>Command Palette</code>(左下の歯車マークもしくは、メニューのViewから開ける)から<code>Azure Search Analyze Client: Create Azure Search Analyze Request</code>というコマンドを選びます。</p>

<link rel="stylesheet" href="/css/hugo-easy-gallery.css" />
<div class="box" style="max-width:600">
  <figure  itemprop="associatedMedia" itemscope itemtype="http://schema.org/ImageObject">
    <div class="img">
      <img itemprop="thumbnail" src="/images/entries/20200319/command_palette.png" />
    </div>
    <a href="/images/entries/20200319/command_palette.png" itemprop="contentUrl"></a>
  </figure>
</div>

<p>すると、以下のようなファイルがエディタに開きます。</p>


<div class="box" style="max-width:600">
  <figure  itemprop="associatedMedia" itemscope itemtype="http://schema.org/ImageObject">
    <div class="img">
      <img itemprop="thumbnail" src="/images/entries/20200319/input_template.png" />
    </div>
    <a href="/images/entries/20200319/input_template.png" itemprop="contentUrl"></a>
  </figure>
</div>

<p>これらの項目をまずは埋めていきます。
それぞれの値がどういったものかは<a href="https://github.com/johtani/azure-search-analyze-client">GitHubのREADME</a>を御覧ください。</p>
<p>入力値エラー(存在チェックしかしていない)がある場合は、ダイアログが表示されます。</p>
<h3 id="結果表示">結果表示</h3>
<p>値を入力したら、設定値と<code>###</code>の間に表示されている<code>Analyze text with analyzers</code>というグレーの文字をクリックします。すると、APIにリクエストを送信し、結果が返ってきて、別のパネルとして表示されます。</p>


<div class="box" style="max-width:600">
  <figure  itemprop="associatedMedia" itemscope itemtype="http://schema.org/ImageObject">
    <div class="img">
      <img itemprop="thumbnail" src="/images/entries/20200319/response.png" />
    </div>
    <a href="/images/entries/20200319/response.png" itemprop="contentUrl"></a>
  </figure>
</div>

<p>複数のAnalyzerを入力値に設定すると、それぞれがどのような区切り方をするかがわかります。
文字の下にある<code>[0:2]</code>は、その単語がもとの文章の何文字目から何文字目までに出現しているかというオフセットの表示になります。</p>
<p>もし、Analyzer名の設定ミスなどで指定されたAnalyzerがない場合は、結果画面にエラーが表示されるようにしています。</p>
<p>以上が簡単な機能の説明です。
簡単なと言いつつ、これだけしか機能がありませんが。</p>
<h2 id="visual-studio-codeのプラグインの作り方">Visual Studio Codeのプラグインの作り方</h2>
<p>プラグイン自体の作り方に関しては<a href="https://code.visualstudio.com/api/get-started/your-first-extension">Visual Studio CodeのGetting Started</a>がわかりやすかったです。
APIや機能が豊富なので、最初はちょっと戸惑いましたが、<a href="https://github.com/microsoft/vscode-extension-samples">サンプルもGitHubで多数公開</a>されています。</p>
<p>あとは、<a href="https://marketplace.visualstudio.com/items?itemName=humao.rest-client">REST API Client</a>を参考にさせていただきました。</p>
<p>Getting Startedを一通り読むことで、なんとなくプラグインの作成からMarketplaceへのリリースまでが完了できました。
(TypeScriptに慣れていないのがあるので、プログラミング自体は手間取りましたが。。。)</p>
<h2 id="今後の対応">今後の対応?</h2>
<p>いまのところ、こんなところを考えていますが、こんな機能がほしい、バグが有るなどあれば、GitHubにIssueを上げていただければと(使う人すくないだろうけど)。</p>
<ul>
<li>いろいろなエラーに関する対応</li>
<li>Readmeに画像をアップ</li>
<li>アイコン作成?</li>
<li>自動補完機能?</li>
</ul>
<h2 id="まとめ">まとめ</h2>
<p>Visual Studio Codeの拡張機能を作ってみました。
Yeomanによるプロジェクトテンプレートが用意されているので、とりあえず、Hello worldを作るのは簡単でした。
試行錯誤しつつTypeScriptを書いたので、TypeScriptっぽくないところなどもあるかもですが、誰かの役に立つツールになってくれれば良いなぁと。</p>
</content:encoded>
    </item>
    
    <item>
      <title>Azure Cognitive Searchでインデックスを作って検索</title>
      <link>https://blog.johtani.info/blog/2020/02/19/research-azure-cognitive-search/</link>
      <pubDate>Wed, 19 Feb 2020 11:48:01 +0900</pubDate>
      
      <guid>https://blog.johtani.info/blog/2020/02/19/research-azure-cognitive-search/</guid>
      <description>お手伝いしているお客さんがAzure Cognitive Searchを利用してます。 検索周り=Azure Cognitive Searchに関する手伝いをする形で入っており、 いく</description>
      <content:encoded><p>お手伝いしているお客さんがAzure Cognitive Searchを利用してます。
検索周り=Azure Cognitive Searchに関する手伝いをする形で入っており、
いくつか触った感触をブログにまとめてみようかと(お客さんからはOKいただいてます)。</p>
<h2 id="azure-cognitive-searchとは">Azure Cognitive Searchとは？</h2>
<ul>
<li><a href="https://azure.microsoft.com/ja-jp/services/search/">公式サイト</a></li>
</ul>
<p>「AIを活用した」クラウド検索サービスと紹介されています。</p>
<p>昔はAzure Searchと呼ばれていましたが、ここ最近はAzure Cognitive Searchと呼ばれているみたいです(<a href="https://techcommunity.microsoft.com/t5/azure-ai/knowledge-mining-with-azure-cognitive-search/ba-p/1020774">Microsoft Igniteで発表された話がまとまっているページもあります</a>)。
もともと、検索エンジンのSaaSサービス(キーワード検索、あいまい検索、オートサジェスト、スコアリングなどの機能)として作られていた部分に、データの登録パイプラインにCognitive Serviceの便利な機能を簡単に使えるようにしたものというイメージでしょうか。</p>
<p>バックエンドはElasticsearchのはずです。変わってなければ。
昔、Elastic社主催のユーザーカンファレンスで<a href="https://www.elastic.co/jp/elasticon/2015/sf/powering-real-time-search-at-microsoft">MSの方が公演された資料</a>が公開されていたりします。
ちなみに質問が多いのでしょうか、<a href="https://docs.microsoft.com/ja-jp/azure/search/search-faq-frequently-asked-questions#what-is-the-difference-between-azure-cognitive-search-and-elasticsearch">Azure Cognitive SearchとElasticsearchの違いはなんですか?</a>というページがよくある質問のページに用意されていました。参考までに。</p>
<p>今回はちょっとしたインデックスをつくって検索する部分を紹介してみようかと思います
(Cognitiveなところは機会があればまた)。</p>
<p><a href="https://docs.microsoft.com/ja-jp/azure/search/search-create-service-portal">普通の使い方</a>については、Azureのドキュメントなどを読んで頂く形にします。
ポータルと呼ばれるブラウザ上でAzureのサービスを触ることができる画面が用意されています。
ここで、簡単な操作(インデックス作成、フィールドの追加)</p>
<p>APIを使ってインデックス(特にAnalyzer)の設定をしたり、データをいれて、クエリしてみるというところをサクッと紹介しようと思います。</p>
<h2 id="インデックスの作り方">インデックスの作り方</h2>
<p><a href="https://docs.microsoft.com/ja-jp/azure/search/search-what-is-an-index#recommended-workflow">インデックス作成に関するドキュメント</a>も用意されています。最初はポータル(GUI)でインデックスを作成する方法が紹介されています。
ですが、今回はn-gram(n=2)のAnalyzerを利用したかったので、GUIではなくAPIでインデックスを作成しました。
<a href="https://docs.microsoft.com/ja-jp/azure/search/index-add-custom-analyzers">カスタムアナライザー</a>を利用する場合、REST APIを利用しなければ行けないということになっています。
n-gramのAnalyzerを含むインデックス生成のREST APIは以下のとおりです。こちらを実行することで、インデックスが作成されます(JSONの記述ミスなどがある場合はエラーが返ってきます)。</p>
<pre><code>@host = &lt;サーチのサービス名&gt;.search.windows.net
@api-key = &lt;APIキー&gt;

###

POST https://{{host}}/indexes/?api-version=2019-05-06
Content-Type: application/json
api-key: {{api-key}}

{
    &quot;name&quot;:&quot;ngram-test&quot;,
    &quot;fields&quot;:[
       {
          &quot;name&quot;:&quot;id&quot;,
          &quot;type&quot;:&quot;Edm.String&quot;,
          &quot;key&quot;:true,
          &quot;searchable&quot;:false
       },
       {
          &quot;name&quot;:&quot;ngram&quot;,
          &quot;type&quot;:&quot;Edm.String&quot;,
          &quot;searchable&quot;:true,
          &quot;analyzer&quot;:&quot;bi_gram_analyzer&quot;
       }
    ],
    &quot;analyzers&quot;:[
      {
         &quot;name&quot;:&quot;bi_gram_analyzer&quot;,
         &quot;@odata.type&quot;:&quot;#Microsoft.Azure.Search.CustomAnalyzer&quot;,
         &quot;tokenizer&quot;:&quot;bi_gram_tokenizer&quot;,
         &quot;tokenFilters&quot;:[
            &quot;lowercase&quot;
         ]
      }
    ],
    &quot;tokenizers&quot;:[
       {
          &quot;name&quot;:&quot;bi_gram_tokenizer&quot;,
          &quot;@odata.type&quot;:&quot;#Microsoft.Azure.Search.NGramTokenizer&quot;,
          &quot;minGram&quot;:2,
          &quot;maxGram&quot;:2
       }
    ]
 }
</code></pre><p>なんだかどこかで見たことのある記述のようなそうでないような。。。
Analyzerは、charFilters(0以上複数可)、tokenizer(1つ必須)、tokenFilters(0以上複数可)から構成されます。
フィールドで指定するのはAnalyzerなので、まずanalyzersに<code>CustomAnalyzer</code>の設定を行います。
名前は<code>bi_gram_analyzer</code>にしました(好きに付けてください)。
<code>tokenizer</code>にはこのあと設定するtokenizerの名前を設定します。ここでは、<code>bi_gram_tokenizer</code>という名前にしています。
また、大文字小文字を気にせずに検索したいため、<code>tokenFilters</code>に<code>lowercase</code>を指定しています。こちらは<a href="https://docs.microsoft.com/ja-jp/azure/search/index-add-custom-analyzers#token-filters-reference">すでに定義済み</a>のため、定義済みの名前で呼び出すだけで使用できます。</p>
<p>次が、<code>bi_gram_tokenizer</code>の設定です。
n=2としたいので、<code>tokenizers</code>配下にTokenizerの設定をします。
<code>@odata.type&quot;:&quot;#Microsoft.Azure.Search.NGramTokenizer</code>がTokenizerの名前です(ちょっと独特な名前ですね)。
Tokenizerごとにオプションがあり、NGramTokenizerの場合は、<code>minGram</code>、<code>maxGram</code>がオプションに相当します。
今回は2文字ごとにトークンを出力したいので、minとmaxをそれぞれ2としています。</p>
<p>これで、あとは、フィールドで<code>analyzer</code>という設定に<code>bi_gram_analyzer</code>を指定すればそのフィールドは<code>bi_gram_analyzer</code>を使用してアナライズされるようになります(このへんはElasticsearchといっしょですね)。
フィールドは文字列を扱うので、<code>Edm.String</code>というタイプにしてあります。データ型については、<a href="https://docs.microsoft.com/ja-jp/azure/search/search-what-is-an-index#fields-collection-and-field-attributes">フィールドコレクションとフィールド属性</a>というドキュメントを参考に設定しましょう。</p>
<h3 id="閑話休題---rest-client-exstension-for-visual-studio-code">閑話休題 - REST Client Exstension for Visual Studio Code</h3>
<p>なお、今回のサンプルは<a href="https://github.com/Huachao/vscode-restclient">REST Clinet Extention for Visual Studio Code</a>を利用する想定の記述になっています。</p>
<p>Visual Studio Codeで<code>.rest</code>もしくは<code>.http</code>というファイルに以下のAPIを記述すると、<code>Send Request</code>というリンクがURLの上部に出てくるような拡張機能です。REST APIにリクエストするときに便利なツールになっています。
変数も使えるので、APIのキーやURLの一部をこのように共通化して、他の環境でも使いやすくできるのは素晴らしいなと。</p>

<link rel="stylesheet" href="/css/hugo-easy-gallery.css" />
<div class="box" style="max-width:600">
  <figure  itemprop="associatedMedia" itemscope itemtype="http://schema.org/ImageObject">
    <div class="img">
      <img itemprop="thumbnail" src="/images/entries/20200220/rest_client_extension.png" />
    </div>
    <a href="/images/entries/20200220/rest_client_extension.png" itemprop="contentUrl"></a>
  </figure>
</div>

<h2 id="アナライザーの挙動の確認">アナライザーの挙動の確認</h2>
<p>設定したAnalyzerがきちんと機能しているかというのを確認する必要があります。
入力した文字列がきちんと想定している単語として切り出されて、転置インデックスの見出し語に使われるかというのが重要になるからです。</p>
<p>Azure Cognitive Searchでもアナライザーのテスト用APIが用意されています。
<a href="https://docs.microsoft.com/ja-jp/azure/search/index-add-custom-analyzers#test-custom-analyzers">使い方はこちら</a>。
<a href="https://docs.microsoft.com/ja-jp/rest/api/searchservice/test-analyzer">APIの仕様のページもありました</a>。
「<code>アナライザーの挙動はどんな感じ？</code>」という文字列が、作成したインデックスの定義したアナライザー<code>bi_gram_analyzer</code>により、
どのように分割されるかを確認するAPIの呼び出しは以下のとおりです。</p>
<pre><code>###
POST https://{{host}}/indexes/ngram-test/analyze?api-version=2019-05-06
Content-Type: application/json
api-key: {{api-key}}

{
   &quot;analyzer&quot;:&quot;bi_gram_analyzer&quot;,
   &quot;text&quot;: &quot;アナライザーの挙動はどんな感じ？&quot;
}

</code></pre><p>レスポンスはこんな形です。ヘッダ部分は省略してあります。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-json" data-lang="json">{
  <span style="color:#f92672">&#34;@odata.context&#34;</span>: <span style="color:#e6db74">&#34;https://{{host}}.search.windows.net/$metadata#Microsoft.Azure.Search.V2019_05_06.AnalyzeResult&#34;</span>,
  <span style="color:#f92672">&#34;tokens&#34;</span>: [
    {
      <span style="color:#f92672">&#34;token&#34;</span>: <span style="color:#e6db74">&#34;アナ&#34;</span>,
      <span style="color:#f92672">&#34;startOffset&#34;</span>: <span style="color:#ae81ff">0</span>,
      <span style="color:#f92672">&#34;endOffset&#34;</span>: <span style="color:#ae81ff">2</span>,
      <span style="color:#f92672">&#34;position&#34;</span>: <span style="color:#ae81ff">0</span>
    },
    {
      <span style="color:#f92672">&#34;token&#34;</span>: <span style="color:#e6db74">&#34;ナラ&#34;</span>,
      <span style="color:#f92672">&#34;startOffset&#34;</span>: <span style="color:#ae81ff">1</span>,
      <span style="color:#f92672">&#34;endOffset&#34;</span>: <span style="color:#ae81ff">3</span>,
      <span style="color:#f92672">&#34;position&#34;</span>: <span style="color:#ae81ff">1</span>
    },
    {
      <span style="color:#f92672">&#34;token&#34;</span>: <span style="color:#e6db74">&#34;ライ&#34;</span>,
      <span style="color:#f92672">&#34;startOffset&#34;</span>: <span style="color:#ae81ff">2</span>,
      <span style="color:#f92672">&#34;endOffset&#34;</span>: <span style="color:#ae81ff">4</span>,
      <span style="color:#f92672">&#34;position&#34;</span>: <span style="color:#ae81ff">2</span>
    },
    {
      <span style="color:#f92672">&#34;token&#34;</span>: <span style="color:#e6db74">&#34;イザ&#34;</span>,
      <span style="color:#f92672">&#34;startOffset&#34;</span>: <span style="color:#ae81ff">3</span>,
      <span style="color:#f92672">&#34;endOffset&#34;</span>: <span style="color:#ae81ff">5</span>,
      <span style="color:#f92672">&#34;position&#34;</span>: <span style="color:#ae81ff">3</span>
    },
    {
      <span style="color:#f92672">&#34;token&#34;</span>: <span style="color:#e6db74">&#34;ザー&#34;</span>,
      <span style="color:#f92672">&#34;startOffset&#34;</span>: <span style="color:#ae81ff">4</span>,
      <span style="color:#f92672">&#34;endOffset&#34;</span>: <span style="color:#ae81ff">6</span>,
      <span style="color:#f92672">&#34;position&#34;</span>: <span style="color:#ae81ff">4</span>
    },
    {
      <span style="color:#f92672">&#34;token&#34;</span>: <span style="color:#e6db74">&#34;ーの&#34;</span>,
      <span style="color:#f92672">&#34;startOffset&#34;</span>: <span style="color:#ae81ff">5</span>,
      <span style="color:#f92672">&#34;endOffset&#34;</span>: <span style="color:#ae81ff">7</span>,
      <span style="color:#f92672">&#34;position&#34;</span>: <span style="color:#ae81ff">5</span>
    },
    {
      <span style="color:#f92672">&#34;token&#34;</span>: <span style="color:#e6db74">&#34;の挙&#34;</span>,
      <span style="color:#f92672">&#34;startOffset&#34;</span>: <span style="color:#ae81ff">6</span>,
      <span style="color:#f92672">&#34;endOffset&#34;</span>: <span style="color:#ae81ff">8</span>,
      <span style="color:#f92672">&#34;position&#34;</span>: <span style="color:#ae81ff">6</span>
    },
    {
      <span style="color:#f92672">&#34;token&#34;</span>: <span style="color:#e6db74">&#34;挙動&#34;</span>,
      <span style="color:#f92672">&#34;startOffset&#34;</span>: <span style="color:#ae81ff">7</span>,
      <span style="color:#f92672">&#34;endOffset&#34;</span>: <span style="color:#ae81ff">9</span>,
      <span style="color:#f92672">&#34;position&#34;</span>: <span style="color:#ae81ff">7</span>
    },
    {
      <span style="color:#f92672">&#34;token&#34;</span>: <span style="color:#e6db74">&#34;動は&#34;</span>,
      <span style="color:#f92672">&#34;startOffset&#34;</span>: <span style="color:#ae81ff">8</span>,
      <span style="color:#f92672">&#34;endOffset&#34;</span>: <span style="color:#ae81ff">10</span>,
      <span style="color:#f92672">&#34;position&#34;</span>: <span style="color:#ae81ff">8</span>
    },
    {
      <span style="color:#f92672">&#34;token&#34;</span>: <span style="color:#e6db74">&#34;はど&#34;</span>,
      <span style="color:#f92672">&#34;startOffset&#34;</span>: <span style="color:#ae81ff">9</span>,
      <span style="color:#f92672">&#34;endOffset&#34;</span>: <span style="color:#ae81ff">11</span>,
      <span style="color:#f92672">&#34;position&#34;</span>: <span style="color:#ae81ff">9</span>
    },
    {
      <span style="color:#f92672">&#34;token&#34;</span>: <span style="color:#e6db74">&#34;どん&#34;</span>,
      <span style="color:#f92672">&#34;startOffset&#34;</span>: <span style="color:#ae81ff">10</span>,
      <span style="color:#f92672">&#34;endOffset&#34;</span>: <span style="color:#ae81ff">12</span>,
      <span style="color:#f92672">&#34;position&#34;</span>: <span style="color:#ae81ff">10</span>
    },
    {
      <span style="color:#f92672">&#34;token&#34;</span>: <span style="color:#e6db74">&#34;んな&#34;</span>,
      <span style="color:#f92672">&#34;startOffset&#34;</span>: <span style="color:#ae81ff">11</span>,
      <span style="color:#f92672">&#34;endOffset&#34;</span>: <span style="color:#ae81ff">13</span>,
      <span style="color:#f92672">&#34;position&#34;</span>: <span style="color:#ae81ff">11</span>
    },
    {
      <span style="color:#f92672">&#34;token&#34;</span>: <span style="color:#e6db74">&#34;な感&#34;</span>,
      <span style="color:#f92672">&#34;startOffset&#34;</span>: <span style="color:#ae81ff">12</span>,
      <span style="color:#f92672">&#34;endOffset&#34;</span>: <span style="color:#ae81ff">14</span>,
      <span style="color:#f92672">&#34;position&#34;</span>: <span style="color:#ae81ff">12</span>
    },
    {
      <span style="color:#f92672">&#34;token&#34;</span>: <span style="color:#e6db74">&#34;感じ&#34;</span>,
      <span style="color:#f92672">&#34;startOffset&#34;</span>: <span style="color:#ae81ff">13</span>,
      <span style="color:#f92672">&#34;endOffset&#34;</span>: <span style="color:#ae81ff">15</span>,
      <span style="color:#f92672">&#34;position&#34;</span>: <span style="color:#ae81ff">13</span>
    },
    {
      <span style="color:#f92672">&#34;token&#34;</span>: <span style="color:#e6db74">&#34;じ？&#34;</span>,
      <span style="color:#f92672">&#34;startOffset&#34;</span>: <span style="color:#ae81ff">14</span>,
      <span style="color:#f92672">&#34;endOffset&#34;</span>: <span style="color:#ae81ff">16</span>,
      <span style="color:#f92672">&#34;position&#34;</span>: <span style="color:#ae81ff">14</span>
    }
  ]
}
</code></pre></div><p>このAzure SearchのAnalyze API、使用できるオプションはすくないですが、<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/indices-analyze.html">ElasticsearchのAnalyze API</a>と似ています。</p>
<h2 id="データの登録の仕方">データの登録の仕方</h2>
<p>データ登録もAPIからできます(あたりまえですね)。
<a href="https://docs.microsoft.com/ja-jp/rest/api/searchservice/addupdate-or-delete-documents">APIは1件ずつではなく、バルクで登録できる形で提供されています</a>。</p>
<p>サンプルとしては、以下のような形です。
<code>@search.action</code>の部分(<code>search</code>があるとわかりにくい気がするけど。。。)が、ドキュメントの登録、更新、削除の命令を書き込むところになります。
今回は単純に登録するだけなので、<code>upload</code>を指定しました。
ほかにも<a href="https://docs.microsoft.com/ja-jp/rest/api/searchservice/addupdate-or-delete-documents#document-actions">いくつかアクションが用意されています。</a>用途に合わせて指定する感じになります。
<code>id</code>、<code>ngram</code>はそれぞれフィールド名です。ドキュメントに登録したい値を記述します。</p>
<pre><code>
POST https://{{host}}/indexes/ngram-test/docs/index?api-version=2019-05-06
Content-Type: application/json
api-key: {{api-key}}

{
  &quot;value&quot;: [
    {          
      &quot;@search.action&quot;: &quot;upload&quot;,  
      &quot;id&quot;: &quot;1&quot;,
      &quot;ngram&quot;: &quot;新しいAzure Searchの使い方&quot;
    },
    {          
      &quot;@search.action&quot;: &quot;upload&quot;,  
      &quot;id&quot;: &quot;2&quot;,
      &quot;ngram&quot;: &quot;Elasticsearchの紹介&quot;
    }
  ]
}

</code></pre><h2 id="検索クエリ">検索クエリ</h2>
<p>最後は検索クエリです。
<a href="https://docs.microsoft.com/ja-jp/azure/search/search-query-overview">検索クエリはいくつかのオプションがあります</a>。
ざっくりだと、<code>queryType</code>が<code>simple</code>と<code>full</code>という2種類が用意されており、ちょっとした検索を作る場合は<code>simple</code>で事足りそうという感じです。
入力された単語(スペース区切りで複数扱い)をフィールド(複数可)に対していずれかの単語を含むもしくは、すべての単語を含むという検索に行くというパターンですね。
このときの、「いずれか」か「すべて」の設定が<a href="https://docs.microsoft.com/ja-jp/azure/search/search-query-overview#tips-for-unexpected-results"><code>searchMode</code></a>というパラメータになります。
<code>any</code>の場合、Googleの検索と同様に、どれかの単語が入っているドキュメントが対象に、<code>all</code>の場合すべての単語が含まれるドキュメントだけがたいしょうになるといった形です。</p>
<p><code>queryType=full</code>の場合はLuceneの構文でクエリがかけます。Elasticsearchの<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-query-string-query.html">Query String Query</a>みたいな形です。</p>
<p>簡単なサンプルは次のような感じです。このサンプル</p>
<pre><code>
POST https://{{host}}/indexes/multi-field-test/docs/search?api-version=2019-05-06
Content-Type: application/json
api-key: {{api-key}}

{
   &quot;search&quot;: 'ngram:&quot;使い方&quot; ngram:&quot;紹介&quot;',
   &quot;queryType&quot;: &quot;full&quot;,
   &quot;searchMode&quot;: &quot;any&quot;
}
</code></pre><p>すこしだけクエリの補足を。
searchに入力された単語をダブルクォートで囲んでいます。これは、「使い方」という文字がbi_gram_analyzerにより「使い」「い方」に
分割されるのですが、必ずこの順序で出現したものだけを検索対象にしたい(フレーズ検索)という意味になります(*bi_*gramなので、「紹介」に関してはダブルクォートは厳密には必要ないです)。</p>
<p>あと、レスポンスは今回記載していませんが、<code>@search.score</code>という項目で、スコアが返ってきます。
デフォルトのスコア計算には何を使ってるんだろう?<a href="https://docs.microsoft.com/ja-jp/azure/search/index-add-scoring-profiles#what-is-default-scoring">ドキュメントにはTF-IDFとの記述があるのですが</a>。。。カスタマイズもできそうです。</p>
<p>少しオモシロイと思ったのは、スキーマ(インデックスの設定)に定義されているが、ドキュメントとしては登録していない項目についても、
Azure Cognitive Searchはドキュメントのフィールドが<code>null</code>という形で返ってくるようでした。
そもそもフィールドが存在しないドキュメントとフィールドの値が<code>null</code>のものの違いは無いようです。</p>
<p>簡単ですが、インデックスの設定、ドキュメントの登録、検索の方法の紹介でした。</p>
<h2 id="ちょっと触った感想">ちょっと触った感想</h2>
<p>一番売りである、Cognitiveの部分はまだ触っていないです、すみません(こっちが売りな気もするんですが)。
検索エンジンの部分としては、Elasticsearchを知っていると、「あー、そんな感じね」という気持ちになれるサービスです。
個々のAPIやデータの形式は異なるので、きちんとAPIのリファレンスなどを確認しつつという形になりますが、なんとなくこういうAPIなどがありそうだな?と予測しつつ使えるかなと。
内部的にはElasticsearchだと思いますが、独自のAPIでラップされているおかげで、バージョンの違いなどを意識せずに使えるのではないかと思います。</p>
<p>また、今回は紹介していませんが、マイクロソフト独自の各言語のアナライザー(日本語も含む)があります。
Luceneのアナライザーとマイクロソフトのアナライザーのどちらも利用できますので、ここの違いを見てみるのも面白そうだなと思いました。
緯度経度を利用した検索、フィルター検索(スコア計算対象にならない)、ファセット、スコア調整の機能なども備えているようです。</p>
<p>なんにせよ、利用する場合やドキュメントを読む場合に、全文検索の仕組みをなんとなく知っておいたほうが読みやすいんじゃないかなというのが感想です。</p>
<p>ここ数年はElasticsearchがメインでほかはほぼ触っていない状況だったので新しい製品に触れるのは面白いですね。
時間があったら、アナライザーの違いなども調べてみたいなと思います。</p>
</content:encoded>
    </item>
    
  </channel>
</rss>
