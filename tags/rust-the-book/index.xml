<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>rust-the-book on @johtaniの日記 3rd</title>
    <link>https://blog.johtani.info/tags/rust-the-book/</link>
    <description>Recent content in rust-the-book on @johtaniの日記 3rd</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja</language>
    <lastBuildDate>Thu, 09 Jul 2020 18:59:38 +0900</lastBuildDate><atom:link href="https://blog.johtani.info/tags/rust-the-book/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Rust the book - 第15章</title>
      <link>https://blog.johtani.info/blog/2020/07/09/hap15-rust-the-book/</link>
      <pubDate>Thu, 09 Jul 2020 18:59:38 +0900</pubDate>
      
      <guid>https://blog.johtani.info/blog/2020/07/09/hap15-rust-the-book/</guid>
      <description>前回の記事はこちら。自分用のメモなので、読みにくいかもです。 Rust the Bookを読み始めた Rust the book - 第4章 Rust the book - 第5章 Rust the book - 第6章 Rust the book - 第8章</description>
      <content:encoded><p>前回の記事はこちら。自分用のメモなので、読みにくいかもです。</p>
<ul>
<li><a href="/blog/2020/03/23/start-reading-rust-the-book/">Rust the Bookを読み始めた</a></li>
<li><a href="/blog/2020/03/26/chap4-rust-the-book/">Rust the book - 第4章</a></li>
<li><a href="/blog/2020/04/02/chap5-rust-the-book/">Rust the book - 第5章</a></li>
<li><a href="/blog/2020/04/07/chap6-rust-the-book/">Rust the book - 第6章</a></li>
<li><a href="/blog/2020/04/16/chap8-rust-the-book/">Rust the book - 第8章</a></li>
<li><a href="/blog/2020/05/14/chap9-rust-the-book/">Rust the book - 第9章</a></li>
<li><a href="/blog/2020/05/28/chap10-rust-the-book/">Rust the book - 第10章</a></li>
<li><a href="/blog/2020/06/04/chap13-rust-the-book/">Rust the book - 第13章</a></li>
</ul>
<p>14章は飛ばして、15章です(Cargoはまた別途調べればいいかな?と思って)。</p>
<h2 id="第15章-スマートポインタ">第15章 スマートポインタ</h2>
<p>たぶん、これを理解すれば、参照とベクタや構造体とかの組み合わせがもう少し効率よく使えるようになるのかなぁ?</p>
<ul>
<li>ポインタの強い版?
<ul>
<li>参照カウント方式のスマートポインタ型 - Luceneとかで実装されてた気がするなぁ
<ul>
<li>複数の所有者!?</li>
</ul>
</li>
</ul>
</li>
<li>DerefとDropトレイトを実装している構造体</li>
</ul>
<h3 id="ヒープのデータを指すboxtを使用する">ヒープのデータを指すBox<T>を使用する</h3>
<p>これはコンパイルエラー。<code>let y</code>のタイミングで借用してるので、書き換えでエラーになる。</p>
<pre><code>fn main() {
    let mut x = 5;
    let y = &amp;x;

    assert_eq!(5, x);
    assert_eq!(5, *y);
    x = 6;
    assert_eq!(6, x);
    assert_eq!(6, *y);
}
</code></pre><p>こっちはOK。</p>
<pre><code>fn main() {
    let mut x = 5; // in stack
    let y = Box::new(x); // in heap

    assert_eq!(5, x);
    assert_eq!(5, *y);
    x = 6;
    assert_eq!(6, x);
    assert_eq!(6, *y);
}
</code></pre><p>余談:コンパイラが変なワーニングを出してくれた。</p>
<pre><code>use std::ops::Deref;

impl&lt;T, Z&gt; Deref for MyBox&lt;T, Z&gt; {
    type Target = T;

    fn deref(&amp;self) -&gt; &amp;T {
        &amp;self.0
    }
}

struct MyBox&lt;T, Z&gt;(T, Z);

impl&lt;T, Z&gt; MyBox&lt;T, Z&gt; {
    fn new(x: T, y: Z) -&gt; MyBox&lt;T, Z&gt; {
        MyBox(x, y)
    }
}

fn main() {
    let x = 5;
    let z = &quot;10&quot;;
    let y = MyBox::new(x, z);

    assert_eq!(5, x);
    assert_eq!(5, *y);
}

</code></pre><h3 id="derefトレイトでスマートポインタを普通の参照のように扱う">Derefトレイトでスマートポインタを普通の参照のように扱う</h3>
<ul>
<li><code>参照外し型強制</code> : 日本語ムズカシイネ</li>
<li>Derefを自分で実装しないといけない場面がちょっと想像できてない。たぶん、Boxとかの説明に必要なので出てきたって感じなんだろうけど。</li>
</ul>
<h3 id="dropトレイトで片付け時にコードを走らせる">Dropトレイトで片付け時にコードを走らせる</h3>
<ul>
<li>こっちは、リソース開放とかでいい感じにできそうだってのはわかった。</li>
<li>Dropはどんなときに実装するんだろう?Tantivyだとオブジェクトプールとかで使ってた。</li>
</ul>
<h3 id="rctは参照カウント方式のスマートポインタ">Rc<T>は、参照カウント方式のスマートポインタ</h3>
<ul>
<li>これ、ここで作ったConsのリストを追っかけるためのサンプルも書いてほしい。</li>
</ul>
<pre><code>#[derive(Debug)]
enum List {
    Cons(i32, Rc&lt;List&gt;),
    Nil,
}

fn print_typename&lt;T&gt;(_: T) {
    println!(&quot;{}&quot;, std::any::type_name::&lt;T&gt;());
}

use List::{Cons, Nil};
use std::rc::Rc;
use std::borrow::Borrow;

fn main() {
    let z = Cons(5, Rc::new(Cons(10, Rc::new(Nil))));
    let a = Rc::new(z);
    let _b = Cons(3, Rc::clone(&amp;a));
    let _c = Cons(4, Rc::clone(&amp;a));
    match &amp;(*a) {
        Cons(v1, v2) =&gt; {
            print_typename(v2);
            println!(&quot;{}, {:?}&quot;, v1, v2);
        },
        Nil =&gt; println!(&quot;Nil!!&quot;)
    };
}
</code></pre><h3 id="refcelltと内部可変性パターン">RefCell<T>と内部可変性パターン</h3>
<ul>
<li></li>
</ul>
<h3 id="循環参照はメモリをリークすることもある">循環参照は、メモリをリークすることもある</h3>
</content:encoded>
    </item>
    
    <item>
      <title>Rust the book - 第13章</title>
      <link>https://blog.johtani.info/blog/2020/06/04/chap13-rust-the-book/</link>
      <pubDate>Thu, 04 Jun 2020 17:37:29 +0900</pubDate>
      
      <guid>https://blog.johtani.info/blog/2020/06/04/chap13-rust-the-book/</guid>
      <description>前回の記事はこちら。自分用のメモなので、読みにくいかもです。 Rust the Bookを読み始めた Rust the book - 第4章 Rust the book - 第5章 Rust the book - 第6章 Rust the book - 第8章</description>
      <content:encoded><p>前回の記事はこちら。自分用のメモなので、読みにくいかもです。</p>
<ul>
<li><a href="/blog/2020/03/23/start-reading-rust-the-book/">Rust the Bookを読み始めた</a></li>
<li><a href="/blog/2020/03/26/chap4-rust-the-book/">Rust the book - 第4章</a></li>
<li><a href="/blog/2020/04/02/chap5-rust-the-book/">Rust the book - 第5章</a></li>
<li><a href="/blog/2020/04/07/chap6-rust-the-book/">Rust the book - 第6章</a></li>
<li><a href="/blog/2020/04/16/chap8-rust-the-book/">Rust the book - 第8章</a></li>
<li><a href="/blog/2020/05/14/chap9-rust-the-book/">Rust the book - 第9章</a></li>
<li><a href="/blog/2020/05/28/chap10-rust-the-book/">Rust the book - 第10章</a></li>
</ul>
<p>11章、12章はちょっと飛ばして、13章です。</p>
<h2 id="第13章">第13章</h2>
<p>イテレータ、クロージャです。
12章の話もちょっと出てくるのか。</p>
<h3 id="クロージャ">クロージャ</h3>
<p>基本的に、「変数には値が束縛されている」という固定観念がずっと頭にこびりついたままなので、クロージャに慣れないんだろうなぁ。そろそろこの固定概念をどうにかしないと。</p>
<ul>
<li>匿名関数で、変数に保存したり引数に渡せる</li>
<li>ちょっと面白い話(ワークアウト)で実際に考えられる手法の説明がいくつか行われる</li>
</ul>
<ol>
<li>関数でリファクタリング
<ul>
<li>これが自分がよくやるパターンかなぁ。クロージャになれてないので。。。</li>
</ul>
</li>
<li>クロージャーを変数に束縛
<ul>
<li>呼び出しは関数みたいな感じ(ここで少し混乱)</li>
<li>これだと、結局呼び出されたタイミングが複数回あるよね? -&gt; あはりそうだった</li>
</ul>
</li>
</ol>
<p>ここで、閑話休題で、クロージャの型推論とか注釈の話。
クロージャは狭い文脈だし、外に公開しているものでもないので、戻り値なども定義してなくてもいいよねとのこと。書くことも可能?なので、書いてわかりやすくするのもありなんだろうな。</p>
<p>推論についてはこれまで通りで、2回異なる型の変数で呼び出すと、2回目で怒られていた。</p>
<ol start="3">
<li>遅延評価(クロージャを保持する構造体!?)
<ul>
<li><code>Fn</code>トレイト</li>
<li>トレイトとMatchの組み合わせだからこのへんで説明する形になるのか。</li>
<li>これを真似すれば、いくつか処理を簡素化できるかもしれないなぁ、たしかに。</li>
<li>なければ実行するみたいな処理を書きたいことがよくあるし。Javaだとnullで定義しといて、nullだったらみたいなのがあるから。</li>
</ul>
</li>
</ol>
<ul>
<li>
<p><code>Cacher</code>はサンプルだからこの名前でいいけど、自分だと、どんな名前にするかなぁ?</p>
</li>
<li>
<p>振る舞いは難しくなるのか。<code>Cacher実装の限界</code>を読むと。</p>
</li>
<li>
<p>関数にするとスコープが変わるのでアクセスできなくなると。。。コンパイラが教えてくれるのは便利だな。</p>
</li>
<li>
<p>環境から値をキャプチャする3つの方法</p>
<ul>
<li>多分この話が一番クロージャに意味がある話なんだと思う。</li>
</ul>
</li>
</ul>
<h3 id="イテレータ">イテレータ</h3>
<p>回しましょう。</p>
<ul>
<li>便利。ただ、こういう書き方に自分が慣れてないので、そっちを補正しないとなぁ。</li>
<li>どれがイテレータ?っていうのを判別するのがちょっとむずかしい(慣れの問題かなぁ)</li>
<li>イテレータアダプタ便利。どんなのがあるのか?とかがやっとわかってきた。</li>
<li>パフォーマンスに関しては、うーん、どうなんだろう?という感想だった。</li>
</ul>
</content:encoded>
    </item>
    
    <item>
      <title>Rust the book - 第10章</title>
      <link>https://blog.johtani.info/blog/2020/05/28/chap10-rust-the-book/</link>
      <pubDate>Thu, 28 May 2020 18:06:55 +0900</pubDate>
      
      <guid>https://blog.johtani.info/blog/2020/05/28/chap10-rust-the-book/</guid>
      <description>前回の記事はこちら。自分用のメモなので、読みにくいかもです。 Rust the Bookを読み始めた Rust the book - 第4章 Rust the book - 第5章 Rust the book - 第6章 Rust the book - 第8章</description>
      <content:encoded><p>前回の記事はこちら。自分用のメモなので、読みにくいかもです。</p>
<ul>
<li><a href="/blog/2020/03/23/start-reading-rust-the-book/">Rust the Bookを読み始めた</a></li>
<li><a href="/blog/2020/03/26/chap4-rust-the-book/">Rust the book - 第4章</a></li>
<li><a href="/blog/2020/04/02/chap5-rust-the-book/">Rust the book - 第5章</a></li>
<li><a href="/blog/2020/04/07/chap6-rust-the-book/">Rust the book - 第6章</a></li>
<li><a href="/blog/2020/04/16/chap8-rust-the-book/">Rust the book - 第8章</a></li>
<li><a href="/blog/2020/05/14/chap9-rust-the-book/">Rust the book - 第9章</a></li>
</ul>
<h2 id="第10章">第10章</h2>
<p>ジェネリック、トレイト、ライフタイムです。
手強そう。</p>
<p>いきなり関数の切り出し方みたいな話が始まって面食らいました。</p>
<h3 id="ジェネリックなデータ型">ジェネリックなデータ型</h3>
<p>ジェネリックはJavaにもあるので、それほど理解に苦しむことはなかったです。
また、OptionやResultですでに経験済みでしたし。</p>
<p>ただ、<code>impl&lt;T&gt; Point&lt;T&gt;{</code>、このメソッド定義は少し最初は戸惑いました。
言われてみれば、なるほどなんですけど。</p>
<p>コンパイル時にコンパイラが単相化を行うことにより、必要最低限なコードを生成してくるというのは理にかなっているなぁと。</p>
<h3 id="トレイト-共通の振る舞いを定義する">トレイト: 共通の振る舞いを定義する</h3>
<p>出だしにもありますが、「インターフェイス」という機能に類似していると考えると割とすんなりと理解が進みました。
ただ、Javaだと、インターフェースはクラスとセットなため、トレイとの実装に関する記述方法は少し戸惑いが。</p>
<p>デフォルト実装との組み合わせはAbstractに似た処理になるなと考えながら読みすすめました。</p>
<p>「トレイト境界」という日本語には少し違和感を覚えましたが、線引をして、制限をかけるという理解でいいのかな?</p>
<p>実際には<code>#[derive()]</code>などで、トレイトを自分で実装する必要がないなどの、便利機能も用意されており、このあたりのコードの追い方がまだ少し慣れていないかもなぁと。便利なんですけど。。。</p>
<p>少しだけ気になったので、動作確認したのは次の実装です。</p>
<p>トレイトで宣言されている関数と構造体が独自に実装する関数の名前がかぶるとどうなるのかという実験です。
構造体独自のメソッドが優先される感じになりそう。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Tweet</span> {
    <span style="color:#66d9ef">pub</span> username: String,
    <span style="color:#66d9ef">pub</span> content: String,
    <span style="color:#66d9ef">pub</span> reply: <span style="color:#66d9ef">bool</span>,
    <span style="color:#66d9ef">pub</span> retweet: <span style="color:#66d9ef">bool</span>,
}
<span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">trait</span> Summary {
    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">summarize_author</span>(<span style="color:#f92672">&amp;</span>self) -&gt; String;
    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">summarize</span>(<span style="color:#f92672">&amp;</span>self) -&gt; String {
        <span style="color:#75715e">// {}さんからもっと読む
</span><span style="color:#75715e"></span>        format<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;(Read more from {}...)&#34;</span>, self.summarize_author())
    }
}
<span style="color:#66d9ef">impl</span> Tweet {
    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">summarize_author</span>(<span style="color:#f92672">&amp;</span>self) -&gt; String {
        format<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;hoge {}&#34;</span>, self.username)
    }
    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">to_string</span>(<span style="color:#f92672">&amp;</span>self) -&gt; String {
        format<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;fuga&#34;</span>)
    }
}
<span style="color:#66d9ef">impl</span> Summary <span style="color:#66d9ef">for</span> Tweet {
    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">summarize_author</span>(<span style="color:#f92672">&amp;</span>self) -&gt; String {
        format<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;@{}&#34;</span>, self.username)
    }
}
<span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">summary</span><span style="color:#f92672">&lt;</span>T: <span style="color:#a6e22e">Summary</span><span style="color:#f92672">&gt;</span>(hoge: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">T</span>) {
    println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;{}&#34;</span>, hoge.summarize_author());
}
<span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">let</span> tweet <span style="color:#f92672">=</span> Tweet {
        username: String::from(<span style="color:#e6db74">&#34;horse_ebooks&#34;</span>),
        content: String::from(<span style="color:#e6db74">&#34;of course, as you probably already know, people&#34;</span>),
        reply: <span style="color:#a6e22e">false</span>,
        retweet: <span style="color:#a6e22e">false</span>,
    };
    println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;{}&#34;</span>, tweet.summarize_author());
    summary(<span style="color:#f92672">&amp;</span>tweet);
    println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;{}&#34;</span>, Summary::summarize_author(<span style="color:#f92672">&amp;</span>tweet));
}
</code></pre></div><h3 id="ライフタイムで参照を有効化する">ライフタイムで参照を有効化する</h3>
<p>言われてみればそうですが、プログラマが色々考えないとまぁ、行けないんですねという感想。</p>
<p>ただ、借用チェッカーが賢くやってくれるおかげで、全てにライフタイム注釈をつけなくて良くなっているというのがわかりました。
逆に言うと、なんとなくRustを書き始めてしまったので、それを知らずに書いたせいで、コンパイラに怒られてても「?」となっていたのかと。。。</p>
<p>疑問点がいくつかあって、</p>
<ul>
<li>通常はどんなライフタイム注釈をみんな書いてるんだろう?<code>'a</code>とかざっくりしすぎてる?</li>
<li>1つのメソッド、関数にライフタイム注釈が大量に出てくるような書き方をした場合は設計がおかしいのでは?って考えたほうがいいのかも?</li>
<li>ジェネリックな型とライフタイム引数の順序を入れ替えてみても動くだろ?とおもって入れ替えてみたら怒られた。</li>
</ul>
<p>あとは、構造体+ジェネリックが絡んできたら少しこんがらがってきそうっという感じです。
まぁ、これから先は実際に書いてみないことにはわからないんだろうなと。</p>
<h2 id="まとめ">まとめ</h2>
<p>読みました。
実際にはプログラムを書きながら慣れていく感じだろうなぁと。
まだまだ、あれ?ジェネリックってどう書くんだっけ?とか、ライフタイム注釈どうやって付けて、使うときはどうすんだ?みたいになりながら、
出てくるサンプルを少し変えてみてはどうやって動くんだろうこの場合?みたいなことをやってました。
次は、11章、12章を少しだけ自習しつつ、13章に入る予定です(知り合いと一緒に読みすすめてる)。</p>
</content:encoded>
    </item>
    
    <item>
      <title>Rust the book - 第9章</title>
      <link>https://blog.johtani.info/blog/2020/05/14/chap9-rust-the-book/</link>
      <pubDate>Thu, 14 May 2020 18:43:26 +0900</pubDate>
      
      <guid>https://blog.johtani.info/blog/2020/05/14/chap9-rust-the-book/</guid>
      <description>前回の記事はこちら。自分用のメモなので、読みにくいかもです。 Rust the Bookを読み始めた Rust the book - 第4章 Rust the book - 第5章 Rust the book - 第6章 Rust the book - 第8章</description>
      <content:encoded><p>前回の記事はこちら。自分用のメモなので、読みにくいかもです。</p>
<ul>
<li><a href="/blog/2020/03/23/start-reading-rust-the-book/">Rust the Bookを読み始めた</a></li>
<li><a href="/blog/2020/03/26/chap4-rust-the-book/">Rust the book - 第4章</a></li>
<li><a href="/blog/2020/04/02/chap5-rust-the-book/">Rust the book - 第5章</a></li>
<li><a href="/blog/2020/04/07/chap6-rust-the-book/">Rust the book - 第6章</a></li>
<li><a href="/blog/2020/04/16/chap8-rust-the-book/">Rust the book - 第8章</a></li>
</ul>
<h2 id="第9章">第9章</h2>
<p>エラー処理です。
NLP100とか、いくつかのプログラムを書いていて、なんとなくは扱っていますが、きちんと勉強しないと。</p>
<p>とりあえず、「Rustには例外は存在しません。」が一番知っておくことかな。</p>
<h3 id="panicで回復不能なエラー">panic!で回復不能なエラー</h3>
<ul>
<li><code>panic!</code>マクロでスタックを巻き戻して掃除をして終了。
<ul>
<li>異常終了(<code>panic = 'abort'</code>)にもできる。</li>
</ul>
</li>
<li>「<code>RUST_BACKTRACE</code>を0以外の変数にセットして実行」
*</li>
</ul>
<h3 id="resultで回復可能なエラー">Resultで回復可能なエラー</h3>
<ul>
<li><code>expect()</code>は気持ち悪い名前じゃないかなぁ?</li>
<li><a href="https://doc.rust-jp.rs/book/second-edition/ch09-02-recoverable-errors-with-result.html#a%E3%82%A8%E3%83%A9%E3%83%BC%E3%82%92%E5%A7%94%E8%AD%B2%E3%81%99%E3%82%8B">ここ</a>で<code>io::Error</code>ではないものもエラーが発生する場合には</li>
</ul>
<h3 id="panicすべきかするまいか">panic!すべきかするまいか</h3>
<h2 id="まとめ">まとめ</h2>
<p>「Rustには例外は存在しない」ので、回復不能か可能かを考えつつ処理を書こうと。</p>
</content:encoded>
    </item>
    
    <item>
      <title>Rust the book - 第8章</title>
      <link>https://blog.johtani.info/blog/2020/04/16/chap8-rust-the-book/</link>
      <pubDate>Thu, 16 Apr 2020 18:17:30 +0900</pubDate>
      
      <guid>https://blog.johtani.info/blog/2020/04/16/chap8-rust-the-book/</guid>
      <description>前回の記事はこちら。自分用のメモなので、読みにくいかもです。 Rust the Bookを読み始めた Rust the book - 第4章 Rust the book - 第5章 Rust the book - 第6章 第8章 7章はパ</description>
      <content:encoded><p>前回の記事はこちら。自分用のメモなので、読みにくいかもです。</p>
<ul>
<li><a href="/blog/2020/03/23/start-reading-rust-the-book/">Rust the Bookを読み始めた</a></li>
<li><a href="/blog/2020/03/26/chap4-rust-the-book/">Rust the book - 第4章</a></li>
<li><a href="/blog/2020/04/02/chap5-rust-the-book/">Rust the book - 第5章</a></li>
<li><a href="/blog/2020/04/07/chap6-rust-the-book/">Rust the book - 第6章</a></li>
</ul>
<h2 id="第8章">第8章</h2>
<p>7章はパッケージなので後回しにして、8章に入ります。
8章はコレクションです。</p>
<h3 id="ベクタ型">ベクタ型</h3>
<ul>
<li>ベクタは同じ型の値だけ保持可能。
<ul>
<li>ジェネリクスで型を指定可能 - <code>Vec&lt;i32&gt;</code>とか。</li>
</ul>
</li>
<li><code>vec!</code>マクロで初期値とか設定すると便利。</li>
<li>ベクタに値を追加するのは<code>push</code>。もちろん値が変わるので元のベクタには<code>mut</code>が必要</li>
<li>ベクタのスコープ(ライフサイクル)は要素に対する参照があるのとないので話が変わってくる
<ul>
<li>メモリの確保などの影響で、ベクタ全体に対して借用の規則が矯正されると。</li>
</ul>
</li>
<li>ベクタの値を読むのはいくつか方法あり
<ul>
<li><code>get</code>メソッドはOptionを返す</li>
<li><code>&amp;v[2]</code>の添字記法の場合はパニックの可能性あり</li>
</ul>
</li>
<li>走査(唐突に参照外しが出てきた)
<ul>
<li>単純に値を取り出す場合は<code>for - in &amp;v</code></li>
</ul>
</li>
<li>Enumをベクタにいれることで、異なる型も保持可能(まぁ、Enumの型では固定されるけど)。
<ul>
<li>これだけのためにEnumを使うことってあるのかな?</li>
<li>トレイとオブジェクトに関する文章はちょっとわかりにくい。。。</li>
</ul>
</li>
</ul>
<p>説明以外のメソッドなどについてはAPIドキュメント見ましょうと(リンクも張ってくれてると嬉しいなぁと思ったり。まぁ、バージョンとかの絡みがあるから難しいか)。</p>
<h3 id="文字列型">文字列型</h3>
<ul>
<li>
<p>文字列はUTF-8でエンコードされた文字を扱うための型。</p>
</li>
<li>
<p><code>str</code>は文字列データへの参照。</p>
</li>
<li>
<p><code>String</code>型は言語のコアではなく、標準ライブラリに入っている文字列型。</p>
<ul>
<li>他にもあるのか。。。<code>OsString</code>とか。。。</li>
</ul>
</li>
<li>
<p>文字リテラルはDisplayトレイトを実装していると。</p>
</li>
<li>
<p><code>.to_string()</code> = <code>String::from</code></p>
</li>
<li>
<p>Stringはコレクションだから追加とかが可能なのか、なるほど。</p>
</li>
<li>
<p><code>push_str</code>と<code>push</code></p>
</li>
<li>
<p><a href="https://doc.rust-jp.rs/book/second-edition/ch08-02-strings.html#a%E6%BC%94%E7%AE%97%E5%AD%90%E3%81%BE%E3%81%9F%E3%81%AFformat%E3%83%9E%E3%82%AF%E3%83%AD%E3%81%A7%E9%80%A3%E7%B5%90"><code>+</code>演算子での参照</a>。</p>
<ul>
<li><code>&amp;String</code>は<code>&amp;str</code>に型強制(キャスト?)してくれる。してくれる場合としてくれない場合もあるのかな?<code>s2</code>の所有権は奪わない形で扱うので<code>s2</code>はこのあとも使えていると。</li>
<li>ここでは、<code>s1</code>を変更したあとに所有権が<code>s3</code>に持っていかれてる?</li>
<li><code>format!</code>を使うとどの所有権も奪わないので、これを使うほうが考え方は簡単そう。ただし、効率がいいかはわからん。</li>
</ul>
</li>
<li>
<p>添字記法でのアクセスを<code>String</code>は許容していない</p>
<ul>
<li>文字の境界が必ずしも1バイトとは限らないから。</li>
<li>スライスも同様。</li>
</ul>
</li>
<li>
<p>基本的には<code>.chars()</code>で文字としてアクセスするのが良い。</p>
</li>
<li>
<p>逆にバイト表現を得る方法はどうするんだろう?</p>
<ul>
<li><a href="https://github.com/johtani/nlp100-rust/blob/master/src/chapter01/answer.rs#L155">NLP100本ノックでは<code>encode_utf8</code>メソッド使ったけど。</a></li>
</ul>
</li>
</ul>
<h3 id="ハッシュマップ">ハッシュマップ</h3>
<ul>
<li>いろんな呼び方あるよね。Rustではハッシュマップだよ。</li>
<li>ハッシュマップは<code>use</code>しないと使えない</li>
<li>キーは1つの型、値も1つの型</li>
<li>タプルのベクタから<code>collect</code>で生成。なるほど。
<ul>
<li>タプルのベクタだと、タプルの中身は同じものであることが言える?
<ul>
<li>-&gt; 言える。エレメント数が異なるとコンパイルエラーになった</li>
</ul>
</li>
</ul>
</li>
<li><a href="https://doc.rust-jp.rs/book/second-edition/ch08-03-hash-maps.html#a%E3%83%8F%E3%83%83%E3%82%B7%E3%83%A5%E3%83%9E%E3%83%83%E3%83%97%E3%81%A8%E6%89%80%E6%9C%89%E6%A8%A9">所有権周りの話。</a>
<ul>
<li>これ、ベクタのときに話してほしい感じがした。</li>
<li>値を渡すか参照を渡すかによって話が変わってくる。詳しくは10章</li>
<li>このあたりが自分が混乱していた元だ。</li>
</ul>
</li>
<li><code>entry</code>と<code>insert</code>の違い
<ul>
<li><code>entry</code>の戻り値は<code>Entry</code>というenumで<code>or_insert</code>というメソッドがありそれを使うと存在しない場合だけinsertが呼ばれる。
<ul>
<li>これ便利だ。毎回<code>exist</code>あたりで存在チェックしてた気がする。</li>
</ul>
</li>
</ul>
</li>
<li><code>or_insert</code>は可変参照<code>&amp;mut V</code>を返す。
<ul>
<li>これを<code>let count</code>で束縛するときに、中身が可変かどうかをcountには指定しないのか。。。</li>
</ul>
</li>
</ul>
<h2 id="まとめ">まとめ</h2>
<p>一応、大学などで習ってた(はず)ですが、
スタックとヒープを意識して考えないといけないなぁというのを何度か意識させられた感じです。</p>
<p>あと、これはRustに限らずですが、それぞれがどんな関数を持っているか、どんなメソッドを持っているか、どんなマクロが存在するかなどを探すときにみんなどうしてるんだろう?
人に教えてもらっているのか、APIリファレンスを探すのか、そういったところをみんながどういう感じにプログラミング言語を勉強しているか、業務で書いているのかと言うのが気になりました。</p>
</content:encoded>
    </item>
    
    <item>
      <title>Rust the book - 第6章</title>
      <link>https://blog.johtani.info/blog/2020/04/07/chap6-rust-the-book/</link>
      <pubDate>Tue, 07 Apr 2020 19:27:11 +0900</pubDate>
      
      <guid>https://blog.johtani.info/blog/2020/04/07/chap6-rust-the-book/</guid>
      <description>前回の記事はこちら。自分用のメモなので、読みにくいかもです。 Rust the Bookを読み始めた Rust the book - 第4章 Rust the book - 第5章 第6章 Enumです。matc</description>
      <content:encoded><p>前回の記事はこちら。自分用のメモなので、読みにくいかもです。</p>
<ul>
<li><a href="/blog/2020/03/23/start-reading-rust-the-book/">Rust the Bookを読み始めた</a></li>
<li><a href="/blog/2020/03/26/chap4-rust-the-book/">Rust the book - 第4章</a></li>
<li><a href="/blog/2020/04/02/chap5-rust-the-book/">Rust the book - 第5章</a></li>
</ul>
<h2 id="第6章">第6章</h2>
<p>Enumです。<code>match</code>式に大活躍</p>
<h3 id="enumを定義する">Enumを定義する</h3>
<ul>
<li>列挙型は取りうる値をすべて<em>列挙</em>できる。これが名前の由来</li>
<li>列挙型と列挙子
<ul>
<li>2連コロン(<code>::</code>)で列挙子を指定可能</li>
</ul>
</li>
<li>列挙子にデータ(構造体も)が格納可能。
<ul>
<li><a href="https://doc.rust-lang.org/stable/std/net/enum.IpAddr.html">標準ライブラリに実装例あり。</a></li>
</ul>
</li>
<li>疑問:<code>Write(String)</code>とかはタプルの表現になるのかな?
<ul>
<li>と思ったが、タプルでは1つだけの変数を持つものは定義(正確には定義できるが、内部で普通の変数にもどされてるっぽい)できなかった。</li>
</ul>
</li>
<li>メソッド定義も可能
<ul>
<li>関連関数もできる? -&gt; できる</li>
</ul>
</li>
</ul>
<h4 id="optionの紹介">Optionの紹介</h4>
<ul>
<li>Rustに<code>null</code>はない。代わりにOptionがある</li>
<li>Noneを指定する場合に型が必要。Someの場合はすでに値が入るから推測可能なため。</li>
</ul>
<h3 id="match制御フロー演算子">match制御フロー演算子</h3>
<ul>
<li>アーム -&gt; matchしたときの処理のこと
<ul>
<li>短い場合は波括弧は不要</li>
</ul>
</li>
<li>returnなしでmatchが書いてあるだけだと、慣れない場合に値を返していることに気づかないかも(実際気づけてないかも)</li>
<li>Enumが値を持っているときに、値の束縛がmatch式で可能</li>
<li>すべての列挙子を網羅していないことをコンパイラが検知してくれるのはすごく助かる。
<ul>
<li>ただし、<code>_</code>を利用していなければだけど</li>
</ul>
</li>
</ul>
<h3 id="if-letで簡潔な制御フロー">if letで簡潔な制御フロー</h3>
<ul>
<li>enumで1つのパターンのときに処理をしたい場合に使えるmatchの糖衣構文</li>
<li>elseもかけるよ。</li>
</ul>
<h2 id="まとめ">まとめ</h2>
<p>enumに慣れていないので、値や構造体を持つenumを利用するという想像ができないことがありそうだなぁと読みながら思いました。
それになれると、色々とプログラムがシンプルに書ける部分が多くなりそうかな。</p>
</content:encoded>
    </item>
    
    <item>
      <title>Rust the book - 第5章</title>
      <link>https://blog.johtani.info/blog/2020/04/02/chap5-rust-the-book/</link>
      <pubDate>Thu, 02 Apr 2020 15:09:18 +0900</pubDate>
      
      <guid>https://blog.johtani.info/blog/2020/04/02/chap5-rust-the-book/</guid>
      <description>前回の記事はこちら。自分用のメモなので、読みにくいかもです。 Rust the Bookを読み始めた Rust the book - 第4章 第5章 構造体です。勝手知ったるなんとやら?</description>
      <content:encoded><p>前回の記事はこちら。自分用のメモなので、読みにくいかもです。</p>
<ul>
<li><a href="/blog/2020/03/23/start-reading-rust-the-book/">Rust the Bookを読み始めた</a></li>
<li><a href="/blog/2020/03/26/chap4-rust-the-book/">Rust the book - 第4章</a></li>
</ul>
<h2 id="第5章">第5章</h2>
<p>構造体です。勝手知ったるなんとやら?オブジェクト指向的な部分は問題ないかなぁと。</p>
<h3 id="定義とインスタンス化">定義とインスタンス化</h3>
<ul>
<li><code>struct</code>で定義</li>
<li>インスタンスの生成は引数は順不同でOK</li>
<li>構造体のインスタンスを可変にするとフィールドの値も変更可能
<ul>
<li>特定のフィールドのみ可変にすることは不可能</li>
</ul>
</li>
<li>インスタンス化する関数の最後でreturnなしでインスタンスの返却を暗黙にできる(return書いてほしいな。。。)</li>
<li>インスタンス化時にフィールド初期化省略記法が可能(これはちょっと便利?)</li>
<li>構造体更新記法<code>..user1</code>のように、明示的に設定されていない他のフィールドをコピーしてくれる機能あり</li>
</ul>
<h4 id="タプル構造体">タプル構造体</h4>
<ul>
<li>タプル構造体!? <code>struct Color(i32, i32, i32);</code>
<ul>
<li>いつ使うんだろう?</li>
</ul>
</li>
</ul>
<h4 id="ユニット様構造体">ユニット様構造体</h4>
<ul>
<li>ユニット様構造体 = フィールドのない構造体。トレイトを実装したいけどインスタンスで持つ値はない場合に利用</li>
</ul>
<h4 id="ライフタイム">ライフタイム</h4>
<ul>
<li>構造体が参照を持つときにライフタイムという話が出てくる。なるほど。
<ul>
<li>ライフタイム指定子が必要になる -&gt; 10章での話</li>
</ul>
</li>
</ul>
<h3 id="プログラム例">プログラム例</h3>
<ul>
<li>タプルを引数かぁ。タプルは慣れないので構造体作りそう</li>
<li>Debugトレイトと<code>{:?}</code>という書き方
<ul>
<li><code>derive(Debug)</code>でデバッグ用のトレイトを自動で実装=継承してくれる</li>
<li><code>{:#?}</code>だとpretty printになる(改行とか入る)</li>
</ul>
</li>
</ul>
<p>この辺の便利なトレイとは<a href="https://doc.rust-jp.rs/book/second-edition/appendix-03-derivable-traits.html">付録C</a>にあるらしい。この辺はやりながら覚えるしかないか。</p>
<h3 id="メソッド記法">メソッド記法</h3>
<ul>
<li>最初の引数は必ず<code>self</code></li>
<li><code>impl</code>は構造体とは別の場所に書く = Javaのクラスとは違う</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Rectangle</span> {
    width: <span style="color:#66d9ef">u32</span>,
    height: <span style="color:#66d9ef">u32</span>,
}

<span style="color:#66d9ef">impl</span> Rectangle {
    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">area</span>(<span style="color:#f92672">&amp;</span>self) -&gt; <span style="color:#66d9ef">u32</span> {
        self.width <span style="color:#f92672">*</span> self.height
    }
}
</code></pre></div><ul>
<li>参照じゃない<code>self</code>も使えるらしい。どういうときに使うんだろう?</li>
</ul>
<h4 id="関連関数">関連関数</h4>
<ul>
<li><code>self</code>なしの関数をimplにかける。Javaのスタティックメソッドみたいな感じ</li>
</ul>
<h4 id="その他">その他</h4>
<ul>
<li><code>impl</code>ブロックがあちこちにかける。これはつらいな。。。</li>
<li>2つにわかれた<code>impl</code>ブロックに同じメソッドを書いてみたら、CLionのプラグインではエラーを検知してもらえなかった。
<ul>
<li>cargo buildではきちんとエラーが表示された。</li>
</ul>
</li>
<li>
<blockquote>
<p>複数のimplブロックが有用になるケースは第10章で見ますが、そこではジェネリック型と、トレイトについて議論します。</p>
</blockquote>
<ul>
<li>人の構造体に自分のトレイトを適用したりもできる。</li>
</ul>
</li>
</ul>
<h4 id="実験">実験</h4>
<p>スコープとかどうなりそう?って実験もしてみた。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">trait</span> Hoge {
        <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">trim</span>(<span style="color:#f92672">&amp;</span>self);
    }

    <span style="color:#66d9ef">impl</span> Hoge <span style="color:#66d9ef">for</span> String {
        <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">trim</span>(<span style="color:#f92672">&amp;</span>self) {
            println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;hogehoge {}&#34;</span>, <span style="color:#f92672">&amp;</span>self);
        }
    }
    <span style="color:#66d9ef">let</span> c <span style="color:#f92672">=</span> String::from(<span style="color:#e6db74">&#34;hoge&#34;</span>);
    c.trim();
    println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;{}&#34;</span>, fuga(<span style="color:#f92672">&amp;</span>c));
}

<span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">fuga</span>(d: <span style="color:#66d9ef">&amp;</span>String) -&gt; <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">str</span> {
    d.trim()
}
</code></pre></div><p>出力はこんな感じ</p>
<pre><code>hogehoge hoge
hoge
</code></pre><h2 id="まとめ">まとめ</h2>
<p>気になったのは以下の点。そのうち分かるようになってくるのかな。</p>
<ul>
<li>構造体更新記法はどういったときに使うのを想定して作ったんだろう?とか</li>
<li>可変長引数はマクロじゃないとだめ</li>
</ul>
</content:encoded>
    </item>
    
    <item>
      <title>Rust the book - 第4章</title>
      <link>https://blog.johtani.info/blog/2020/03/26/chap4-rust-the-book/</link>
      <pubDate>Thu, 26 Mar 2020 17:12:11 +0900</pubDate>
      
      <guid>https://blog.johtani.info/blog/2020/03/26/chap4-rust-the-book/</guid>
      <description>前回の記事はこちら。自分用のメモなので、読みにくいかもです。 Rust the Bookを読み始めた 第4章 第4章です。たぶん、これがいちばん大事な概念だと思</description>
      <content:encoded><p>前回の記事はこちら。自分用のメモなので、読みにくいかもです。</p>
<ul>
<li><a href="https://blog.johtani.info/blog/2020/03/23/start-reading-rust-the-book/">Rust the Bookを読み始めた</a></li>
</ul>
<h2 id="第4章">第4章</h2>
<p>第4章です。たぶん、これがいちばん大事な概念だと思います、Rustの。
そして、つまみ食いしながらRust書いてましたが、ここがきちんと理解できないまま書いてたってのもあります。。。</p>
<h3 id="所有権とは">所有権とは?</h3>
<ul>
<li><code>drop</code>関数ってのがあって、明示的に呼ぶことも可能。次のような感じで。2つ目の<code>println!</code>はエラーになる。sがもう無いのに借用しようとしてるから。</li>
</ul>
<pre><code>fn main() {
    let mut s = String::from(&quot;hello&quot;);
    s.push_str(&quot;, world!&quot;);
    println!(&quot;{}&quot;, s);
    drop(s);
    println!(&quot;{}&quot;, s);
}
</code></pre><ul>
<li>ムーブ - shallow copyではない。以下の2行目がムーブ。</li>
</ul>
<pre><code>let s1 = String::from(&quot;hello&quot;);
let s2 = s1;

println!(&quot;{}, world!&quot;, s1);
</code></pre><p>スタックとヒープの話が絡んでくる。あんまり意識すること無いよなぁ。
スタック = 固定長のデータを入れる場所。ポインタ、数値など
ヒープ = 可変長のデータが入る場所。可変の文字列とか。</p>
<ul>
<li>クローン - ヒープのデータをコピーすること。</li>
<li>コピー - スタックに収まるデータの場合はクローンが必要なくコピーで事足りる。
<ul>
<li>CopyトレイととDropトレイとは同居できない。</li>
<li>タプルのコピーはややこしそう</li>
</ul>
</li>
<li><a href="https://doc.rust-jp.rs/book/second-edition/ch04-01-what-is-ownership.html#a%E6%89%80%E6%9C%89%E6%A8%A9%E3%81%A8%E9%96%A2%E6%95%B0">所有権と関数</a>でまた、スタックに入れられるような変数と可変のオブジェクトの違いが出てくる。
<ul>
<li><code>takes_ownership(s: String)</code>が参照を受け取れば問題なく、このあとも使える。</li>
<li>戻り値でもムーブが発生</li>
</ul>
</li>
</ul>
<h3 id="参照と借用">参照と借用</h3>
<ul>
<li>借用 - 関数の引数に参照を取ること</li>
<li>可変な参照<code>&amp;mut</code>は1つ(不変な参照も含めて1つ)しか許さない
<ul>
<li>データの競合を防ぐため。</li>
<li>不変な参照を複数用いるのはOK</li>
<li>実際に変更が実行されるタイミングでエラーと判定される場合もある。</li>
</ul>
</li>
</ul>
<pre><code>let mut s = String::from(&quot;hello&quot;);

{
    let r1 = &amp;mut s;

} // r1はここでスコープを抜けるので、問題なく新しい参照を作ることができる

let r2 = &amp;mut s;
</code></pre><ul>
<li>ダングリング参照はテスト書くときとかにやってるかも。。。</li>
</ul>
<pre><code>fn dangle() -&gt; &amp;String { // dangleはStringへの参照を返す

    let s = String::from(&quot;hello&quot;); // sは新しいString

    &amp;s // String sへの参照を返す
} // ここで、sはスコープを抜け、ドロップされる。そのメモリは消される。
  // 危険だ
</code></pre><h3 id="スライス型">スライス型</h3>
<ul>
<li>部分的な参照。開始位置+長さで構成されているっぽい</li>
<li><code>&amp;str</code>の説明がよくわからなかった。</li>
</ul>
<p><a href="https://doc.rust-jp.rs/book/second-edition/ch04-03-slices.html#a%E5%BC%95%E6%95%B0%E3%81%A8%E3%81%97%E3%81%A6%E3%81%AE%E6%96%87%E5%AD%97%E5%88%97%E3%82%B9%E3%83%A9%E3%82%A4%E3%82%B9">引数としての文字列スライス</a>のテクニックは色々と使いまわせそう。</p>
<h2 id="まとめ">まとめ</h2>
<p>所有権、これまで特に難しいと思ってたのは、固定長の変数と、可変長の変数の違いを意識してなかったのが原因っぽい。
まぁ、Vecとかがどうなるのかとか、他にもいくつか気になるところはあるので、もうちょっとやらないといけないなと思いました。</p>
</content:encoded>
    </item>
    
    <item>
      <title>Rust the Bookを読み始めた</title>
      <link>https://blog.johtani.info/blog/2020/03/23/start-reading-rust-the-book/</link>
      <pubDate>Mon, 23 Mar 2020 10:57:22 +0900</pubDate>
      
      <guid>https://blog.johtani.info/blog/2020/03/23/start-reading-rust-the-book/</guid>
      <description>自転車本を読み始めましたが、その前にRust the bookを読んだほうが良いかも?と知り合いと話をしていてなったので、先にRust the bookを読</description>
      <content:encoded><p>自転車本を読み始めましたが、その前にRust the bookを読んだほうが良いかも?と知り合いと話をしていてなったので、先にRust the bookを読み始めてます。
コツコツ読むってのが苦手なので、知り合いと小規模オンライン読書会しながら読むことになりました(基本的になにか書きながら、使い方を調べるので、存在そのものを知らない記述や使用法などがあったりする)。</p>
<ul>
<li><a href="https://doc.rust-jp.rs/book/second-edition/">日本語版Rust the book</a></li>
<li><a href="https://doc.rust-lang.org/book/title-page.html">Rust the book</a></li>
</ul>
<p>基本は日本語版を読んでいます。まずは1章から3章あたり。</p>
<p>気になった点などを。自分用のメモなので、読みやすさとかは考えてないです(あとで自分が死ぬパターン?)。</p>
<h2 id="1章">1章</h2>
<ul>
<li>
<p>rustfmt便利。</p>
<ul>
<li>CLionのRustプラグインでは、保存時にrustfmtするというオプションがある。デフォルトはオフ。&ldquo;Run rustfmt on Save&rdquo;</li>
</ul>
</li>
<li>
<p>cargoの<code>--bin</code>オプション。意識してつけたことなかった=デフォルトだった。</p>
<ul>
<li>ライブラリにするときは<code>--lib</code></li>
</ul>
</li>
</ul>
<h2 id="2章">2章</h2>
<ul>
<li>「変数を値に束縛」という言い回しにまだ慣れない。
<ul>
<li>「代入」という言い方に慣れているから?</li>
<li>ただ、エラーにはassignってあるな。&ldquo;error[E0384]: cannot assign twice to immutable variable <code>x</code>&rdquo;</li>
</ul>
</li>
<li>preludeというのがデフォルトで読み込まれる型が存在する場所。</li>
<li><code>.expect()</code>により、Resultが評価済みになる</li>
<li>マクロがまだ慣れない</li>
<li><code>extern crate rand;</code>が<a href="https://doc.rust-lang.org/book/ch02-00-guessing-game-tutorial.html#generating-a-random-number">最新版だと要らなくなっている</a>。</li>
<li><code>rand::Rng</code>は<code>gen_range</code>のためにuseしている。CLionだとかってにuseを推測して追加してくれた。</li>
<li><code>match</code>はswitch文みたいな感じ。けど、defaultが必ず実行されるって感じではないな。
<ul>
<li>ただし、全て網羅しないと怒られるのが便利。</li>
<li>アームという呼び方が新鮮</li>
<li>単一の式のときは{}が省略できる</li>
<li>ブロック{}のときは、終わりにカンマを入力するとrustfmtが除去する(最後の条件かどうかは関係ない)。</li>
</ul>
</li>
<li>シャドーイングは面白い。
<ul>
<li>よく、<code>hoge_str</code>や<code>hoge_int</code>のような変数を書くので、ありがたい。</li>
<li>ただし、コードを読むときに少し混乱しそう?</li>
</ul>
</li>
<li><code>let ... match</code>で変数への束縛でmatchが使えるのは便利(これまで知らなかったので、変数宣言して条件つけて束縛する処理書いてた)。</li>
</ul>
<h3 id="シャドーイング">シャドーイング?</h3>
<pre><code>fn main() {
    let x = 5;

    let x = x + 1;

    let x = x * 2;

    println!(&quot;The value of x is: {}&quot;, x);
}
</code></pre><p>とか</p>
<pre><code>let spaces = &quot;   &quot;;
let spaces = spaces.len();
</code></pre><p>みたいに、同一変数名を使い回せること。再代入ではない</p>
<h2 id="3章">3章</h2>
<ul>
<li>constは型注釈が必須</li>
<li><code>100_000</code>のような記述が便利(<a href="https://docs.oracle.com/javase/jp/8/docs/technotes/guides/language/underscores-literals.html">Javaもできるって言われてびっくりしたw</a>)</li>
<li>タプルの中身を一部だけ書き換え可能。(mutを指定すれば)
<ul>
<li><code>tup.0 = 20;</code>のような感じで。</li>
</ul>
</li>
<li>配列は固定長でかつ、同一の型のものだけが入る</li>
<li>文末にセミコロンがない場合に四季になるというのはちょっと射にくいので辛いのでは。。。
<ul>
<li>自分は明示的に<code>return</code>を書きたくなる。が、returnだと動かない場合もある。。。</li>
</ul>
</li>
<li><code>let ... if</code>のような記述もできる。</li>
<li><code>(1..4)</code>はRange型</li>
</ul>
<h3 id="おまけ">おまけ</h3>
<p>フィボナッチ数列計算してみろというのがまとめにあったので。こんな感じでいいのかな?</p>
<pre><code>fn calc_fibonacci(n: usize) -&gt; usize {
    if n == 0 {
        return 0;
    } else if n==1 {
        return 1;
    } else {
        return calc_fibonacci(n-1) + calc_fibonacci(n-2);
    }
}
</code></pre><h2 id="その他">その他</h2>
<p>知り合いと読みすすめると、人が不思議に思ったところが、自分が理解が曖昧だったことなどに気づけて便利です。</p>
</content:encoded>
    </item>
    
  </channel>
</rss>
